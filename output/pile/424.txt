{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "424",
    "text": "Q:\n\n\"Confused Digger\" algorithm running too slow, any way to speed it up?\n\nI have an algorithm that was based on a backtracking maze algorithm with some parts removed, resulting in this wonderful dungeon. Unfortunately, it runs extremely slowly which makes it almost impossible to fill a decently-sized map with. I really don't want to throw it out, but I can't think of any way to speed it up. I'm using Python, so I know that's part of my problem, but I'm not exactly prepared to throw out my roguelike's entire existing codebase, which runs fast enough right now. Here's the code currently:\n    start = (random.randint(0, self.width), random.randint(0, self.height))\n    self.dungeon['up_stairs'] = start\n\n    visited = [start]\n    while len(visited) < 300:\n        current = visited[-1]\n        apos = random.choice([(1, 0), (0, 1), (0, -1), (-1, 0)])\n        new = utils.tuple_add(current, apos)\n        if not new in visited and self.on_map(new):\n            self.place_cell(new, is_wall=False)\n            visited.append(new)\n        else:\n            visited.pop()\n\n[edit]\n\nTo answer some questions in the comments, place_cell either creates a wall or an empty cell at the supplied position-tuple based on the positional argument is_wall. So for instance, in the code above, the self.place_cell(new, is_wall=False) call changes the cell at the position new on the map to an empty cell.\nVisited should really be called something else, I'm just... lazy that way. I'll fix it later probably.\nThe < 300 condition is because 299 cells is the most it can draw in a reasonable time frame. (Beyond 299 cells, it suddenly starts hanging.)\n\nA:\n\nI would suggest following improvements:\n\nDo not pop a visited cell only because you failed on one step. This may lead to starvation: popping and trying again, popping ... etc. You should instead pick another cell you visited in the past, and continue from there. If that fails, pick another one...\nUse a set to keep track of the visited cells: this will allow faster lookup\nUse another \"frontier\" set for keeping track of which visited cells still have unvisited neighbours\nWhen a cell is visited, check all neighbours in random order whether they are unvisited. The first one that is will be your next visit. But if all of them were visited (or outside the grid) then choose a random cell from the frontier set.\n\nHere is the suggested code:\nstart = (random.randint(0, self.width-1), random.randint(0, self.height-1))\nself.dungeon['up_stairs'] = start\n\ncurrent = start\nfrontier = set()\nvisited = set([start])\nwhile len(visited) < 400:\n    frontier.add(current)\n    self.place_cell(current, is_wall=False)\n    found = False\n    while not found:\n        choices = [(1, 0), (0, 1), (0, -1), (-1, 0)]\n        random.shuffle(choices)\n        for apos in choices:\n            new = utils.tuple_add(current, apos)\n            if not new in visited and self.on_map(new):\n                found = True\n                break\n        if not found:\n            # we can remove this cell from frontier as it is \n            # completely surrounded by visited cells\n            frontier.discard(current)\n            # pick a random other one to start from\n            current = random.sample(frontier, 1)[0]\n    current = new    \n    visited.add(current)\n\n"
}