{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['1', '3', '4', '2', '1', '1', '2', '2', '2', '6', '7', '8']."
        }
    ],
    "doc_id": "7679",
    "text": "Status of this Memo\n\nThis document is an Internet-Draft and is subject to all provisions\nof section 3 of RFC 3667.\nBy submitting this Internet-Draft,\neach author represents that any applicable patent or other IPR claims of which\nhe or she is aware have been or will be disclosed,\nand any of which he or she become aware will be disclosed,\nin accordance with RFC 3668.\n\nInternet-Drafts are working documents of the Internet Engineering\nTask Force (IETF), its areas, and its working groups.\nNote that other groups may also distribute working documents as\nInternet-Drafts.\n\nInternet-Drafts are draft documents valid for a maximum of six months\nand may be updated, replaced, or obsoleted by other documents at any time.\nIt is inappropriate to use Internet-Drafts as reference material or to cite\nthem other than as \"work in progress.\"\n\nCopyright Notice\n\nCopyright (C) The Internet Society (2004).\n\nAbstract\n\nThis document describes the syslog protocol which is\nused to convey event notification messages. It\ndescribes a layered architecture for an\neasily extensible syslog protocol. It also describes the basic message\nformat and structured elements used to provide meta-information about\nthe message.\n\n1. Introduction\n\nThis document describes a layered architecture for syslog. The goal\nof this architecture is to separate functionality into different\nlayers and thus provide easy extensibility.\n\nThis document describes the\nsemantics of the syslog protocol, outlines the concept of transport mappings and\nprovides a standard format for all syslog messages.\nIt also describes\nstructured data elements, which can be used to transmit\neasy parsable, structured information.\n\n3. Definitions\n\nAn application that can receive a message will be called a \"receiver\".\n\nAn application that can receive the message and forward it to\nanother receiver will be called a \"relay\".\n\nAn application that receives the message and does not relay it to\nany other receivers will be called a \"collector\".\n\nPlease note that a single application can have multiple roles at the same\ntime.\n\nThe following principles apply to syslog communication:\n\nSenders send messages blindly. They do not receive any notification\nif the recipient received the message nor do they receive any error\nnotifications. Though some transports may provide limited status\ninformation, conceptionally syslog is pure simplex communication.\n\nSenders send messages to relays or collectors with no knowledge\nof whether it is a collector or relay.\n\nSenders may be configured to send the same message to multiple receivers.\n\nRelays may send all or some of the messages that they receive\nto a subsequent relay or collector. They may also store - or otherwise\nlocally process - some or all messages without forwarding. In those\ncases, they are acting as both a\ncollector and a relay.\n\nRelays may also generate their own messages and send them on to\nsubsequent relays or collectors. In that case it is acting as\na sender and a relay.\n\nThe following deployment scenarios shown in Diagram 1 are valid while the\nfirst one has been known to be the most prevalent. Other\narrangements of these examples are also acceptable. As noted,\nin the following diagram relays may pass along all or some of the\nmessages that they receive along with passing along messages that\nthey internally generate. The boxes represent syslog-enabled applications.\n\n4. Transport Layer Protocol\n\nThis document does not specify any transport layer\nprotocol. Instead, it describes the format of a syslog message in a\ntransport layer independent way. This will require that syslog\ntransports be defined in other documents. The first transport is\ndefined in [13]Okmianski, A., Transmission of syslog messages over UDP, August 2004. and is consistent with the\ntraditional UDP transport.\n\nOther transport mappings must ensure that all messages\nMUST be transmitted unaltered to the destination.\nIf the mapping needs to perform temporary transformations, it MUST be\nguaranteed that the message received at the final destination is an\nexact copy of the message sent from the initial originator.\nOtherwise cryptographic verifiers (like signatures)\nwill be broken.\n\nThe maximum length of any syslog message is 16,777,216 octets.\nAny receiver receiving a larger message MUST discard the message.\nA diagnostic message SHOULD be logged in this case.\n\nA receiver MUST be able to receive messages of a length of 480\noctets or less. A receiver SHOULD be able to receive messages of a length\nof 65,535 octets or less.\nIt is RECOMMENDED that receivers have the ability\nto receive messages up to the maximum message length.\n\nIf a receiver receives messages\nwithin the maximum length, but with a length larger than it handles, the\nreceiver MAY discard or truncate it.\n\nThe VERSION field denotes the version of the syslog protocol specification.\nThe version number MUST be incremented for each new syslog\nprotocol specification that changes the format. The value specified\nfor the value in this document is version \"1\".\nSome additional information about this is specified in Section 9IANA Considerations.\n\nFACILITY is an integer that can be used for filtering by the receiver.\nThere exist some traditional FACILITY code semantics for\nthe codes in the range from 0 to 23. These semantics are not closely followed\nby all senders. Therefore, no specific semantics for\nFACILITY codes are implied in this document.\n\nA syslog sender being incapable of obtaining system time\nMUST use the following TIMESTAMP:\n\n2000-01-01T00:00:60Z\n\nThis TIMESTAMP is in the past and it shows a time\nthat never existed, because 1 January 2000 had no leap second.\nIt can never have existed in a valid syslog\nmessage of a time-aware sender. A receiver receiving that\nTIMESTAMP MUST treat it as being well-formed.\n\nThis represents 20 minutes and 50.52 seconds after the 23rd hour of\n12 April 1985 in UTC.\n\nExample 2\n\n1985-04-12T18:20:50.52-06:00\n\nThis represents the same time as in example 1, but expressed\nin the eastern US time zone (daylight savings time being observed).\n\nExample 3\n\n2003-10-11T22:14:15.003Z\n\nThis represents 11 October 2003 at 10:14:15pm, 3 milliseconds into\nthe next second. The timestamp is in UTC.\nThe timestamp provides millisecond resolution. The creator may have\nactually had a better resolution, but by providing just\nthree digits for the fractional settings, it does not tell us.\n\nExample 4\n\n2003-08-24T05:14:15.000003-09:00\n\nThis represents 24 August 2003 at 05:14:15am, 3 microseconds into the\nnext second. The microsecond resolution is indicated by the additional\ndigits in time-secfrac. The timestamp indicates that its local time\nis -9 hours from UTC. This timestamp might be created in the\nUS Pacific time zone during daylight savings time.\n\nExample 5 - An Invalid TIMESTAMP\n\n2003-08-24T05:14:15.000000003-09:00\n\nThis example nearly the same as Example 4, but it is specifying\ntime-secfrac in nanoseconds.\nThis will result in time-secfrac to be longer than the\nallowed 6 digits, which invalidates it.\n\nIf the FQDN is not known to the originator, but it knows its\nIP address and knows that address is statically assigned,\nit SHOULD use that IP address.\n\nIf the sender does not know its IP address or if it is statically\nassigned and the FQDN is not known, it SHOULD specify its\nhost name without domain name.\n\nIf the FQDN and the host name are not known, and the IP\naddress is not statically assigned or it is not known if it\nis statically assigned, the sender SHOULD specify\nthe IPv4 or IPv6 address it knows, even if it may be dynamically\nassigned.\n\nIf the sender does not know any identifying information, it\nSHOULD provide the value \"0:0:0:0:0:0:0:0\".\n\nIf a sender has multiple IP addresses, it SHOULD use\na consistent value in the HOSTNAME field. This consistent\nvalue MUST be one\nof its actual IP addresses. If a sender is running on a machine\nwhich has both statically and dynamically assigned addressed, then\nthat consistent\nvalue SHOULD be from the statically assigned addresses.\nAs an alternative, the sender MAY use the IP address of the\ninterface that is used to send the message.\n\nThe SENDER-INST SHOULD identify a specific instance of the sender.\nIt is RECOMMENDED that SENDER-INST contains the operating system\nprocess ID, together with a thread ID, if these things\nexist. No specific format is REQUIRED.\n\nThe dash character (\"-\") is a reserved character that MUST only\nbe used to indicate an unidentified instance.\n\nSTRUCTURED-DATA transports data in a well defined, easily\nparsable and interpretable format. There are multiple usage\nscenarios. For example, it may transport meta-information about\nthe syslog message or application-specific information\nsuch as traffic counters or IP addresses.\n\nSTRUCURED-DATA contains none, one or multiple structured\ndata elements, which are referred to as \"STR-DATA-ELT\" in this document.\n\nA STR-DATA-ELT consists of a name and parameter name-value pairs. The name\nis referred to as SD-ID. It is case-sensitive and uniquely identifies the\ntype and purpose of the element.\nThe name-value pairs are referred to as \"SD-PARAM\".\n\nSD-IDs MUST NOT contain SP or the characters '=', '\"', or ']'.\nIANA controls ALL SD-IDs without a hyphen ('-') in the second\ncharacter position.\nExperimental or vendor-specific SD-IDs MUST start with \"x-\".\nValues with a hyphen on the second character position and\nthe first character position not being\na lower case \"x\" are undefined and SHOULD NOT be used.\nReceivers MAY accept them.\n\nIf a receiver receives a well-formed but unknown SD-ID,\nit SHOULD ignore the element.\n\nEach SD-PARAM consist of a name, referred to as PARAM-NAME, and a value,\nreferred to as PARAM-VALUE.\n\nPARAM-NAME is case-sensitive and MUST NOT contain SP or the\ncharacters '=', '\"', or ']'.\n\nInside PARAM-VALUE, the characters '\"', '\\' and ']' MUST be escaped.\nThis is necessary to avoid parsing errors.\nEscaping ']' would not strictly be necessary but is REQUIRED by this\nspecification to avoid parser implementation errors.\nEach of these three characters MUST be\nescaped as '\\\"', '\\\\' and '\\]' respectively.\n\nA backslash ('\\') followed by none of the three described characters is considered\nan invalid escape sequence. Upon reception of such an invalid escape sequence, the\nreceiver MUST replace the two-character sequence with only the second\ncharacter received. It is RECOMMENDED that the receivers logs a diagnostic\nin this case.\n\nAll examples in this section only show the structured data part of the message.\nExamples should be considered to be on one line. They are wrapped on\nmultiple lines for readability purposes only. A description\nis given after each example.\n\nExample 1 - Valid\n\n[x-example-iut iut=\"3\" EventSource=\"Application\"\nEventID=\"1011\"]\n\nThis example is a structured data element with an experimental\nSD-ID of type \"x-example-iut\" which has three parameters.\n\nThis is nearly the same example as 2, but it has\na subtle error. Please note that there is a SP character between\nthe two structured data elements (\"]SP[\"). This is invalid. It will\ncause the STRUCTURED-DATA field to end after the first element. The\nsecond element will be interpreted as part of the MSG field.\n\nThis example again is nearly the same as 2. It has another\nsubtle error. Please note the SP character after the initial\nbracket. A structured data element SD-ID must immediately\nfollow the beginning bracket, so the SP character\ninvalidates the STRUCTURED-DATA. Thus, the receiver MAY discard\nthis message.\n\nExample 5 - Valid\n\n[sigSig Ver=\"1\" RSID=\"1234\" ... Signature=\"......\"]\n\nExample 5 is a valid example. It shows a hypothetical IANA assigned SD-I.\nPlease note that the dots denote missing fields, which have been\nleft out for brevity.\n\nIn this example, the VERSION is 1 and\nthe FACILITY has the value of 888. The message was created\non October, 11th 2003 at 10:14:15pm UTC, 3 milliseconds into\nthe next second. The message originated\nfrom a host that identifies itself as \"mymachine.example.com\".\nThe SENDER-NAME is \"su\" and the SENDER-INST\nis unknown. Note the two SP characters following SENDER-INST.\nThe second SP character is the STRUCTURED-DATA delimiter. It\ntells that no STRUCTURED-DATA is present in this message.\nThe MSG is \"'su root' failed for lonvick...\".\n\nIn this example, the VERSION is again 1.\nThe FACILITY is within the legacy syslog range (20).\nThe severity is 6 (\"Notice\" semantics).\nIt was created on 24 August 2003 at 5:14:15am, with a -9 hour offset\nfrom UTC, 3 microseconds into the next second.\nThe HOSTNAME is \"192.0.2.1\", so the sender\ndid not know its FQDN and used the IPv4 address instead.\nThe SENDER-NAME is \"myproc\" and the SENDER-INST is \"10\".\nThe message is \"%% It's time\nto make the do-nuts......\".\n\nThis example is modeled after example 1. However, this time\nit contains STRUCTURED-DATA, a single element with the\nvalue \"[x-example-iut iut=\"3\" EventSource=\"Application\"\nEventID=\"1011\"]\".\nThe MSG itself is \"An application event log entry...\"\n\n6. Structured Data IDs\n\nThe SD-ID \"time\" MAY be used by the original sender\nto describe its notion of system time. This SD-ID SHOULD be written if the\nsender is not properly synchronized with a reliable external\ntime source or if it does not know if its time zone information\nis correct.\nThe main use of this structured data element is to\nprovide some information on the level of trust of the TIMESTAMP described in\nSection 5.2.4TIMESTAMP.\n\nThe \"tzknown\" parameter indicates if the original sender knows its\ntime zone. If it does so, the value \"1\" MUST be\nused. If the time zone information is in doubt, the value \"0\" MUST be\nused. If the sender knows its time zone but decides to\nemit UTC, the value \"1\" MUST be used (because the time zone is known).\n\nThe \"issynced\" parameter indicates if the original sender is\nsynchronized to a reliable external time source, e.g. via NTP.\nIf the original sender is time synchronized, the value \"1\" SHOULD be\nused. If not, the value \"0\" MUST be used.\n\nThe \"syncaccuracy\" parameter indicates how accurate the original sender\nthinks the time synchronization it participates in is.\nIt is an integer describing the maximum number of\nmilliseconds that the clock may be off between synchronization intervals.\n\nIf the value \"0\" is used for \"issynced\", this parameter MUST NOT\nbe specified. If the value\n\"1\" is used for \"issynced\" but the \"syncaccuracy\" parameter is absent,\na receiver SHOULD assume that the time information provided is\naccurate enough to be considered correct. The \"syncaccuracy\" parameter\nSHOULD ONLY be written if the original sender actually has knowledge of\nthe reliability of the external time source. In practice, in most cases, it\nwill gain this in-depth knowledge only through operator configuration.\n\nThe following is an example of a system that knows that it\ndoes neither know its time zone nor if it is being synchronized:\n\n[time tzknown=\"0\" issynced=\"0\"]\n\nWith this information, the sender indicates that its time information\ncannot be trusted. This may be a hint for the receiver to use its local\ntime instead of the message-provided TIMESTAMP for correlation of multiple\nmessages from different senders.\n\nThe following is an example of a system that knows its\ntime zone and knows that it is properly synchronized to a reliable\nexternal source:\n\n[time tzknown=\"1\" issynced=\"1\"]\n\nNote: this case SHOULD be assumed by a receiver if no \"time\"\nSD-ID is provided by the sender.\n\nThe following is an example of a system that knows both its\ntime zone and that it is externally synchronized. It also knows the accuracy\nof the external synchronization:\n\n[time tzknown=\"1\" issynced=\"1\" syncaccuracy=\"60000\"]\n\nThe difference between this and the previous example is that the\nsender expects that its clock will be kept within 60 seconds\nof the official time. So if the sender reports it is 9:00:00, it\nis no earlier than 8:59:00 and no later then 9:01:00.\n\nThe \"ip\" parameter denotes the\nIP address that the sender knows it had at the time of sending\nthis message. It MUST contain the textual representation\nof an IP address as outlined in Section 5.2.5HOSTNAME.\n\nIf a sender has multiple IP addresses, it MAY either use a\nsingle of its IP addresses in the \"ip\" parameter or it MAY include\nmultiple \"ip\" parameters in a single \"origin\" structured data element.\n\nThe \"enterpriseID\" parameter MUST be an\n'SMI Network Management Private Enterprise Code', maintained by IANA,\nwhose prefix is iso.org.dod.internet.private.enterprise (1.3.6.1.4.1).\nThe number which follows is unique and may be registered by\nan on-line form at http://www.iana.org/.\nOnly that number MUST be specified in the \"enterpriseID\" parameter.\nThe complete up-to-date list of Enterprise Numbers is maintained by IANA\nat http://www.iana.org/assignments/enterprise-numbers.\n\nBy specifying an enterpriseID, the vendor allows more specific\nparsing of the message. This may be of aid to log\nanalyzers and similar processes.\n\nThe \"software\" parameter\nuniquely identifies the software that generated this message.\nIf it is used, \"enterpriseID\" SHOULD also be\nspecified, so that a specific vendor's software can be identified.\nThe \"software\" parameter is not the same as the SENDER-NAME\nheader parameter. It always contains the name of the generating\nsoftware while SENDER-NAME can contain anything else, including\nan operator-configured value.\n\nSpecifying the \"software\" parameter is an aid to log analyzers\nand similar processes.\n\nThe \"software\" parameter is a string. It MUST NOT be longer\nthan 48 characters.\n\n7. Security Considerations\n\nThis document, in multiple sections, recommends that an implementation\nwrites a diagnostic message to indicate unusual situations or other\nthings noteworthy.\nDiagnostic messages are a useful tool in finding configuration issues as\nwell as a system penetration.\n\nUnfortunately, diagnostic logging can cause issues by itself, for example\nif an attacker tries to create a denial of service condition by willingly\nsending malformed messages that will lead to the creation of diagnostic\nlog entries. Due to sheer volume, the resulting diagnostic log entries\nmay exhaust system resources, e.g. processing power, I/O capability or\nsimply storage space. For example, an attacker could flood a system with\nmessages generating diagnostic log entries after he has compromised a system.\nIf the log entries are stored for example in a circular buffer, the\nflood of diagnostic\nlog entries would eventually overwrite useful previous diagnostics.\n\nBesides this risk, diagnostic message, if they occur too frequently, can\nbecome meaningless. Common practice is to turn\noff diagnostic logging if it is too verbose. This potentially\nremoves important diagnostic information which could aid the operator.\n\nThis document does not impose any restrictions on the MSG content. As such,\nMSG MAY contain control characters, including the NUL character.\n\nIn some programming languages (most notably C and C++), the NUL (0x00) character\ntraditionally has a special significance as string terminator. Most, if not all,\nimplementations of these languages assume that a string will not extend\nbeyond the first NUL character. This is primarily a restriction of the\nsupporting run-time libraries. Please note that this restriction is\noften carried over to programs and script languages written in those\nlanguages.\nAs such, NUL characters must be considered with great care and be properly\nhandled. An attacker may deliberately include NUL characters to hide\ninformation after them. Incorrect handling of the NUL character\nmay also invalidate cryptographic checksums that are transmitted inside\nthe message.\n\nMany popular text editors are also written in languages with this restriction.\nThis means that NUL characters SHOULD NOT be written to a file in an\nunencoded way - otherwise it would potentially render the file unreadable.\n\nThe same is true for other control characters. For example, deliberately\nincluded backspace characters may be used by an attacker to render parts\nof the log message unreadable. Similar approaches exist for almost all\ncontrol characters.\n\nFinally, invalid UTF-8 sequences may be used by an attacker to inject\nASCII control characters.\nThis is why invalid UTF-8 sequences are not allowed and MUST be rejected.\n\nThe message length MUST NOT exceed the maximum value\noutlined in Section 5Required syslog Format. Various problems may result\nif a sender sends out messages with a greater length.\nWhile this document forbids oversize messages, an attacker may deliberately\nintroduce them. As such, it is vital that each receiver performs the\nnecessary sanity checks.\n\nAn attacker might deliberately send message with the maximum size. This\ncould lead to massive resource consumption and potentially denial of service\non the receiver or an interim system. Besides the DoS itself, this could\nresult in the loss of vital log data. As such, a DoS attack could be used\nas a way to hide another attack.\n\nTo avoid this problem, the network operator may limit the size of the received\nmessage to some value below the maximum supported by the protocol. An implementation\nmay also provide a feature where only a configured number of maximum size messages\nare allowed and truncation occurs if these occur too frequently.\n\nMessages over the minimum to be supported size may be discarded\nor truncated by the receiver or interim systems. As such, vital log information\nmay be lost. Even messages within that size may be lost if a non-reliable\ntransport mapping is used.\n\nIn order to prevent information loss, messages should be less then the\nminimum supported size outlined in Section 5.1Message Length.\nFor best performance and reliability, messages SHOULD be as small as possible.\nImportant information SHOULD be placed as early in the message as possible, as the\ninformation at the begin of the message is less likely to be discarded by a\nsize-limited receiver.\n\nIn case an application includes some user-supplied data within a syslog message,\nthis application should limit the size of this data. Otherwise, an attacker may\nprovide large data in the hope to exploit this potential weakness.\n\nThe syslog messages are usually presented (placed in a file, displayed\non the console, etc.) in the order in which they are received. This\nis not always in accordance with the sequence in which they were\ngenerated. As they are transmitted across an IP network, some out of\norder receipt should be expected. This may lead to some confusion as\nmessages may be received that would indicate that a process has\nstopped before it was started. This is somewhat rectified by the TIMESTAMP.\nHowever, the accuracy of the TIMESTAMP may not always be sufficiently enough.\n\nIt is desirable to use a transport with guaranteed delivery, if\none is available.\n\nIn syslog, there is no concept of unified event numbering. Single\nsenders are free to include a sequence number within the MSG but\nthat can hardly be coordinated between multiple senders. In such\ncases, multiple senders may report that each one is sending message\nnumber one. Again, this may be rectified somewhat by the TIMESTAMP.\nAs has been noted, however, even messages from a single\nsender to a single collector may be received out of order. This\nsituation is compounded when there are several senders configured to\nsend their syslog messages to a single collector. Messages from one\nsender may be delayed so the collector receives messages from another\nsender first even though the messages from the first sender were\ngenerated before the messages from the second. If there is no sufficiently-precise\ntimestamp or coordinated sequence number, then the messages may be\npresented in the order in which they were received which may give an\ninaccurate view of the sequence of actual events.\n\nThe plethora of configuration options available to the network\nadministrators may further skew the perception of the order of\nevents. It is possible to configure a group of senders to send\nstatus messages -or other informative messages- to one collector,\nwhile sending messages of relatively higher importance to another\ncollector. Additionally, the messages may be sent to different files\non the same collector. If the messages do not contain sufficiently-precise\ntimestamps from the source, it may be difficult to order the messages if they\nare kept in different places. An administrator may not be able to\ndetermine if a record in one file occurred before or after a record\nin a different file. This may be somewhat alleviated by placing\nmarking messages with a timestamp into all destination files. If\nthese have coordinated timestamps, then there will be some indication\nof the time of receipt of the individual messages. As such, it is\nhighly recommended\nto use the best available precision in the TIMESTAMP and use automatic\ntime synchronization on each systems (as, for example, can be done via NTP).\n\nMessages may be\nrecorded and replayed at a later time. An attacker may record a set\nof messages that indicate normal activity of a machine. At a later\ntime, that attacker may remove that machine from the network and\nreplay the syslog messages to the collector. Even with a TIMESTAMP\nfield in the HEADER part, an attacker may record the packets and\ncould simply modify them to reflect the current time before\nretransmitting them. The administrators may find nothing unusual in\nthe received messages and their receipt would falsely indicate normal\nactivity of the machine.\n\nCryptographically signing messages could prevent the alteration of\nTIMESTAMPs and thus the reply attack.\n\nAs there is no mechanism described within this document\nto ensure delivery, and since the underlying transport\nmay be lossey (e.g. UDP), some messages may be lost. They may either\nbe dropped through\nnetwork congestion, or they may be maliciously intercepted and\ndiscarded. The consequences of the drop of one or more syslog\nmessages cannot be determined. If the messages are simple status\nupdates, then their non-receipt may either not be noticed, or it may\ncause an annoyance for the system operators. On the other hand, if\nthe messages are more critical, then the administrators may not\nbecome aware of a developing and potentially serious problem.\nMessages may also be intercepted and discarded by an attacker as a\nway to hide unauthorized activities.\n\nIt is RECOMMENDED to use a reliable transport mapping to prevent this problem.\n\nBesides being discarded, syslog messages may be damaged in transit,\nor an attacker may maliciously modify them.\nIn such cases, the original contents of the message will not be\ndelivered to the collector. Additionally, if an attacker is\npositioned between the sender and collector of syslog messages, they\nmay be able to intercept and modify those messages while in-transit\nto hide unauthorized activities.\n\nWhile there are no strict guidelines pertaining to the MSG\nformat, most syslog messages are generated in human readable form\nwith the assumption that capable administrators should be able to\nread them and understand their meaning. Neither the syslog protocol\nnor the syslog application have mechanisms to provide confidentiality\nof the messages in transit. In most cases passing clear-text\nmessages is a benefit to the operations staff if they are sniffing\nthe packets off of the wire. The operations staff may be able to\nread the messages and associate them with other events seen from\nother packets crossing the wire to track down and correct problems.\nUnfortunately, an attacker may also be able to observe the human-readable\ncontents of syslog messages. The attacker may then use the\nknowledge gained from those messages to compromise a machine or do\nother damage.\n\nSince there is no control information distributed about any messages\nor configurations, it is wholly the responsibility of the network\nadministrator to ensure that the messages are actually going to the\nintended recipient. Cases have been noted where senders were\ninadvertently configured to send syslog messages to the wrong\nreceiver. In many cases, the inadvertent receiver may not be\nconfigured to receive syslog messages and it will probably discard\nthem. In certain other cases, the receipt of syslog messages has\nbeen known to cause problems for the unintended recipient. If\nmessages are not going to the intended recipient, then they cannot be\nreviewed or processed.\n\nAs it is shown in Figure 1, machines may be configured to relay\nsyslog messages to subsequent relays before reaching a collector. In\none particular case, an administrator found that he had mistakenly\nconfigured two relays to forward messages with certain Priority\nvalues to each other. When either of these machines either received\nor generated that type of message, it would forward it to the other\nrelay. That relay would, in turn, forward it back. This cycle did\ncause degradation to the intervening network as well as to the\nprocessing availability on the two devices. Network administrators\nmust take care to not cause such a death spiral.\n\nNetwork administrators must take the time to estimate the appropriate\nsize of the syslog receivers. An attacker may perform a Denial of\nService attack by filling the disk of the collector with false\nmessages. Placing the records in a circular file may alleviate this\nbut that has the consequence of not ensuring that an administrator\nwill be able to review the records in the future. Along this line, a\nreceiver or collector must have a network interface capable of\nreceiving all messages sent to it.\n\nAdministrators and network planners must also critically review the\nnetwork paths between the devices, the relays, and the collectors.\nGenerated syslog messages should not overwhelm any of the network links.\n\nIn order to reduce the impact of this issue, it is recommended to\nuse transports with guaranteed delivery.\n\nAs with any system, an attacker may just overwhelm a receiver by sending more\nmessages to it than can be handled by the infrastructure or the device itself.\nImplementors should attempt to provide features that minimize this threat.\nSuch as only receiving syslog messages from known IP addresses.\n\nNothing in this protocol attempts to eliminate covert\nchannels. Indeed, the unformatted message syntax in the\npackets could be very amenable to sending embedded\nsecret messages. In fact, just about every aspect of\nsyslog messages lends itself to the conveyance of covert\nsignals. For example, a collusionist could send odd and\neven PRI values to indicate Morse Code dashes and dots.\n\n8. Notice to RFC Editor\n\nThis is a note to the RFC editor. This ID is submitted along with\nID draft-ietf-syslog-transport-udp and they cross-reference each other.\nWhen RFC numbers are determined for each of these IDs, these references\nwill be updated to use the RFC numbers. This section will be removed at\nthat time.\n\nAuthor's Address\n\nAppendix A. Implementor Guidelines\n\nInformation in this section is given as an aid to implementors. While\nthis information is considered to be helpful, it is not normative. As such,\nan implementation is NOT REQUIRED to implement it in order to claim compliance to\nthis specification.\n\nImplementors should note the message size limitations outlined in\nSection 5.1Message Length and try to keep the most important parts\nearly in the message (within the minimum guaranteed length). This\nensures they will be seen by the receiver even if it\n(or a relay on the message path) truncates the message.\n\nThe section RECOMMENDS a message header parsing method based on\nthe VERSION field described in Section 5.2.1VERSION.\n\nThe receiver MUST check the VERSION. If the VERSION is within the set of\nversions supported by the receiver, it MUST parse the message according\nto the correct syslog protocol specification.\n\nIf the receiver does not support the specified VERSION, it SHOULD log a diagnostic\nmessage. It SHOULD NOT parse beyond the VERSION field. This is because the header\nformat may have changed in a newer version.\nIt SHOULD NOT try to process the message, but it MAY try this if the\nadministrator has configured the receiver to do so. In the latter case, the results\nmay be undefined. If the administrator has configured the receiver to parse a non-supported\nversion, it SHOULD assume that these messages are legacy syslog messages and parse\nand process them with respect to RFC 3164Lonvick, C., The BSD Syslog Protocol, August 2001.[11].\nTo be precise, a receiver receiving an unknown VERSION number, or a message without\na valid VERSION, MUST discard the message by default.\nHowever, the administrator may configure it to not discard these messages.\nIf that happens, the receiver\nMUST parse it according to RFC 3164Lonvick, C., The BSD Syslog Protocol, August 2001.[11]. The\nadministrator may again override this setting and configure the receiver to parse\nthe messages in any way.\nIt would be considered good form if the receiver were to attempt to ensure\nthat no application reliability issues occur.\n\nThe spirit behind these guidelines is that the administrator may sometime need the power\nto allow overriding of version-specific parsing, but this should be done in the\nmost secure and reliable way. Therefore, the receiver MUST use the appropriate\ndefaults specified above. This document is specific on this point\nbecause it is common experience that parsing unknown formats often leads to\nsecurity issues.\n\nAll implementations SHOULD try to assign the most appropriate severity to their message.\nMost importantly, messages designed to enable debugging or testing of software\nSHOULD be assigned severity 7. Severity 0 SHOULD be reserved for\nmessages of very high importance (like serious hardware failures or\nimminent power failure).\nAn implementation MAY use severities 0 and 7 for other purposes if this is configured\nby the administrator.\n\nSince severities are very subjective, the receiver SHOULD\nNOT assume that all senders have the same definition of severity.\n\nThe TIMESTAMP described in Section 5.2.4TIMESTAMP supports fractional\nseconds. This provides ground for a very common coding error, where leading zeros\nare removed from the fractional seconds. For example, the\nTIMESTAMP \"2003-10-11T22:13:14.003\" may be\nerroneously written as \"2003-10-11T22:13:14.3\". This would\nindicate 300 milliseconds instead of the 3 milliseconds\nactually meant.\n\nThe value \"60\" in the time-second field is used to indicate a leap second.\nThis MUST NOT be misinterpreted.\nDevelopers and implementors are advised to replace the\nvalue \"60\" if seen in the header, with the value \"59\" if it otherwise\ncan not be processed, e.g. stored to a database. It SHOULD NOT be\nconverted to the first second of the next minute. Please note that such\na conversion, if done on the message text itself, will cause cryptographic\nsignatures to become invalid. As such, it is suggested that the adjustment\nis not performed when the plain message text is to be stored (e.g. for later\nverification of signatures).\n\nIn Section 5.2.4.1Syslog Senders Without Knowledge of Time, a specific TIMESTAMP for usage by senders without\nknowledge of time is defined. This is done to support a\nspecial case when a sender is not aware of time\nat all. It can be argued whether or not such a sender is\nsomething that can actually\nbe found in today's IT infrastructure. However, discussion has\nindicated that those things may exist in practice and as such there should be\na guideline established for this case. It may also be assumed\nthat this class of senders will most probably be found in embedded devices.\n\nNote well: an implementation MUST emit a valid TIMESTAMP if the underlying\noperating system, programming system and hardware supports the clock\nfunction. A proper TIMESTAMP MUST be emitted even if it is\ndifficult, but doable, to obtain the system time. The TIMESTAMP described in\nSection 5.2.4.1Syslog Senders Without Knowledge of Time MUST only be used when it is actually impossible\nto obtain time information.\nThis rule SHOULD NOT be used as an excuse for lazy implementations.\n\nIf a receiver receives that special TIMESTAMP, it\nSHOULD know that the sender had no idea\nof what the time actually is and act accordingly.\n\nThe objective behind SENDER-INSTSENDER-INST is to provide a quick\nway to detect a new instance of the same sender. It must be\nnoted that this is not reliable as a second incarnation of\na SENDER-INST may actually be able to use the same SENDER-INST value as the prior one.\nProperly used, the SENDER-INST can be helpful for analysis purposes.\n\nIt is RECOMMENDED that the value of \"0\" be the default for the\n\"tzknown\"tzknown parameter. It SHOULD only be changed\nto \"1\" after the administrator has specifically configured the\ntime zone. The value \"1\" MAY be used as the default if the underlying\noperating system provides accurate time zone information. It is still advised\nthat the administrator explicitly acknowledges the correctness of the\ntime zone information.\n\nIt is important not to create a false impression of accuracy with the\ntime SD-IDtime.\nA sender MUST only indicate a given accuracy if it actually\nknows it is within these bounds. It is generally assumed that the sender gains this\nin-depth knowledge through operator configuration.\nAs such, by default, an accuracy SHOULD NOT be provided.\n\nIn Section 7.1Diagnostic Logging, this document describes the need as well as\npotential problems of diagnostic logging. In this section, a real-world\napproach to useful diagnostic logging is RECOMMENDED.\n\nWhile this document recommends to write meaningful diagnostic logs, it\nalso recommends to allow an operator to limit the amount of\ndiagnostic logging. At least, an implementation SHOULD differentiate between\ncritical, informational and debugging diagnostic message. Critical messages\nshould only be issued in real critical states, e.g. expected or happening\nmalfunction of the application or parts of it. A strong indication of an\nongoing attack may also be considered critical. As a guideline,\nthere should be very few critical messages. Informational messages should\nindicate all conditions not fully correct, but still within the bounds of\nnormal processing. A diagnostic message logging the fact that a malformed\nmessage has been received is a good example of this category. A debug\ndiagnostic message should not be needed during normal operation, but merely\nas a tool for setting up or testing a system (which includes the process\nof an operator configuring multiple syslog applications in a complex\nenvironment). An application may decide to not provide any debugging\ndiagnostic messages.\n\nAn administrator should be able to configure the level for which diagnostic\nmessages will be written. Non-configured diagnostic should not be written\nbut discarded. An implementor may create as many different levels of\ndiagnostic messages as he see useful - the above recommendation is just based\non real-world experience of what is considered useful. Please note that\nexperience also shows that too many levels of diagnostics typically do\nno good, because the typical administrator may no longer be able to\nunderstand what each level means.\n\nEven with this categorization, a single diagnostic (or a set of them) may\nfrequently be generated when a specific condition exists (or a system\nis being attacked). It will lead to the security issues outlined at the\nbeginning of this section. To solve this, it is recommended that an\nimplementation be allowed to set a limit of how many duplicate diagnostic\nmessages will be generated within a limited amount of time. For example, an\nadministrator should be able to configure that groups of 50 identical messages\nare logged within a specified time period with only a single diagnostic message.\nAll subsequent identical messages\nwill be discarded until the next time interval. It is usually considered good\nform to generate a subsequent message identifying the number of duplicate\nmessages that were discarded. While this causes some\ninformation loss, it is considered a good compromise between avoiding overruns\nand providing most in-depth diagnostic information. An implementation offering\nthis feature should allow the administrator to configure the number of\nduplicate messages as well as the time interval to whatever the\nadministrator thinks to be reasonable for his needs. It is up to the\nimplementor of what the term \"duplicate\" means. Some may decide that only\ntotally identical (in byte-to-byte comparison) messages are actually duplicate,\nsome other may say that a message which is of identical type but with\njust some changed parameter (e.g. changed remote host address) is also\nconsidered to be a duplicate. Both approaches have their advantages\nand disadvantages. Probably, it is best to also leave this configurable\nand allow the administrator to set the parameters.\n\nIntellectual Property Statement\n\nThe IETF takes no position regarding the validity or scope of any\nIntellectual Property Rights or other rights that might be claimed\nto pertain to the implementation or use of the technology\ndescribed in this document or the extent to which any license\nunder such rights might or might not be available; nor does it\nrepresent that it has made any independent effort to identify any\nsuch rights.\nInformation on the procedures with respect to\nrights in RFC documents can be found in BCP 78 and BCP 79.\n\nCopies of IPR disclosures made to the IETF Secretariat and any\nassurances of licenses to be made available,\nor the result of an attempt made to obtain a general license or\npermission for the use of such proprietary rights by implementers or\nusers of this specification can be obtained from the IETF on-line IPR\nrepository at http://www.ietf.org/ipr.\n\nThe IETF invites any interested party to bring to its attention\nany copyrights,\npatents or patent applications,\nor other\nproprietary rights that may cover technology that may be required\nto implement this standard.\nPlease address the information to the IETF at ietf-ipr@ietf.org.\n\nDisclaimer of Validity\n\nThis document and the information contained herein are provided\non an \"AS IS\" basis and THE CONTRIBUTOR,\nTHE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY),\nTHE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM\nALL WARRANTIES,\nEXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE\nINFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\nWARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n\nCopyright Statement\n\nCopyright (C) The Internet Society (2004).\nThis document is subject to the rights,\nlicenses and restrictions contained in BCP 78,\nand except as set forth therein,\nthe authors retain all their rights.\n\nAcknowledgment\n\nFunding for the RFC Editor function is currently provided by the\nInternet Society."
}