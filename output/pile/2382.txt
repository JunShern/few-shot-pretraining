{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2382",
    "text": "/****************************************************************************\r\n**\r\n** https://www.qxorm.com/\r\n** Copyright (C) 2013 Lionel Marty (contact@qxorm.com)\r\n**\r\n** This file is part of the QxOrm library\r\n**\r\n** This software is provided 'as-is', without any express or implied\r\n** warranty. In no event will the authors be held liable for any\r\n** damages arising from the use of this software\r\n**\r\n** Commercial Usage\r\n** Licensees holding valid commercial QxOrm licenses may use this file in\r\n** accordance with the commercial license agreement provided with the\r\n** Software or, alternatively, in accordance with the terms contained in\r\n** a written agreement between you and Lionel Marty\r\n**\r\n** GNU General Public License Usage\r\n** Alternatively, this file may be used under the terms of the GNU\r\n** General Public License version 3.0 as published by the Free Software\r\n** Foundation and appearing in the file 'license.gpl3.txt' included in the\r\n** packaging of this file. Please review the following information to\r\n** ensure the GNU General Public License version 3.0 requirements will be\r\n** met : http://www.gnu.org/copyleft/gpl.html\r\n**\r\n** If you are unsure which license is appropriate for your use, or\r\n** if you have questions regarding the use of this file, please contact :\r\n** contact@qxorm.com\r\n**\r\n****************************************************************************/\r\n\r\n#ifndef _QX_IS_QX_POD_H_\r\n#define _QX_IS_QX_POD_H_\r\n\r\n#ifdef _MSC_VER\r\n#pragma once\r\n#endif\r\n\r\n/*!\r\n * \\file is_qx_pod.h\r\n * \\author Lionel Marty\r\n * \\ingroup QxTraits\r\n * \\brief qx::trait::is_qx_pod<T>::value : return true if T is a POD type and not a pointer\r\n */\r\n\r\nnamespace qx {\r\nnamespace trait {\r\n\r\n/*!\r\n * \\ingroup QxTraits\r\n * \\brief qx::trait::is_qx_pod<T>::value : return true if T is a POD type and not a pointer\r\n */\r\ntemplate <typename T>\r\nstruct is_qx_pod\r\n{\r\n\r\n   enum { value = (std::is_pod<T>::value && ! std::is_pointer<T>::value && ! std::is_member_pointer<T>::value) };\r\n\r\n   typedef typename std::conditional<qx::trait::is_qx_pod<T>::value, std::true_type, std::false_type>::type type;\r\n\r\n};\r\n\r\n} // namespace trait\r\n} // namespace qx\r\n\r\n#endif // _QX_IS_QX_POD_H_\r\n"
}