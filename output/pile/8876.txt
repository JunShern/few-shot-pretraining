{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 5 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains [' * This software is available to you under a choice of one of two (0.199)']."
        }
    ],
    "doc_id": "8876",
    "text": "/*\n * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2005, 2006, 2007, 2008 Mellanox Technologies. All rights reserved.\n * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n\n#include <linux/mlx4/cmd.h>\n\n#include <asm/io.h>\n\n#include \"mlx4.h\"\n\n#define CMD_POLL_TOKEN 0xffff\n\nenum {\n\t/* command completed successfully: */\n\tCMD_STAT_OK\t\t= 0x00,\n\t/* Internal error (such as a bus error) occurred while processing command: */\n\tCMD_STAT_INTERNAL_ERR\t= 0x01,\n\t/* Operation/command not supported or opcode modifier not supported: */\n\tCMD_STAT_BAD_OP\t\t= 0x02,\n\t/* Parameter not supported or parameter out of range: */\n\tCMD_STAT_BAD_PARAM\t= 0x03,\n\t/* System not enabled or bad system state: */\n\tCMD_STAT_BAD_SYS_STATE\t= 0x04,\n\t/* Attempt to access reserved or unallocaterd resource: */\n\tCMD_STAT_BAD_RESOURCE\t= 0x05,\n\t/* Requested resource is currently executing a command, or is otherwise busy: */\n\tCMD_STAT_RESOURCE_BUSY\t= 0x06,\n\t/* Required capability exceeds device limits: */\n\tCMD_STAT_EXCEED_LIM\t= 0x08,\n\t/* Resource is not in the appropriate state or ownership: */\n\tCMD_STAT_BAD_RES_STATE\t= 0x09,\n\t/* Index out of range: */\n\tCMD_STAT_BAD_INDEX\t= 0x0a,\n\t/* FW image corrupted: */\n\tCMD_STAT_BAD_NVMEM\t= 0x0b,\n\t/* Error in ICM mapping (e.g. not enough auxiliary ICM pages to execute command): */\n\tCMD_STAT_ICM_ERROR\t= 0x0c,\n\t/* Attempt to modify a QP/EE which is not in the presumed state: */\n\tCMD_STAT_BAD_QP_STATE   = 0x10,\n\t/* Bad segment parameters (Address/Size): */\n\tCMD_STAT_BAD_SEG_PARAM\t= 0x20,\n\t/* Memory Region has Memory Windows bound to: */\n\tCMD_STAT_REG_BOUND\t= 0x21,\n\t/* HCA local attached memory not present: */\n\tCMD_STAT_LAM_NOT_PRE\t= 0x22,\n\t/* Bad management packet (silently discarded): */\n\tCMD_STAT_BAD_PKT\t= 0x30,\n\t/* More outstanding CQEs in CQ than new CQ size: */\n\tCMD_STAT_BAD_SIZE\t= 0x40,\n\t/* Multi Function device support required: */\n\tCMD_STAT_MULTI_FUNC_REQ\t= 0x50,\n};\n\nenum {\n\tHCR_IN_PARAM_OFFSET\t= 0x00,\n\tHCR_IN_MODIFIER_OFFSET\t= 0x08,\n\tHCR_OUT_PARAM_OFFSET\t= 0x0c,\n\tHCR_TOKEN_OFFSET\t= 0x14,\n\tHCR_STATUS_OFFSET\t= 0x18,\n\n\tHCR_OPMOD_SHIFT\t\t= 12,\n\tHCR_T_BIT\t\t= 21,\n\tHCR_E_BIT\t\t= 22,\n\tHCR_GO_BIT\t\t= 23\n};\n\nenum {\n\tGO_BIT_TIMEOUT_MSECS\t= 10000\n};\n\nstruct mlx4_cmd_context {\n\tstruct completion\tdone;\n\tint\t\t\tresult;\n\tint\t\t\tnext;\n\tu64\t\t\tout_param;\n\tu16\t\t\ttoken;\n};\n\nstatic int mlx4_status_to_errno(u8 status)\n{\n\tstatic const int trans_table[] = {\n\t\t[CMD_STAT_INTERNAL_ERR]\t  = -EIO,\n\t\t[CMD_STAT_BAD_OP]\t  = -EPERM,\n\t\t[CMD_STAT_BAD_PARAM]\t  = -EINVAL,\n\t\t[CMD_STAT_BAD_SYS_STATE]  = -ENXIO,\n\t\t[CMD_STAT_BAD_RESOURCE]\t  = -EBADF,\n\t\t[CMD_STAT_RESOURCE_BUSY]  = -EBUSY,\n\t\t[CMD_STAT_EXCEED_LIM]\t  = -ENOMEM,\n\t\t[CMD_STAT_BAD_RES_STATE]  = -EBADF,\n\t\t[CMD_STAT_BAD_INDEX]\t  = -EBADF,\n\t\t[CMD_STAT_BAD_NVMEM]\t  = -EFAULT,\n\t\t[CMD_STAT_ICM_ERROR]\t  = -ENFILE,\n\t\t[CMD_STAT_BAD_QP_STATE]   = -EINVAL,\n\t\t[CMD_STAT_BAD_SEG_PARAM]  = -EFAULT,\n\t\t[CMD_STAT_REG_BOUND]\t  = -EBUSY,\n\t\t[CMD_STAT_LAM_NOT_PRE]\t  = -EAGAIN,\n\t\t[CMD_STAT_BAD_PKT]\t  = -EINVAL,\n\t\t[CMD_STAT_BAD_SIZE]\t  = -ENOMEM,\n\t\t[CMD_STAT_MULTI_FUNC_REQ] = -EACCES,\n\t};\n\n\tif (status >= ARRAY_SIZE(trans_table) ||\n\t    (status != CMD_STAT_OK && trans_table[status] == 0))\n\t\treturn -EIO;\n\n\treturn trans_table[status];\n}\n\nstatic int cmd_pending(struct mlx4_dev *dev)\n{\n\tu32 status = readl(mlx4_priv(dev)->cmd.hcr + HCR_STATUS_OFFSET);\n\n\treturn (status & swab32(1 << HCR_GO_BIT)) ||\n\t\t(mlx4_priv(dev)->cmd.toggle ==\n\t\t !!(status & swab32(1 << HCR_T_BIT)));\n}\n\nstatic int mlx4_cmd_post(struct mlx4_dev *dev, u64 in_param, u64 out_param,\n\t\t\t u32 in_modifier, u8 op_modifier, u16 op, u16 token,\n\t\t\t int event)\n{\n\tstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\n\tu32 __iomem *hcr = cmd->hcr;\n\tint ret = -EAGAIN;\n\tunsigned long end;\n\n\tmutex_lock(&cmd->hcr_mutex);\n\n\tend = jiffies;\n\tif (event)\n\t\tend += msecs_to_jiffies(GO_BIT_TIMEOUT_MSECS);\n\n\twhile (cmd_pending(dev)) {\n\t\tif (time_after_eq(jiffies, end))\n\t\t\tgoto out;\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * We use writel (instead of something like memcpy_toio)\n\t * because writes of less than 32 bits to the HCR don't work\n\t * (and some architectures such as ia64 implement memcpy_toio\n\t * in terms of writeb).\n\t */\n\t__raw_writel((__force u32) cpu_to_be32(in_param >> 32),\t\t  hcr + 0);\n\t__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful),  hcr + 1);\n\t__raw_writel((__force u32) cpu_to_be32(in_modifier),\t\t  hcr + 2);\n\t__raw_writel((__force u32) cpu_to_be32(out_param >> 32),\t  hcr + 3);\n\t__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), hcr + 4);\n\t__raw_writel((__force u32) cpu_to_be32(token << 16),\t\t  hcr + 5);\n\n\t/* __raw_writel may not order writes. */\n\twmb();\n\n\t__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT)\t\t|\n\t\t\t\t\t       (cmd->toggle << HCR_T_BIT)\t|\n\t\t\t\t\t       (event ? (1 << HCR_E_BIT) : 0)\t|\n\t\t\t\t\t       (op_modifier << HCR_OPMOD_SHIFT) |\n\t\t\t\t\t       op),\t\t\t  hcr + 6);\n\n\t/*\n\t * Make sure that our HCR writes don't get mixed in with\n\t * writes from another CPU starting a FW command.\n\t */\n\tmmiowb();\n\n\tcmd->toggle = cmd->toggle ^ 1;\n\n\tret = 0;\n\nout:\n\tmutex_unlock(&cmd->hcr_mutex);\n\treturn ret;\n}\n\nstatic int mlx4_cmd_poll(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\n\t\t\t int out_is_imm, u32 in_modifier, u8 op_modifier,\n\t\t\t u16 op, unsigned long timeout)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tvoid __iomem *hcr = priv->cmd.hcr;\n\tint err = 0;\n\tunsigned long end;\n\n\tdown(&priv->cmd.poll_sem);\n\n\terr = mlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\n\t\t\t    in_modifier, op_modifier, op, CMD_POLL_TOKEN, 0);\n\tif (err)\n\t\tgoto out;\n\n\tend = msecs_to_jiffies(timeout) + jiffies;\n\twhile (cmd_pending(dev) && time_before(jiffies, end))\n\t\tcond_resched();\n\n\tif (cmd_pending(dev)) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tif (out_is_imm)\n\t\t*out_param =\n\t\t\t(u64) be32_to_cpu((__force __be32)\n\t\t\t\t\t  __raw_readl(hcr + HCR_OUT_PARAM_OFFSET)) << 32 |\n\t\t\t(u64) be32_to_cpu((__force __be32)\n\t\t\t\t\t  __raw_readl(hcr + HCR_OUT_PARAM_OFFSET + 4));\n\n\terr = mlx4_status_to_errno(be32_to_cpu((__force __be32)\n\t\t\t\t\t       __raw_readl(hcr + HCR_STATUS_OFFSET)) >> 24);\n\nout:\n\tup(&priv->cmd.poll_sem);\n\treturn err;\n}\n\nvoid mlx4_cmd_event(struct mlx4_dev *dev, u16 token, u8 status, u64 out_param)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cmd_context *context =\n\t\t&priv->cmd.context[token & priv->cmd.token_mask];\n\n\t/* previously timed out command completing at long last */\n\tif (token != context->token)\n\t\treturn;\n\n\tcontext->result    = mlx4_status_to_errno(status);\n\tcontext->out_param = out_param;\n\n\tcomplete(&context->done);\n}\n\nstatic int mlx4_cmd_wait(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\n\t\t\t int out_is_imm, u32 in_modifier, u8 op_modifier,\n\t\t\t u16 op, unsigned long timeout)\n{\n\tstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\n\tstruct mlx4_cmd_context *context;\n\tint err = 0;\n\n\tdown(&cmd->event_sem);\n\n\tspin_lock(&cmd->context_lock);\n\tBUG_ON(cmd->free_head < 0);\n\tcontext = &cmd->context[cmd->free_head];\n\tcontext->token += cmd->token_mask + 1;\n\tcmd->free_head = context->next;\n\tspin_unlock(&cmd->context_lock);\n\n\tinit_completion(&context->done);\n\n\tmlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\n\t\t      in_modifier, op_modifier, op, context->token, 1);\n\n\tif (!wait_for_completion_timeout(&context->done, msecs_to_jiffies(timeout))) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terr = context->result;\n\tif (err)\n\t\tgoto out;\n\n\tif (out_is_imm)\n\t\t*out_param = context->out_param;\n\nout:\n\tspin_lock(&cmd->context_lock);\n\tcontext->next = cmd->free_head;\n\tcmd->free_head = context - cmd->context;\n\tspin_unlock(&cmd->context_lock);\n\n\tup(&cmd->event_sem);\n\treturn err;\n}\n\nint __mlx4_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\n\t       int out_is_imm, u32 in_modifier, u8 op_modifier,\n\t       u16 op, unsigned long timeout)\n{\n\tif (mlx4_priv(dev)->cmd.use_events)\n\t\treturn mlx4_cmd_wait(dev, in_param, out_param, out_is_imm,\n\t\t\t\t     in_modifier, op_modifier, op, timeout);\n\telse\n\t\treturn mlx4_cmd_poll(dev, in_param, out_param, out_is_imm,\n\t\t\t\t     in_modifier, op_modifier, op, timeout);\n}\nEXPORT_SYMBOL_GPL(__mlx4_cmd);\n\nint mlx4_cmd_init(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tmutex_init(&priv->cmd.hcr_mutex);\n\tsema_init(&priv->cmd.poll_sem, 1);\n\tpriv->cmd.use_events = 0;\n\tpriv->cmd.toggle     = 1;\n\n\tpriv->cmd.hcr = ioremap(pci_resource_start(dev->pdev, 0) + MLX4_HCR_BASE,\n\t\t\t\tMLX4_HCR_SIZE);\n\tif (!priv->cmd.hcr) {\n\t\tmlx4_err(dev, \"Couldn't map command register.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->cmd.pool = pci_pool_create(\"mlx4_cmd\", dev->pdev,\n\t\t\t\t\t MLX4_MAILBOX_SIZE,\n\t\t\t\t\t MLX4_MAILBOX_SIZE, 0);\n\tif (!priv->cmd.pool) {\n\t\tiounmap(priv->cmd.hcr);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid mlx4_cmd_cleanup(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tpci_pool_destroy(priv->cmd.pool);\n\tiounmap(priv->cmd.hcr);\n}\n\n/*\n * Switch to using events to issue FW commands (can only be called\n * after event queue for command events has been initialized).\n */\nint mlx4_cmd_use_events(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i;\n\n\tpriv->cmd.context = kmalloc(priv->cmd.max_cmds *\n\t\t\t\t   sizeof (struct mlx4_cmd_context),\n\t\t\t\t   GFP_KERNEL);\n\tif (!priv->cmd.context)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->cmd.max_cmds; ++i) {\n\t\tpriv->cmd.context[i].token = i;\n\t\tpriv->cmd.context[i].next  = i + 1;\n\t}\n\n\tpriv->cmd.context[priv->cmd.max_cmds - 1].next = -1;\n\tpriv->cmd.free_head = 0;\n\n\tsema_init(&priv->cmd.event_sem, priv->cmd.max_cmds);\n\tspin_lock_init(&priv->cmd.context_lock);\n\n\tfor (priv->cmd.token_mask = 1;\n\t     priv->cmd.token_mask < priv->cmd.max_cmds;\n\t     priv->cmd.token_mask <<= 1)\n\t\t; /* nothing */\n\t--priv->cmd.token_mask;\n\n\tpriv->cmd.use_events = 1;\n\n\tdown(&priv->cmd.poll_sem);\n\n\treturn 0;\n}\n\n/*\n * Switch back to polling (used when shutting down the device)\n */\nvoid mlx4_cmd_use_polling(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i;\n\n\tpriv->cmd.use_events = 0;\n\n\tfor (i = 0; i < priv->cmd.max_cmds; ++i)\n\t\tdown(&priv->cmd.event_sem);\n\n\tkfree(priv->cmd.context);\n\n\tup(&priv->cmd.poll_sem);\n}\n\nstruct mlx4_cmd_mailbox *mlx4_alloc_cmd_mailbox(struct mlx4_dev *dev)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\n\tmailbox = kmalloc(sizeof *mailbox, GFP_KERNEL);\n\tif (!mailbox)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmailbox->buf = pci_pool_alloc(mlx4_priv(dev)->cmd.pool, GFP_KERNEL,\n\t\t\t\t      &mailbox->dma);\n\tif (!mailbox->buf) {\n\t\tkfree(mailbox);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn mailbox;\n}\nEXPORT_SYMBOL_GPL(mlx4_alloc_cmd_mailbox);\n\nvoid mlx4_free_cmd_mailbox(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox)\n{\n\tif (!mailbox)\n\t\treturn;\n\n\tpci_pool_free(mlx4_priv(dev)->cmd.pool, mailbox->buf, mailbox->dma);\n\tkfree(mailbox);\n}\nEXPORT_SYMBOL_GPL(mlx4_free_cmd_mailbox);\n"
}