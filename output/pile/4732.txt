{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['0', '0', '0', '0', '0', '0']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4732",
    "text": "Q:\n\nUsing TaskCompletionSource Within An await Task.Run Call\n\nI am getting unexpected behavior that I would like to shed some light on.  I've created a simple example to demonstrate the problem.  I call an async function using Task.Run, which will continuously generate results, and uses IProgress to deliver updates to the UI.  But I want to wait until after the UI actually updates to continue, so I tried using TaskCompletionSource as suggested in some other posts (this seemed somewhat similar: Is it possible to await an event instead of another async method?.)  I'm expecting the initial Task.Run to wait, but what is happening is the await happening inside seems to move it onward and \"END\" happens after the first iteration. Start() is the entry point:\npublic TaskCompletionSource<bool> tcs;\n\npublic async void Start()\n{\n    var progressIndicator = new Progress<List<int>>(ReportProgress);\n\n    Debug.Write(\"BEGIN\\r\");\n    await Task.Run(() => this.StartDataPush(progressIndicator));\n    Debug.Write(\"END\\r\");\n}\n\nprivate void ReportProgress(List<int> obj)\n{\n    foreach (int item in obj)\n    {\n        Debug.Write(item + \" \");\n    }\n    Debug.Write(\"\\r\");\n    Thread.Sleep(500);\n\n    tcs.TrySetResult(true);\n}\n\nprivate async void StartDataPush(IProgress<List<int>> progressIndicator)\n{\n    List<int> myList = new List<int>();\n\n    for (int i = 0; i < 3; i++)\n    {\n        tcs = new TaskCompletionSource<bool>();\n\n        myList.Add(i);\n        Debug.Write(\"Step \" + i + \"\\r\");\n\n        progressIndicator.Report(myList);\n\n        await this.tcs.Task;\n    }\n}\n\nWith this I get:\nBEGIN\nStep 0\n0 \nEND\nStep 1\n0 1 \nStep 2\n0 1 2 \n\ninstead of what I want to get which is:\nBEGIN\nStep 0\n0 \nStep 1\n0 1 \nStep 2\n0 1 2 \nEND\n\nI'm assuming I am misunderstanding something about Tasks and await and how they work. I do want StartDataPush to be a separate thread, and my understanding is that it is. My end use is somewhat more complex as it involves heavy calculation, updating to a WPF UI and events signaling back that it completed, but the mechanics are the same. How can I achieve what I'm trying to do?\n\nA:\n\nI'm not fully understanding the goal you are trying to achieve.  But the issue is StartDataPush returning void.  The only time an async should return void is if it is an event handler otherwise it needs to return Task.\nThe following would achieve what you expected in terms of output\npublic partial class MainWindow : Window\n{\n    public TaskCompletionSource<bool> tcs;\n\n    public MainWindow()\n    {\n        InitializeComponent();\n    }\n\n    private async void ButtonBase_OnClick(object sender, RoutedEventArgs e)\n    {\n        var progressIndicator = new Progress<List<int>>(ReportProgress);\n\n        Debug.Write(\"BEGIN\\r\");\n        await StartDataPush(progressIndicator);\n        Debug.Write(\"END\\r\");\n    }\n\n    private void ReportProgress(List<int> obj)\n    {\n        foreach (int item in obj)\n        {\n            Debug.Write(item + \" \");\n        }\n        Debug.Write(\"\\r\");\n        Thread.Sleep(500);\n\n        tcs.TrySetResult(true);\n    }\n\n    private async Task StartDataPush(IProgress<List<int>> progressIndicator)\n    {\n        List<int> myList = new List<int>();\n\n        for (int i = 0; i < 3; i++)\n        {\n            tcs = new TaskCompletionSource<bool>();\n\n            myList.Add(i);\n            Debug.Write(\"Step \" + i + \"\\r\");\n\n            progressIndicator.Report(myList);\n\n            await this.tcs.Task;\n        }\n    }\n}\n\n"
}