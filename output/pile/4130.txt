{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4130",
    "text": "Q:\n\nWhat is better: select duplicates check OR making a unique index?\n\nI have a table like this:\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `torderid` int(11) DEFAULT NULL,\n  `tuid` int(11) DEFAULT NULL,\n  `tcontid` int(11) DEFAULT NULL,\n  `tstatus` varchar(10) DEFAULT 'pending',\n\nthe rule here is that the same user UID can't have more than one pending order with the same contid.\nso the first thing i could do is to check if there is a pending order like this:\nselect count(id) into @cnt from tblorders where tuid = 1 and tcontid=5 and tstatus like 'pending';\n\nand if it is > 0 then can't insert.\nor i can just make a unique index for the three columns and that way the table won't accept new records of the duplicates.\nthe question is:\nWHICH WAY IS FASTER? because thats gonna be a large database...\n\nA:\n\nFew suggestions.\nuse tstatus = 'pending'; instead of tstatus like 'pending';\nCreating composite primary keys for tid, tcontid, tstatus may not work if you are considering only for 'pending' status.  What about other statuses?\nIf you decide to index the columns, I would recommend you create  a separate table for tstatus and use the foreign key reference here.  So it will save the space for the indexed columns and also your query will always run on the indexed fields.\n\n"
}