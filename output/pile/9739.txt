{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9739",
    "text": "Q:\n\nAutocompletion library in C++\n\nI need an auto-completion routine or library in C++ for 1 million words. I guess I can find a routine on the net like Rabin\u2013Karp. Do you know a library that does this. I don't see it in Boost. \nAlso, is it a crazy idea to use MySql LIKE SQL request to do that ?\nThank you\nEDIT: It is true that it is more suggestions than auto-completion that I need (propose ten words when the user typed the first 2 letters). I actually also have expressions \"Nikon digital camera\". But for a first version, I only need suggestions on \"Ni\" of Nikon and not on \"digital camera\".\n\nA:\n\nYou don't have to use any crazy algorithm if you begin by preparing an index.\nA simple Trie/Binary Search Tree structure, that keeps the words ordered alphabetically, would allow efficient prefix searches.\nIn C++, for example, the std::map class has the lower_bound member which would point in O(log N) to the first element that could possibly extend your word.\n\n"
}