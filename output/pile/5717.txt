{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "5717",
    "text": "Q:\n\nHow do I ensure a sequence has a certain length?\n\nI want to check that an IEnumerable contains exactly one element. This snippet does work:\nbool hasOneElement = seq.Count() == 1\n\nHowever it's not very efficient, as Count() will enumerate the entire list. Obviously, knowing a list is empty or contains more than 1 element means it's not empty. Is there an extension method that has this short-circuiting behaviour?\n\nA:\n\nThis should do it:\npublic static bool ContainsExactlyOneItem<T>(this IEnumerable<T> source)\n{\n    using (IEnumerator<T> iterator = source.GetEnumerator())\n    {\n        // Check we've got at least one item\n        if (!iterator.MoveNext())\n        {\n            return false;\n        }\n        // Check we've got no more\n        return !iterator.MoveNext();\n    }\n}\n\nYou could elide this further, but I don't suggest you do so:\npublic static bool ContainsExactlyOneItem<T>(this IEnumerable<T> source)\n{\n    using (IEnumerator<T> iterator = source.GetEnumerator())\n    {\n        return iterator.MoveNext() && !iterator.MoveNext();\n    }\n}\n\nIt's the sort of trick which is funky, but probably shouldn't be used in production code. It's just not clear enough. The fact that the side-effect in the LHS of the && operator is required for the RHS to work appropriately is just nasty... while a lot of fun ;)\nEDIT: I've just seen that you came up with exactly the same thing but for an arbitrary length. Your final return statement is wrong though - it should be return !en.MoveNext(). Here's a complete method with a nicer name (IMO), argument checking and optimization for ICollection/ICollection<T>:\npublic static bool CountEquals<T>(this IEnumerable<T> source, int count)\n{\n    if (source == null)\n    {\n        throw new ArgumentNullException(\"source\");\n    }\n    if (count < 0)\n    {\n        throw new ArgumentOutOfRangeException(\"count\",\n                                              \"count must not be negative\");\n    }\n    // We don't rely on the optimizations in LINQ to Objects here, as\n    // they have changed between versions.\n    ICollection<T> genericCollection = source as ICollection<T>;\n    if (genericCollection != null)\n    {\n        return genericCollection.Count == count;\n    }\n    ICollection nonGenericCollection = source as ICollection;\n    if (nonGenericCollection != null)\n    {\n        return nonGenericCollection.Count == count;\n    }\n    // Okay, we're finally ready to do the actual work...\n    using (IEnumerator<T> iterator = source.GetEnumerator())\n    {\n        for (int i = 0; i < count; i++)\n        {\n            if (!iterator.MoveNext())\n            {\n                return false;\n            }\n        }\n        // Check we've got no more\n        return !iterator.MoveNext();\n    }\n}\n\nEDIT: And now for functional fans, a recursive form of CountEquals (please don't use this, it's only here for giggles):\npublic static bool CountEquals<T>(this IEnumerable<T> source, int count)\n{\n    if (source == null)\n    {\n        throw new ArgumentNullException(\"source\");\n    }\n    if (count < 0)\n    {\n        throw new ArgumentOutOfRangeException(\"count\", \n                                              \"count must not be negative\");\n    }\n    using (IEnumerator<T> iterator = source.GetEnumerator())\n    {\n        return IteratorCountEquals(iterator, count);\n    }\n}\n\nprivate static bool IteratorCountEquals<T>(IEnumerator<T> iterator, int count)\n{\n    return count == 0 ? !iterator.MoveNext()\n        : iterator.MoveNext() && IteratorCountEquals(iterator, count - 1);\n}\n\nEDIT: Note that for something like LINQ to SQL, you should use the simple Count() approach - because that'll allow it to be done at the database instead of after fetching actual results.\n\nA:\n\nNo, but you can write one yourself:\n public static bool HasExactly<T>(this IEnumerable<T> source, int count)\n {\n   if(source == null)\n      throw new ArgumentNullException(\"source\");\n\n   if(count < 0)\n      return false;\n\n   return source.Take(count + 1).Count() == count;\n }\n\nEDIT: Changed from atleast  to exactly after clarification.\nFor a more general and efficient solution (which uses only 1 enumerator and checks if the sequence implements ICollection or ICollection<T> in which case enumeration is not necessary), you might want to take a look at my answer here, which lets you specify whether you are looking forExact,AtLeast, orAtMost tests.\n\nA:\n\nseq.Skip(1).Any() will tell you if the list has zero or one elements.\nI think the edit you made is about the most efficient way to check the length is n. But there's a logic fault, items less than length long will return true. See what I've done to the second return statement.\n    public static bool LengthEquals<T>(this IEnumerable<T> en, int length)\n    {\n        using (var er = en.GetEnumerator())\n        {\n            for (int i = 0; i < length; i++)\n            {\n                if (!er.MoveNext())\n                    return false;\n            }\n            return !er.MoveNext();\n        }\n    }\n\n"
}