{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains For example."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['Not all groups need have the same number of components. (0.181)', 'For example, a.sub.0 and b.sub.0 need not be the least significant bits of the actual binary numbers to be added, in which case there may be other copies of the adder in FIG. (0.173)']."
        }
    ],
    "doc_id": "5754",
    "text": "Performing floating point multiplication of binary operands with Booth encoding requires several multiples of the operands. Specifically, for radix-8 Booth encoding with an operand a, the products .+-.a, .+-.2a, .+-.3a, and .+-.4a are required. All such products except .+-.3a are easily obtained with simple bit shifts. One way to obtain 3a is to add 2a to a, where 2a is obtained from a by a bit shift. However, the integer sum of 2a with a is required. We shall refer to an adder for providing a signal indicative of 3a for any binary number a as a 3x adder.\nA Kogge-Stone adder can be useful for performing integer summation. Like a Carry Look Adder (CLA), the Kogge-Stone adder provides generate and propagate terms. However, to exploit parallelism, various bits of the operands are grouped together and the Kogge-Stone adder operates on these groups in parallel to provide group generate and group propagate terms for these groups. These group generate and group propagate terms are eventually used by the Kogge-Stone adder to provide the carry terms, from which the sum is obtained from these carry terms and the original operands. This is now described in more detail below.\nA functional diagram for a Kogge-Stone adder is shown in FIG. 1. The binary numbers a and b are added together to obtain their sum s. We denote the i.sup.th component of these binary numbers by a.sub.i, b.sub.i, and s.sub.i, respectively. In FIG. 1, the components of a and b are grouped into n+1 groups, where only the first (group 0), second (group 1), and last (group n) groups are explicitly shown. Not all groups need have the same number of components. For example, in FIG. 1, group 0 has j+1 components, group 1 has k+1 components, and group n has m+1 components.\nPG generators 102, 104, 106, and 108 provide group generate and group propagate terms. PG generators 102, 104, and 106 constitutes a first stage (level) and may be operated in parallel, and PG generator 108 constitutes a second stage (level). C generator 116 generates carry-out terms. CSS (Conditional Sum Selector) generators 110, 112, and 114 provide the sum s, and may be operated in parallel. Pipelining may be employed in which the first stage of PG generators operates on new data when the CSS generators are operating on old data.\nThe lines in FIG. 1 represent data flow lines. Their physical realization may comprise more than one wire for carrying a signal, or signals may be time-multiplexed on a single wire (and ground plane). The designation of data represented by a data flow line is indicated in FIG. 1. For example, PG generator 102 provides the terms gg.sub.m.sup.n and gp.sub.m.sup.n on data flow line 116. These terms represent, respectively, the highest order (m) group generate and group propagate terms for group n. When describing group generate and group propagate terms for an arbitrary group, the superscripts for these terms will not be indicated.\nAn arbitrary PG generator is shown in FIG. 2. For an arbitrary index i, gg.sub.i =1 if a carry-out term is generated when adding the binary number (x.sub.i x.sub.i-1 . . . x.sub.0) to the binary number (y.sub.i y.sub.i-1 . . . y.sub.0). The group generate term is zero otherwise. The group propagate term is given by gp.sub.i =1 if a carry-in term is propagated when adding the binary numbers (x.sub.i x.sub.i-1 . . . x.sub.0) and (y.sub.i y.sub.i-1. . . y.sub.0). The group propagate term is zero otherwise.\nThe group generate and group propagate terms can be written in terms of the generate terms g.sub.i and propagate terms p.sub.i as indicated in FIG. 2, where p.sub.i =x.sub.i +y.sub.i and g.sub.i 32 x.sub.i y.sub.i. Although the symbol + has been used before to indicate the ordinary summation symbol in the field of integers, in the previous sentence and elsewhere it is also used to indicate the logical (Boolean) OR in which the operands are now the Boolean elements \"1\" and \"0\", and its particular meaning will be clear from context. The product of Boolean variables indicates the logical AND of the Boolean variables. In FIG. 1, the summation symbol .SIGMA. indicates the logical OR sum. By definition, gg.sub.0 =g.sub.0.\nAs shown in FIG. 1, the input data to PG generator 108 are the highest order group generate and group propagate terms from each PG generator in the first stage of the CLA. These quantities are operated on by PG generator 108 to provide new (effective) group generate and group propagate terms gg.sup.i and gp.sup.i, i=0, 1, . . . , n. These effective group generate and group propagate terms are interpreted as follows. Let a.sup.i denote group i of the components of a. Similarly for b.sup.i. For example, according to the grouping indicated in FIG. 1, a.sup.0 =(a.sub.j a.sub.j-1 . . . a.sub.0). Then, gg.sup.i =1 indicates that a carry-out term is generated when adding the two binary numbers (a.sup.i a.sup.i-1 . . . a.sup.0) and (b.sup.i b.sup.i-1 . . . b.sup.0), where these two binary numbers are formed from the concatenation of the first i+1 groupings of a and b, respectively. If gg.sup.i =0, then no carry-out term is generated. Similarly, gp.sup.i =1 indicates that a carry-in term is propagated when adding the two binary numbers (a.sup.i a.sup.i-1 . . . a.sup.0) and (b.sup.i b.sup.i-1 . . . b.sup.0). If gp.sup.i =0 , then no carry-in term is propagated.\nAs shown in FIG. 1, C generator 116 provides carry-out terms c.sub.out.sup.i for i=0, 1, . . . n. FIG. 3 also illustrates C generator 116 and provides the Boolean expression for the carry-out terms as a function of the effective group generate and group propagate terms and the carry-in term Cin . A carry-out term c.sub.out.sup.i for some i is the carry-out term obtained by adding (a.sup.i a.sup.i-1 . . . a.sup.0) and (b.sup.i b.sup.i-1 . . . b.sup.0) in which the carry-in term is c.sub.in. This carry-in term may result from the sum of other bits not shown in FIG. 1. For example, a.sub.0 and b.sub.0 need not be the least significant bits of the actual binary numbers to be added, in which case there may be other copies of the adder in FIG. 1 to provide other sum bits, or the adder of FIG. 1 may be used more than once in an iterative manner to obtain all sum bits.\nAs shown in FIG. 1, the carry-out terms from C generator 116 are provided to the CSS generators. For 0.ltoreq.i&lt;n, the carry-out term c.sub.out.sup.i is the carry-in term to the CSS generator corresponding to group i+1. The carry-in term to CSS generator 114 for group 0 is c.sub.in. As shown in FIG. 1, the carry-out term c.sub.out.sup.0 is provided to CSS generator 112 corresponding to group 1 and the carry-out term c.sub.out.sup.n-1 is provided to CSS generator 110 corresponding to group n. Note that carry-out term c.sub.out.sup.n is available for other adders (not shown), or to indicate overflow, etc.\nFIG. 4 illustrates CSS generator 114 and provides the Boolean expression for the i.sup.th sum bit, s.sub.i. The symbol .sym. denotes exclusive OR. The carry-in term c.sub.i is the carry-in term for bit position i, and its expression in terms of gg.sub.i, gp.sub.i, and c.sub.in (the carry-in term for CSS generator 114) is also given in FIG. 4. Similar expressions are easily generalized for the other CSS generators in the Kogge-Stone adder of FIG. 1. A circuit at the logic gate level for the CSS generator of FIG. 4 is provided in FIG. 5, where MUX 502 switches to line 504 if c.sub.in =0 and switches to line 506 if c.sub.in =1.\nFrom the expression for gg.sub.i given in FIG. 2, it is seen that obtaining the highest order group generator term gg.sub.j for a PG generator of size j+1(i.e., a PG generator corresponding to groupings of a and b with j+1 bits each) requires evaluating the logical OR of j+1 product terms, where the most complicated product term is the logical AND of j+1 terms.\nFor example, a domino or dynamic logic gate realization for obtaining the group generator term gg.sub.4 is shown in FIG. 6. Transistors 602 and 604 are gated by a clock signal CLK, where the domino gate is in its precharge phase when CLK is LOW and is in its evaluation phase when CLK is HIGH. The output node of the domino gate is node 610. Transistors 606 and 608 constitute a static inverter gate. The stack depth of the domino gate in FIG. 6 is defined to be 5. That is, the clocked transistors are not counted. For some implementations, clocked transistor 602 is not needed. In general, a stack depth may be defined as the largest number of nFETs (n-Field Effect Transistors) in series between the output node and ground if no clocked nFET is present, or between the output node and the clocked nFET if a clocked nFET is present. For the general case, a domino gate providing gg.sub.i has a stack depth of j+1.\nBecause of the body effect of stacking nFETs in series, a logic gate tends to slow down as its stack depth increases. That is, the latency between output and input increases. Because not all paths in a domino gate between the output node and ground have the same number of nFETs, the increase in latency depends upon the particular input values. For example, in FIG. 6 the worst case scenario for increasing the latency is when all generator terms except g.sub.0 are 0 (LOW) and all propagate terms are 1 (HIGH). On average, latency will increase with increasing stack depth.\nThere are, however, no stack depth problems associated with domino gates for obtaining the group propagate terms because a simple NOR domino gate may be used in which the stack depth is only one.\nStack depths for obtaining the group generate terms can be reduced by employing more than one level of logic, but each additional level increases the over-all latency for computing the group generator terms. Thus, for many high-speed circuits the size of a PG generator according to FIG. 2 is limited to a fairly small number (e.g., not much more than four or five). However, decreasing the size of groupings (to decrease the size of PG generators in the first stage of a Kogge-Stone adder) leads to an increase in the number of groups in the first stage, which increases the size of the second stage (i.e., the size of functional unit 108 becomes too large).\nIt is therefore desirable to provide a 3x adder in which the stack depths associated with obtaining the group generate terms can be reduced."
}