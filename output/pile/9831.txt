{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Question:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9831",
    "text": "'use strict';\n\nconst root = '../../../..';\n\nconst mockrequire = require('mock-require');\nconst should = require('should');\nconst sinon = require('sinon');\nconst _ = require('lodash');\nconst { Client: ESClient } = require('@elastic/elasticsearch');\nconst {\n  Request,\n  KuzzleError,\n  UnauthorizedError,\n  TooManyRequestsError,\n  SizeLimitError,\n  ServiceUnavailableError,\n  PreconditionError,\n  PluginImplementationError,\n  PartialError,\n  NotFoundError,\n  InternalError,\n  GatewayTimeoutError,\n  ForbiddenError,\n  ExternalServiceError,\n  BadRequestError,\n} = require('kuzzle-common-objects');\n\nconst KuzzleMock = require(`${root}/test/mocks/kuzzle.mock`);\nconst { EmbeddedSDK } = require('../../../../lib/core/shared/sdk/embeddedSdk');\n\ndescribe('Plugin Context', () => {\n  const someCollection = 'someCollection';\n  let kuzzle;\n  let context;\n  let PluginContext;\n\n  beforeEach(() => {\n    PluginContext = mockrequire.reRequire(`${root}/lib/core/plugin/pluginContext`);\n\n    kuzzle = new KuzzleMock();\n    context = new PluginContext(kuzzle, 'pluginName');\n  });\n\n  afterEach(() => {\n    mockrequire.stopAll();\n  });\n\n  describe('#constructor', () => {\n    it('should be an instance of a PluginContext object', () => {\n      should(context).be.an.instanceOf(PluginContext);\n    });\n\n    it('should expose the right constructors', () => {\n      let repository;\n      const Koncorde = require('koncorde');\n\n      should(context.constructors).be.an.Object().and.not.be.empty();\n      should(context.constructors.Koncorde).be.a.Function();\n      should(context.constructors.Request).be.a.Function();\n      should(context.constructors.RequestContext).be.a.Function();\n      should(context.constructors.RequestInput).be.a.Function();\n      should(context.constructors.BaseValidationType).be.a.Function();\n      should(context.constructors.Repository).be.a.Function();\n\n      should(new context.constructors.Koncorde).be.instanceOf(Koncorde);\n      should(new context.constructors.Request(new Request({}), {})).be.instanceOf(Request);\n\n      repository = new context.constructors.Repository(someCollection);\n\n      should(repository.search).be.a.Function();\n      should(repository.get).be.a.Function();\n      should(repository.mGet).be.a.Function();\n      should(repository.delete).be.a.Function();\n      should(repository.create).be.a.Function();\n      should(repository.createOrReplace).be.a.Function();\n      should(repository.replace).be.a.Function();\n      should(repository.update).be.a.Function();\n    });\n\n    it('should exposes secrets from vault', () => {\n      should(context.secrets)\n        .not.be.undefined()\n        .match({\n          aws: {\n            secretKeyId: 'the cake is a lie'\n          },\n          kuzzleApi: 'the spoon does not exist'\n        });\n    });\n\n    describe('#ESClient', () => {\n      it('should expose the ESClient constructor', () => {\n        const esClient = new context.constructors.ESClient();\n\n        should(esClient).be.instanceOf(ESClient);\n      });\n\n      it('should allow to instantiate an ESClient connected to the ES cluster', () => {\n        const esClient = new context.constructors.ESClient();\n\n        should(esClient.connectionPool.connections[0].url.origin)\n          .be.eql(kuzzle.storageEngine.config.client.node);\n      });\n    });\n\n    describe('#Request', () => {\n      it('should throw when trying to instantiate a Request object without providing any data', () => {\n        should(function () { new context.constructors.Request(); })\n          .throw(PluginImplementationError, { id: 'plugin.context.missing_request_data' });\n      });\n\n      it('should replicate the right request information', () => {\n        let\n          request = new Request({\n            action: 'action',\n            controller: 'controller',\n            foobar: 'foobar',\n            _id: '_id',\n            index: 'index',\n            collection: 'collection',\n            result: 'result',\n            error: new Error('error'),\n            status: 666,\n            jwt: 'jwt',\n            volatile: {foo: 'bar'}\n          }, {\n            protocol: 'protocol',\n            connectionId: 'connectionId'\n          }),\n          pluginRequest = new context.constructors.Request(request, {});\n\n        should(pluginRequest.context.protocol).be.eql(request.context.protocol);\n        should(pluginRequest.context.connectionId).be.eql(request.context.connectionId);\n        should(pluginRequest.result).be.null();\n        should(pluginRequest.error).be.null();\n        should(pluginRequest.status).be.eql(102);\n        should(pluginRequest.input.action).be.null();\n        should(pluginRequest.input.controller).be.null();\n        should(pluginRequest.input.jwt).be.eql(request.input.jwt);\n        should(pluginRequest.input.args.foobar).be.eql(request.input.args.foobar);\n        should(pluginRequest.input.resource._id).be.eql(request.input.resource._id);\n        should(pluginRequest.input.resource.index).be.eql(request.input.resource.index);\n        should(pluginRequest.input.resource.collection).be.eql(request.input.resource.collection);\n        should(pluginRequest.input.volatile).match({foo: 'bar'});\n      });\n\n      it('should override origin request data with provided ones', () => {\n        let\n          request = new Request({\n            action: 'action',\n            controller: 'controller',\n            foo: 'foo',\n            bar: 'bar',\n            _id: '_id',\n            index: 'index',\n            collection: 'collection',\n            result: 'result',\n            error: new Error('error'),\n            status: 666,\n            jwt: 'jwt',\n            volatile: {foo: 'bar'}\n          }, {\n            protocol: 'protocol',\n            connectionId: 'connectionId'\n          }),\n          pluginRequest = new context.constructors.Request(request, {\n            action: 'pluginAction',\n            controller: 'pluginController',\n            foo: false,\n            from: 0,\n            size: 99,\n            collection: 'pluginCollection',\n            jwt: null,\n            volatile: {foo: 'overridden', bar: 'baz'}\n          });\n\n        should(pluginRequest.context.protocol).be.eql('protocol');\n        should(pluginRequest.context.connectionId).be.eql('connectionId');\n        should(pluginRequest.result).be.null();\n        should(pluginRequest.error).be.null();\n        should(pluginRequest.status).be.eql(102);\n        should(pluginRequest.input.action).be.eql('pluginAction');\n        should(pluginRequest.input.controller).be.eql('pluginController');\n        should(pluginRequest.input.jwt).be.null();\n        should(pluginRequest.input.args.foo).be.eql(false);\n        should(pluginRequest.input.args.bar).be.eql('bar');\n        should(pluginRequest.input.args.from).be.eql(0);\n        should(pluginRequest.input.args.size).be.eql(99);\n        should(pluginRequest.input.resource._id).be.eql('_id');\n        should(pluginRequest.input.resource.index).be.eql('index');\n        should(pluginRequest.input.resource.collection).be.eql('pluginCollection');\n        should(pluginRequest.input.volatile).match({foo: 'overridden', bar: 'baz'});\n      });\n\n      it('should allow building a request without providing another one', () => {\n        const rq = new context.constructors.Request({controller: 'foo', action: 'bar'});\n\n        should(rq).be.instanceOf(Request);\n        should(rq.input.action).be.eql('bar');\n        should(rq.input.controller).be.eql('foo');\n      });\n    });\n\n    it('should expose all error objects as capitalized constructors', () => {\n      const errors = {\n        KuzzleError,\n        UnauthorizedError,\n        TooManyRequestsError,\n        SizeLimitError,\n        ServiceUnavailableError,\n        PreconditionError,\n        PluginImplementationError,\n        PartialError,\n        NotFoundError,\n        InternalError,\n        GatewayTimeoutError,\n        ForbiddenError,\n        ExternalServiceError,\n        BadRequestError,\n      };\n\n      should(context.errors).be.an.Object().and.not.be.empty();\n\n      _.forOwn(errors, (constructor, name) => {\n        should(context.errors[name]).be.a.Function();\n        should(new context.errors[name]('foo')).be.instanceOf(constructor);\n      });\n    });\n\n    it('should expose the right accessors', () => {\n      [\n        'silly',\n        'verbose',\n        'info',\n        'debug',\n        'warn',\n        'error'\n      ].forEach(level => {\n        should(context.log[level]).be.an.instanceOf(Function);\n\n        context.log[level]('test');\n\n        should(kuzzle.log[level])\n          .calledOnce()\n          .calledWithExactly('[pluginName] test');\n      });\n\n      should(context.accessors).be.an.Object().and.not.be.empty();\n      should(context.accessors).have.properties(\n        ['execute', 'validation', 'storage', 'trigger', 'strategies', 'sdk']);\n    });\n\n    it('should adds the plugin name in logs', done => {\n      context.log.info('foobar');\n\n      process.nextTick(() => {\n        try {\n          should(kuzzle.log.info)\n            .be.calledOnce()\n            .be.calledWith('[pluginName] foobar');\n\n          done();\n        }\n        catch (e) {\n          done(e);\n        }\n      });\n    });\n\n    it('should expose a data validation accessor', () => {\n      const validation = context.accessors.validation;\n\n      should(validation.addType)\n        .be.eql(kuzzle.validation.addType.bind(kuzzle.validation));\n      should(validation.validate)\n        .be.eql(kuzzle.validation.validate.bind(kuzzle.validation));\n    });\n\n    it('should expose an API execution accessor', () => {\n      const execute = context.accessors.execute;\n\n      should(execute).be.a.Function();\n    });\n\n    it('should expose an event trigger accessor', () => {\n      const trigger = context.accessors.trigger;\n\n      should(trigger).be.a.Function();\n    });\n\n    it('should expose a private storage accessor', () => {\n      const storage = context.accessors.storage;\n\n      should(storage.bootstrap).be.a.Function();\n      should(storage.createCollection).be.a.Function();\n    });\n\n    it('should expose an authentication strategies management accessor', () => {\n      const strategies = context.accessors.strategies;\n\n      should(strategies.add).be.a.Function();\n      should(strategies.remove).be.a.Function();\n    });\n\n    it('should expose a EmbeddedSDK in accessors', () => {\n      const sdk = context.accessors.sdk;\n\n      should(sdk).be.instanceOf(EmbeddedSDK);\n    });\n\n    describe('#trigger', () => {\n      it('should call trigger with the given event name and payload and return pipe chain result', async () => {\n        kuzzle.pipe.resolves('pipe chain result');\n        const eventName = 'backHome';\n        const payload = {\n          question: 'whose motorcycle is this?',\n          answer: 'it\\'s a chopper, baby.',\n          anotherQuestion: 'whose chopper is this, then?',\n          anotherAnswer: 'it\\'s Zed\\'s',\n          yetAnotherQuestion: 'who\\'s Zed?',\n          yetAnotherAnswer: 'Zed\\'s dead, baby, Zed\\'s dead.'\n        };\n\n        const result = await context.accessors.trigger(eventName, payload);\n\n        should(result).be.eql('pipe chain result');\n        should(kuzzle.pipe)\n          .be.calledWithExactly(`plugin-pluginName:${eventName}`, payload);\n      });\n    });\n\n    describe('#execute', () => {\n      it('should call the callback with a result if everything went well', done => {\n        const\n          request = new Request({requestId: 'request'}, {connectionId: 'connectionid'}),\n          result = {foo: 'bar'},\n          callback = sinon.spy((err, res) => {\n            try {\n              should(callback).be.calledOnce();\n              should(err).be.null();\n              should(res).match(request);\n              should(res.result).be.equal(result);\n              should(kuzzle.funnel.executePluginRequest).calledWith(request);\n              done();\n            }\n            catch(e) {\n              done(e);\n            }\n          });\n\n        kuzzle.funnel.executePluginRequest.resolves(result);\n\n        should(context.accessors.execute(request, callback)).not.be.a.Promise();\n      });\n\n      it('should resolve a Promise with a result if everything went well', () => {\n        const\n          request = new Request({requestId: 'request'}, {connectionId: 'connectionid'}),\n          result = {foo: 'bar'};\n\n        kuzzle.funnel.executePluginRequest.resolves(result);\n\n        const ret = context.accessors.execute(request);\n\n        should(ret).be.a.Promise();\n\n        return ret\n          .then(res => {\n            should(res).match(request);\n            should(res.result).be.equal(result);\n            should(kuzzle.funnel.executePluginRequest).calledWith(request);\n          });\n      });\n\n      it('should call the callback with an error if something went wrong', done => {\n        const\n          request = new Request({body: {some: 'request'}}, {connectionId: 'connectionid'}),\n          error = new Error('error'),\n          callback = sinon.spy(\n            (err, res) => {\n              try {\n                should(kuzzle.funnel.executePluginRequest).calledWith(request);\n                should(callback).be.calledOnce();\n                should(err).match(error);\n                should(res).be.undefined();\n                done();\n              }\n              catch(e) {\n                done(e);\n              }\n            });\n\n        kuzzle.funnel.executePluginRequest.rejects(error);\n\n        context.accessors.execute(request, callback);\n      });\n\n      it('should reject a Promise with an error if something went wrong', () => {\n        const\n          request = new Request({body: {some: 'request'}}, {connectionId: 'connectionid'}),\n          error = new Error('error');\n\n        kuzzle.funnel.executePluginRequest.rejects(error);\n\n        return context.accessors.execute(request)\n          .catch(err => {\n            should(kuzzle.funnel.executePluginRequest).calledWith(request);\n            should(err).match(error);\n          });\n      });\n\n      it('should resolve to an error if no Request object is provided', done => {\n        const\n          callback = sinon.spy(\n            (err, res) => {\n              try {\n                should(kuzzle.funnel.executePluginRequest).not.be.called();\n                should(callback).be.calledOnce();\n                should(err).be.instanceOf(PluginImplementationError);\n                should(err.message).startWith('Invalid argument: a Request object must be supplied');\n                should(res).be.undefined();\n                done();\n              }\n              catch(e) {\n                done(e);\n              }\n            });\n\n        context.accessors.execute({}, callback);\n      });\n\n      it('should reject if no Request object is provided', () => {\n        return should(context.accessors.execute({})).be.rejectedWith(\n          /Invalid argument: a Request object must be supplied/\n        );\n      });\n\n      it('should reject if callback argument is not a function', () => {\n        return should(context.accessors.execute({requestId: 'request'}, 'foo'))\n          .be.rejectedWith({message: /^Invalid argument: Expected callback to be a function, received \"string\"/});\n\n      });\n\n      it('should reject if trying to call forbidden methods from realtime controller', () => {\n        return Promise.resolve()\n          .then(() => {\n            return should(context.accessors.execute(new Request({\n              controller: 'realtime',\n              action: 'subscribe'\n            })))\n              .be.rejectedWith(PluginImplementationError, {\n                id: 'plugin.context.unavailable_realtime'\n              });\n          })\n          .then(() => {\n            return should(context.accessors.execute(new Request({\n              controller: 'realtime',\n              action: 'unsubscribe'\n            })))\n              .be.rejectedWith(PluginImplementationError, {\n                id: 'plugin.context.unavailable_realtime'\n              });\n          });\n      });\n    });\n\n    describe('#strategies', () => {\n      it('should allow to add a strategy and link it to its owner plugin', () => {\n        const\n          mockedStrategy = {\n            config: {\n              authenticator: 'foo'\n            }\n          },\n          result = context.accessors.strategies.add('foo', mockedStrategy);\n\n        should(result).be.a.Promise();\n\n        return result\n          .then(() => {\n            should(kuzzle.pluginsManager.registerStrategy).calledWith('pluginName', 'foo', mockedStrategy);\n            should(kuzzle.pipe).calledWith('core:auth:strategyAdded', {\n              pluginName: 'pluginName',\n              name: 'foo',\n              strategy: mockedStrategy\n            });\n          });\n      });\n\n      it('should reject the promise if the strategy registration throws', () => {\n        const error = new Error('foobar');\n        kuzzle.pluginsManager.registerStrategy.throws(error);\n\n        const result = context.accessors.strategies.add('foo', {\n          config: {\n            authenticator: 'foobar'\n          }\n        });\n\n        should(result).be.a.Promise();\n\n        return should(result).be.rejectedWith(error);\n      });\n\n      it('should throw if no authenticator is provided', () => {\n\n        return should(context.accessors.strategies.add('foo', null))\n          .rejectedWith(PluginImplementationError, {message: '[pluginName] Strategy foo: dynamic strategy registration can only be done using an \"authenticator\" option (see https://tinyurl.com/y7boozbk).\\nThis is probably not a Kuzzle error, but a problem with a plugin implementation.'});\n      });\n\n      it('should allow to remove a strategy', () => {\n        const result = context.accessors.strategies.remove('foo');\n\n        should(result).be.a.Promise();\n\n        return result\n          .then(() => {\n            should(kuzzle.pluginsManager.unregisterStrategy).calledWith('pluginName', 'foo');\n            should(kuzzle.pipe).calledWith('core:auth:strategyRemoved', {\n              pluginName: 'pluginName',\n              name: 'foo'\n            });\n          });\n      });\n\n      it('should reject the promise if the strategy removal throws', () => {\n        const error = new Error('foobar');\n        kuzzle.pluginsManager.unregisterStrategy.throws(error);\n\n        const result = context.accessors.strategies.remove('foo');\n\n        should(result).be.a.Promise();\n\n        return should(result).be.rejectedWith(error);\n      });\n    });\n  });\n});\n"
}