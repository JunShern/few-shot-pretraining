{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9626",
    "text": "Q:\n\nAgain, ObservableCollection doesnt Update item\n\nThats my first project using MVVM , MVVM light.\nI have a listbox, that gets refreshed from the PersonList Observable collection, adding and removing refresh it normal. the problem is when editing an item.\nI looked for all the solutions for this problem, nothing worked, which make me think that I missed something. \nso here is the code : \n public class AdminViewModel : ApplicationPartBaseViewModel\n{\n   private ObservableCollection<Person> personList;\n\n   public AdminViewModel()\n    {\n\n       this.context = new Entities();\n       this.SavePersonCommand = new RelayCommand(() => this.SavePerson ());\n\n       this.PersonList = new ObservableCollection<Peson>(context.Person.OrderBy(o => o.PersonName).ToList());\n\n     }\n\n      public ObservableCollection<Person> PersonList\n    {\n        get\n        {\n             return personList;\n        }\n\n        set\n        {\n            this.personList = value;\n            RaisePropertyChanged(\"PersonList\");\n        }\n    }\n\n     private void SavePerson()\n    {\n      //Add and update code here\n       this.context.SaveChanges();\n       RaisePropertyChanged(\"PersonList\");\n\n    }\n\n}\n\nPerson Class is Autogenerated template from the DataModel edmx\n //------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated from a template.\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n\npublic partial class Person \n{\n    #region Primitive Properties\n\n    public virtual int PersonId\n    {\n        get;\n        set;\n    }\n\n    public virtual string PersonName\n    {\n        get;\n        set;\n    }\n\n    public virtual Nullable<int> PersonAge\n    {\n        get;\n        set;\n    }\n\n    #endregion\n    #region Navigation Properties\n\n    public virtual ICollection<Humans> Humans\n    {\n        get\n        {\n            if (_human == null)\n            {\n                var newCollection = new FixupCollection<Human>();\n                newCollection.CollectionChanged += FixupHuman;\n                _human = newCollection;\n            }\n            return _human;\n        }\n        set\n        {\n            if (!ReferenceEquals(_human, value))\n            {\n                var previousValue = _human as FixupCollection<Human>;\n                if (previousValue != null)\n                {\n                    previousValue.CollectionChanged -= FixupHuman;\n                }\n                _human = value;\n                var newValue = value as FixupCollection<Human>;\n                if (newValue != null)\n                {\n                    newValue.CollectionChanged += FixupAssets;\n                }\n            }\n        }\n    }\n    private ICollection<Human> _human;\n\n    #endregion\n    #region Association Fixup\n\n    private void FixupHuman(object sender, NotifyCollectionChangedEventArgs e)\n    {\n        if (e.NewItems != null)\n        {\n            foreach (Human item in e.NewItems)\n            {\n                if (!item.Person.Contains(this))\n                {\n                    item.Person.Add(this);\n                }\n            }\n        }\n\n        if (e.OldItems != null)\n        {\n            foreach (Human item in e.OldItems)\n            {\n                if (item.Person.Contains(this))\n                {\n                    item.Person.Remove(this);\n                }\n            }\n        }\n    }\n\n    #endregion\n}\n\nI thought that MVVM light update the item when I call RaisePropertyChanged. \nI am so confused. \nThanks in advance.\n\nA:\n\nFirst option is try to get your auto-generated class to implement INPC if you can. Have a look at Fody.PropertyChanged\nIf that's not possible, since it does have it's properties as \"virtual\", we can over-ride them in a derived class such as\npublic class ObservablePerson : Person, INotifyPropertyChanged {\n  public override int PersonId {\n    get {\n      return base.PersonId;\n    }\n    set {\n      base.PersonId = value;\n      OnPropertyChanged();\n    }\n  }\n\n  public override string PersonName {\n    get {\n      return base.PersonName;\n    }\n    set {\n      base.PersonName = value;\n      OnPropertyChanged();\n    }\n  }\n\n  public override int? PersonAge {\n    get {\n      return base.PersonAge;\n    }\n    set {\n      base.PersonAge = value;\n      OnPropertyChanged();\n    }\n  }\n\n  public event PropertyChangedEventHandler PropertyChanged;\n\n  [NotifyPropertyChangedInvocator]\n  protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null) {\n    PropertyChangedEventHandler handler = PropertyChanged;\n    if (handler != null)\n      handler(this, new PropertyChangedEventArgs(propertyName));\n  }\n}\n\nNow in your AdminViewModel work with objects of type ObservablePerson than Person\n\n"
}