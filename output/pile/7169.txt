{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7169",
    "text": "Q:\n\nSQL query to return a grouped result as a single row\n\nIf I have a jobs table like:\n|id|created_at  |status    |\n----------------------------\n|1 |01-01-2015  |error     |\n|2 |01-01-2015  |complete  |\n|3 |01-01-2015  |error     |\n|4 |01-02-2015  |complete  |\n|5 |01-02-2015  |complete  |\n|6 |01-03-2015  |error     |\n|7 |01-03-2015  |on hold   |\n|8 |01-03-2015  |complete  |\n\nI want a query that will group them by date and count the occurrence of each status and the total status for that date.\nSELECT created_at status, count(status), created_at \nFROM jobs \nGROUP BY created_at, status;\n\nWhich gives me \n|created_at  |status    |count|\n-------------------------------\n|01-01-2015  |error     |2\n|01-01-2015  |complete  |1\n|01-02-2015  |complete  |2\n|01-03-2015  |error     |1\n|01-03-2015  |on hold   |1\n|01-03-2015  |complete  |1   \n\nI would like to now condense this down to a single row per created_at unique date with some sort of multi column layout for each status. One constraint is that status is any one of 5 possible words but each date might not have one of every status. Also I would like a total of all statuses for each day. So desired results would look like:\n|date        |total |errors|completed|on_hold|\n----------------------------------------------\n|01-01-2015  |3     |2     |1        |null   \n|01-02-2015  |2     |null  |2        |null\n|01-03-2015  |3     |1     |1        |1\n\nthe columns could be built dynamically from something like \nSELECT DISTINCT status FROM jobs;\n\nwith a null result for any day that doesn't contain any of that type of status. I am no SQL expert but am trying to do this in a DB view so that I don't have to bog down doing multiple queries in Rails. \nI am using Postresql but would like to try to keep it straight SQL. I have tried to understand aggregate function enough to use some other tools but not succeeding.\n\nA:\n\nThe following should work in any RDBMS:\nSELECT created_at, count(status) AS total,\n       sum(case when status = 'error' then 1 end) as errors,\n       sum(case when status = 'complete' then 1 end) as completed,\n       sum(case when status = 'on hold' then 1 end) as on_hold\nFROM jobs \nGROUP BY created_at;\n\nThe query uses conditional aggregation so as to pivot grouped data. It assumes that status values are known before-hand. If you have additional cases of status values, just add the corresponding sum(case ... expression.\nDemo here\n\n"
}