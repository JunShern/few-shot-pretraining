{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['In the SQL world, you would typically create a a boolean|tinyint column; in Neo4j, the same can be achieved in the following two ways: (0.195)', 'Having faced this design dilemma a number of times, we would like to share our experience with the two presented possibilities and some Cypher query optimizations that will help you take a full advantage of a the graph database. (0.175)', 'Some designs we have encountered were making too much use of dedicated labels, forcing queries to match on multiple labels to fetch the desired set of nodes. (0.191)', 'We can see here that the number of database accesses is growing and you can imagine that it will be costly when we have millions of blog posts or entities in the database. (0.197)', 'As we can see, we did not define any labels because we know that the :PUBLISHED relationship will point to blog posts that are active and retrieving thousands of blog posts will just cost us nothing more than using the schema index for our user and a few traversals from the user to blog post nodes by following their relationships. (0.184)']."
        }
    ],
    "doc_id": "6283",
    "text": "A common question when planning and designing your Neo4j Graph Database is how to handle \u201cflagged\u201d entities. This could include users that are active, blog posts that are published, news articles that have been read, etc.\n\nIntroduction\n\nIn the SQL world, you would typically create a a boolean|tinyint column; in Neo4j, the same can be achieved in the following two ways:\n\nA flagged indexed property\n\nA dedicated label\n\nHaving faced this design dilemma a number of times, we would like to share our experience with the two presented possibilities and some Cypher query optimizations that will help you take a full advantage of a the graph database.\n\nThroughout the blog post, we\u2019ll use the following example scenario:\n\nWe have User nodes\n\nnodes User FOLLOWS other users\n\nother users Each user writes multiple blog posts stored as BlogPost nodes\n\nnodes Some of the blog posts are drafted , others are published ( active )\n\nSetting up\n\nIf we want to get a running test database for this use case, we can generate a small graph using Graphgen and import it into our local database. We use the following pattern:\n\n(user:#User *10) (post:#BlogPost *200) (post2:#BlogPost:ActivePost {active:{randomElement:[\"true\"]}} *200) (user)-[:WRITTEN *1..n]->(post) (user)-[:WRITTEN *1..n]->(post2) (user)-[:FOLLOWS *n..n]->(user)\n\nNaturally, we will create a unique constraint on the User _id property :\n\nCREATE CONSTRAINT ON (user:User) ASSERT user._id IS UNIQUE;\n\nRetrieving active blog posts\n\nWe now want to retrieve all the BlogPost nodes that are active.\n\nUsing labels\n\nPROFILE MATCH (post:ActivePost) RETURN count(post);\n\nwill result in the following execution plan :\n\nneo4j-sh (?)$ PROFILE MATCH (post:ActivePost) RETURN count(post); +-------------+ | count(post) | +-------------+ | 200 | +-------------+ 1 row ColumnFilter | +EagerAggregation | +NodeByLabel +------------------+------+--------+-------------+--------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +------------------+------+--------+-------------+--------------------------+ | ColumnFilter | 1 | 0 | | keep columns count(post) | | EagerAggregation | 1 | 0 | | | | NodeByLabel | 200 | 201 | post, post | :ActivePost | +------------------+------+--------+-------------+--------------------------+ Total database accesses: 201\n\nAs we can see there are no more database accesses than the number of ActivePost nodes in the database, thanks to the label indexing.\n\nNow, let\u2019s compare it with the use of an indexed active property on the nodes.\n\nUsing an indexed flagged property\n\nCREATE INDEX ON :BlogPost(active);\n\nPROFILE MATCH (post:BlogPost) WHERE post.active = true RETURN count(post);\n\nneo4j-sh (?)$ PROFILE MATCH (post:BlogPost) WHERE post.active = 'true' RETURN count(post); +-------------+ | count(post) | +-------------+ | 200 | +-------------+ 1 row ColumnFilter | +EagerAggregation | +SchemaIndex +------------------+------+--------+-------------+------------------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +------------------+------+--------+-------------+------------------------------------+ | ColumnFilter | 1 | 0 | | keep columns count(post) | | EagerAggregation | 1 | 0 | | | | SchemaIndex | 200 | 201 | post, post | { AUTOSTRING0}; :BlogPost(active) | +------------------+------+--------+-------------+------------------------------------+ Total database accesses: 201\n\nAs we can see, there is no difference between matching on a dedicated label and using indexed properties.\n\nBut why this blog post then?\n\nThe difference will be apparent when the queried nodes are not in the beginning of the pattern.\n\nRetrieving active blog posts written by a user\n\nLet\u2019s say we want to retrieve all active posts for a specific user :\n\nUsing labels\n\nPROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) WITH user MATCH (user)-[:WRITTEN]->(p:ActivePost) RETURN count(p);\n\nneo4j-sh (?)$ PROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) > WITH user > MATCH (user)-[:WRITTEN]->(p:ActivePost) > RETURN count(p); +----------+ | count(p) | +----------+ | 21 | +----------+ 1 row ColumnFilter | +EagerAggregation | +Filter | +SimplePatternMatcher | +SchemaIndex +----------------------+------+--------+----------------------+-----------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +----------------------+------+--------+----------------------+-----------------------------+ | ColumnFilter | 1 | 0 | | keep columns count(p) | | EagerAggregation | 1 | 0 | | | | Filter | 21 | 21 | | hasLabel(p:ActivePost(2)) | | SimplePatternMatcher | 21 | 35 | user, p, UNNAMED85 | | | SchemaIndex | 1 | 2 | user, user | { AUTOSTRING0}; :User(_id) | +----------------------+------+--------+----------------------+-----------------------------+ Total database accesses: 58\n\nUsing an indexed property\n\nPROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) WITH user MATCH (user)-[:WRITTEN]->(p:BlogPost) WHERE p.active = 'true' RETURN count(p);\n\nneo4j-sh (?)$ PROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) > WITH user > MATCH (user)-[:WRITTEN]->(p:BlogPost) > WHERE p.active = 'true' > RETURN count(p); +----------+ | count(p) | +----------+ | 21 | +----------+ 1 row ColumnFilter | +EagerAggregation | +Filter | +SimplePatternMatcher | +SchemaIndex +----------------------+------+--------+----------------------+------------------------------------------------------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +----------------------+------+--------+----------------------+------------------------------------------------------------------------+ | ColumnFilter | 1 | 0 | | keep columns count(p) | | EagerAggregation | 1 | 0 | | | | Filter | 21 | 63 | | (hasLabel(p:BlogPost(1)) AND Property(p,active(8)) == { AUTOSTRING1}) | | SimplePatternMatcher | 21 | 105 | user, p, UNNAMED85 | | | SchemaIndex | 1 | 2 | user, user | { AUTOSTRING0}; :User(_id) | +----------------------+------+--------+----------------------+------------------------------------------------------------------------+ Total database accesses: 170\n\nAs we can see, the indexed property is not used by Cypher and it needs to filter on all blog posts. Using a dedicated label is thus more performant.\n\nGoing further with some tips and tricks\n\nWe will not stop here! We would like to share some tips that will help you optimize your Cypher queries.\n\nAlways use dedicated labels for positives\n\nYou may want to ask: why not adding a Draft label on the BlogPost nodes for non-active blog posts?\n\nThe reason is that this would force an additional negation filter when retrieving active blog posts, and negation in Cypher is costly :\n\nPROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) WITH user MATCH (user)-[:WRITTEN]->(p:BlogPost) WHERE NOT p :Draft RETURN count(p);\n\nneo4j-sh (?)$ PROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) > WITH user > MATCH (user)-[:WRITTEN]->(p:BlogPost) > WHERE NOT p :Draft > RETURN count(p); +----------+ | count(p) | +----------+ | 21 | +----------+ 1 row ColumnFilter | +EagerAggregation | +Filter | +SimplePatternMatcher | +SchemaIndex +----------------------+------+--------+----------------------+---------------------------------------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +----------------------+------+--------+----------------------+---------------------------------------------------------+ | ColumnFilter | 1 | 0 | | keep columns count(p) | | EagerAggregation | 1 | 0 | | | | Filter | 21 | 42 | | (hasLabel(p:BlogPost(1)) AND NOT(hasLabel(p:Draft(3)))) | | SimplePatternMatcher | 21 | 70 | user, p, UNNAMED85 | | | SchemaIndex | 1 | 2 | user, user | { AUTOSTRING0}; :User(_id) | +----------------------+------+--------+----------------------+---------------------------------------------------------+ Total database accesses: 114\n\nAvoid the need to match on multiple labels\n\nSome designs we have encountered were making too much use of dedicated labels, forcing queries to match on multiple labels to fetch the desired set of nodes.\n\nMatching on more than one label will make Cypher apply an additional hasLabel filter :\n\nPROFILE MATCH (post:BlogPost:ActivePost) RETURN count(post);\n\nneo4j-sh (?)$ PROFILE MATCH (post:BlogPost:ActivePost) RETURN count(post); +-------------+ | count(post) | +-------------+ | 200 | +-------------+ 1 row ColumnFilter | +EagerAggregation | +Filter | +NodeByLabel +------------------+------+--------+-------------+------------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +------------------+------+--------+-------------+------------------------------+ | ColumnFilter | 1 | 0 | | keep columns count(post) | | EagerAggregation | 1 | 0 | | | | Filter | 200 | 400 | | hasLabel(post:ActivePost(2)) | | NodeByLabel | 400 | 401 | post, post | :BlogPost | +------------------+------+--------+-------------+------------------------------+ Total database accesses: 801\n\nWe can see here that the number of database accesses is growing and you can imagine that it will be costly when we have millions of blog posts or entities in the database.\n\nUse well named relationship types to avoid some use of labels\n\nWhen looking up patterns, specifying the label of the end node will force Cypher to filter on labels.\n\nDedicated and clear relationship types will help you traverse the graph easily and make full use of the powerful graph model, gaining performance by not having to match on labels.\n\nLet\u2019s refactor our little model by adding a PUBLISHED relationship from User to ActivePost nodes and a DRAFTED relationship to the others.\n\nMATCH (n:ActivePost) WITH n MATCH (n)<-[:WRITTEN]-(u) MERGE (u)-[:PUBLISHED]->(n);\n\nMATCH (n:BlogPost) WHERE NOT n :ActivePost WITH n MATCH (n)<-[:WRITTEN]-(u) MERGE (u)-[:DRAFTED]->(n);\n\nThe very advantage of Neo4j is that nodes contain references to the relationships they connected to them. This means that once we have a starting point in the graph, following relationships from nodes to nodes costs almost nothing :\n\nPROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) WITH user MATCH (user)-[:PUBLISHED]->(p) RETURN count(p);\n\nneo4j-sh (?)$ PROFILE MATCH (user:User {_id:'c922ea0d-45d6-375b-b91a-470933592c2a'}) > WITH user > MATCH (user)-[:PUBLISHED]->(p) > RETURN count(p); +----------+ | count(p) | +----------+ | 21 | +----------+ 1 row ColumnFilter | +EagerAggregation | +SimplePatternMatcher | +SchemaIndex +----------------------+------+--------+----------------------+-----------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +----------------------+------+--------+----------------------+-----------------------------+ | ColumnFilter | 1 | 0 | | keep columns count(p) | | EagerAggregation | 1 | 0 | | | | SimplePatternMatcher | 21 | 0 | user, p, UNNAMED85 | | | SchemaIndex | 1 | 2 | user, user | { AUTOSTRING0}; :User(_id) | +----------------------+------+--------+----------------------+-----------------------------+ Total database accesses: 2\n\nAs we can see, we did not define any labels because we know that the :PUBLISHED relationship will point to blog posts that are active and retrieving thousands of blog posts will just cost us nothing more than using the schema index for our user and a few traversals from the user to blog post nodes by following their relationships.\n\nConclusion\n\nA good design of your graph database model will help you perform very fast queries and provide a good user experience. Testing your queries and the usage of the query profiler can help you discover bottlenecks in your schema and should be done regularly during the development process, before going to production with a large data set.\n\nNote: This blog post is a follow up of my StackOverflow answer on the subject"
}