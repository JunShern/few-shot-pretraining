{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0', '2', '0', '0', '0', '2']."
        }
    ],
    "doc_id": "8317",
    "text": "Q:\n\nARM clock speed on raspberry pi\n\nRunning bare-metal (no operating system, no Linux)\nThe specs implies the ARM can/does run 700MHz, the sys clock matches the manual and appears to be running at 250MHz.  Simple tests on the ARM imply that it is doing the same, for example with the instruction cache on\ntest:\n  subs r0,r0,#1\n  bne test\n\nAnd vary the number of subs instructions to dominate over the branch, it is in the ball park of 250MHz but a long way away from 700MHz.\nI there a phy setting that I am not seeing in the datasheet for multiplying the ARM clock?\nEDIT:\nMaybe my assumptions are flawed...\n.globl ARMTEST0\nARMTEST0:\n    subs r0,r0,#1\n    bne ARMTEST0\n    bx lr\n\n.globl ARMTEST1\nARMTEST1:\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    bne ARMTEST1\n    bx lr\n\n.globl ARMTEST2\nARMTEST2:\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    subs r0,r0,#1\n    bne ARMTEST2\n    bx lr\n\n.globl ARMTEST3\nARMTEST3:\n    subs r1,r0,#1\n    subs r2,r1,#1\n    subs r3,r2,#1\n    subs r0,r3,#1\n    subs r1,r0,#1\n    subs r2,r1,#1\n    subs r3,r2,#1\n    subs r0,r3,#1\n    subs r1,r0,#1\n    subs r2,r1,#1\n    subs r3,r2,#1\n    subs r0,r3,#1\n    subs r1,r0,#1\n    subs r2,r1,#1\n    subs r3,r2,#1\n    subs r0,r3,#1\n    bne ARMTEST3\n    bx lr\n\nSystem timer ticks in hex per function (250Mhz system timer verified against stopwatch, etc).\n02DB6DF7 ARMTEST0\n02DB6E1C ARMTEST0\n00AB6E2A ARMTEST1\n00836E46 ARMTEST2\n00836E2A ARMTEST3\n\nWhich gives:\nARMTEST0\n0x01000000 subs instructions\n0x01000000 bne  instructions\n0x02000000 instructions\n1.43 clocks per instruction.  175Mips.\n\nARMTEST1\n0x01000000 sub instructions\n0x00200000 bne instructions\n0x01200000 instructions\n1.68 instructions per clock. 420Mips\n\nARMTEST2\n0x01000000 sub instructions\n0x00100000 bne instructions\n0x01100000 instructions\n2.07 instructions per clock. 517Mips\n\nARMTEST3\n0x01000000 sub instructions\n0x00100000 bne instructions\n0x01100000 instructions\n2.07 instructions per clock. 517Mips\n\nThe ARM11 is super-scalar more than one instruction per clock is not unexpected.  I would expect more though.  Using only register 0 might mess with the pipe as you have to wait for one result of one instruction before executing the next.  I was expecting to see a difference between test 2 and 3, perhaps another bad assumption.  Maybe its really 500Mhz not 700?  There is one line in the linux sources that mentions a 500000000 clock.\nstatic struct clk osc_clk = {\n#ifdef CONFIG_ARCH_BCM2708_CHIPIT\n    .rate = 27000000,\n#else\n    .rate = 500000000,  /* ARM clock is set from the VideoCore booter */\n#endif\n};\n\n/* warning - the USB needs a clock > 34MHz */\n\n#ifdef CONFIG_MMC_BCM2708\nstatic struct clk sdhost_clk = {\n#ifdef CONFIG_ARCH_BCM2708_CHIPIT\n    .rate = 4000000,    /* 4MHz */\n#else\n    .rate = 250000000,  /* 250MHz */\n#endif\n};\n#endif\n\nMaybe what I think I have measured as 250Mhz is 270 and the ARM is at 500MHz?\nEDIT2...DOH\nThat wasnt a great pipeline improvement was it, this is better:\n.globl ARMTEST3\nARMTEST3:\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    subs r0,r0,#1\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    nop\n    bne ARMTEST3\n    bx lr\n\n    ARMTEST3\n    0x01000000 sub instructions\n    0x08000000 nop instructions\n    0x00100000 bne instructions\n    0x09100000 instructions\n    037000D7 system clocks\n    2.64 instructions per clock. 659Mips\n\nI failed to get config.txt to work at first, then re-build a linux sd card, booted it to find that the /boot/ directory is in fact the fat partition that contains the gpu boot files and the kernel.img arm boot file.  So NOT in a boot/ dir but in that same dir with the .bin's and .elf and .img file create config.txt and put arm_freq=something, the gpu bootloader then makes the modification to the pll multiplier so that when the arm starts it is at that speed.  I still expect more than 700 million instructions per second and am not seeing that, will need to keep trying I guess.\n\nA:\n\nMight be worth looking at the boot loader provided with the Arch Linux reference distribution from the Raspberry Pi organisation's download pages.  I have no idea whether it's a working option, but its config.txt includes the line\n#arm_freq=800\n\nThere are also reports of people having overclocked the Pi - so information about initialising the clock is certainly out there, somewhere.\n\n"
}