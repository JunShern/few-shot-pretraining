{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['What accounts for the dots in the names of these functions (0.197)']."
        }
    ],
    "doc_id": "5489",
    "text": "Q:\n\nWhat accounts for the dots in the names of these functions\n\nI'm debugging why my Boost.Python module won't load in Ubuntu.  Interestingly, the problem comes before my module is actually loaded.  A simple, foo C++ module confirms this.  The stack trace shows calls to boost::python::* which are absent in our larger lib.  Thus, I know that the seg fault occurs before my module is even attempted.\nThe below stacktrace is for the failing library which gets a segfault.  My question is, what are the dots in the function names?  Not all functions have them.  For example, frame #62 0x0000000000547692 in PyErr_PrintEx.part.3.42666 ().  I can grep through the Python sources and find PyErr_PrintEx, but I don't find the rest.  What is that?\n#0  0x0000000002344596 in ?? ()\nNo symbol table info available.\n#1  0x00007f5f02d72258 in std::string::_S_construct<char const*> (__beg=\n    0x7f5efb565f46 \"amd64\", __end=0x7f5efb565f4b \"\", __a=...)\n    at /usr/include/c++/4.6/bits/basic_string.tcc:134\n        __dnew = 116\n        __r = 0x7\n#2  0x00007f5efdf505e3 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) ()\n   from /usr/lib/x86_64-linux-gnu/libstdc++.so.6\nNo symbol table info available.\n#3  0x00007f5efb4ebdfe in pkgInitConfig(Configuration&) ()\n   from /usr/lib/x86_64-linux-gnu/libapt-pkg.so.4.12\nNo symbol table info available.\n#4  0x00007f5efb7aa395 in ?? ()\n   from /usr/lib/python2.7/dist-packages/apt_pkg.so\nNo symbol table info available.\n#5  0x000000000056d4a4 in PyEval_EvalFrameEx ()\nNo locals.\n#6  0x00000000005747c0 in PyEval_EvalCodeEx ()\nNo locals.\n#7  0x0000000000568e58 in PyImport_ExecCodeModuleEx ()\nNo locals.\n#8  0x000000000042bf11 in load_source_module.39049 ()\nNo locals.\n#9  0x0000000000566f80 in load_package.39142 ()\nNo locals.\n#10 0x000000000042c90b in import_submodule.39103 ()\nNo locals.\n#11 0x000000000046895d in load_next.39108 ()\nNo locals.\n#12 0x000000000042d164 in import_module_level.isra.3.39129 ()\nNo locals.\n#13 0x00000000005167db in builtin___import__.32784 ()\nNo locals.\n#14 0x000000000043a8b6 in PyObject_Call ()\nNo locals.\n#15 0x000000000043b626 in PyEval_CallObjectWithKeywords ()\nNo locals.\n#16 0x000000000056f95b in PyEval_EvalFrameEx ()\nNo locals.\n#17 0x00000000005747c0 in PyEval_EvalCodeEx ()\nNo locals.\n#18 0x0000000000568e58 in PyImport_ExecCodeModuleEx ()\nNo locals.\n#19 0x000000000042bf11 in load_source_module.39049 ()\nNo locals.\n#20 0x000000000042c90b in import_submodule.39103 ()\nNo locals.\n#21 0x00000000004688d3 in load_next.39108 ()\nNo locals.\n#22 0x000000000042d326 in import_module_level.isra.3.39129 ()\nNo locals.\n#23 0x00000000005167db in builtin___import__.32784 ()\nNo locals.\n#24 0x000000000043a8b6 in PyObject_Call ()\nNo locals.\n#25 0x000000000043b626 in PyEval_CallObjectWithKeywords ()\nNo locals.\n#26 0x000000000056f95b in PyEval_EvalFrameEx ()\nNo locals.\n#27 0x00000000005747c0 in PyEval_EvalCodeEx ()\nNo locals.\n#28 0x0000000000568e58 in PyImport_ExecCodeModuleEx ()\nNo locals.\n#29 0x000000000042bf11 in load_source_module.39049 ()\nNo locals.\n#30 0x000000000042c90b in import_submodule.39103 ()\nNo locals.\n#31 0x00000000004688d3 in load_next.39108 ()\nNo locals.\n#32 0x000000000042d326 in import_module_level.isra.3.39129 ()\nNo locals.\n#33 0x00000000005167db in builtin___import__.32784 ()\nNo locals.\n#34 0x000000000043a8b6 in PyObject_Call ()\nNo locals.\n#35 0x000000000043b626 in PyEval_CallObjectWithKeywords ()\nNo locals.\n#36 0x000000000056f95b in PyEval_EvalFrameEx ()\nNo locals.\n#37 0x00000000005747c0 in PyEval_EvalCodeEx ()\nNo locals.\n#38 0x0000000000568e58 in PyImport_ExecCodeModuleEx ()\nNo locals.\n#39 0x000000000042bf11 in load_source_module.39049 ()\nNo locals.\n#40 0x000000000042c90b in import_submodule.39103 ()\nNo locals.\n#41 0x00000000004688d3 in load_next.39108 ()\nNo locals.\n#42 0x000000000042d326 in import_module_level.isra.3.39129 ()\nNo locals.\n#43 0x00000000005167db in builtin___import__.32784 ()\nNo locals.\n#44 0x000000000043a8b6 in PyObject_Call ()\nNo locals.\n#45 0x000000000043b626 in PyEval_CallObjectWithKeywords ()\nNo locals.\n#46 0x000000000056f95b in PyEval_EvalFrameEx ()\nNo locals.\n#47 0x00000000005747c0 in PyEval_EvalCodeEx ()\nNo locals.\n#48 0x0000000000568e58 in PyImport_ExecCodeModuleEx ()\nNo locals.\n#49 0x000000000042bf11 in load_source_module.39049 ()\nNo locals.\n#50 0x0000000000566f80 in load_package.39142 ()\nNo locals.\n#51 0x000000000042c90b in import_submodule.39103 ()\nNo locals.\n#52 0x00000000004688d3 in load_next.39108 ()\nNo locals.\n#53 0x000000000042d164 in import_module_level.isra.3.39129 ()\nNo locals.\n#54 0x00000000005167db in builtin___import__.32784 ()\nNo locals.\n#55 0x000000000043a8b6 in PyObject_Call ()\nNo locals.\n#56 0x000000000043b626 in PyEval_CallObjectWithKeywords ()\nNo locals.\n#57 0x000000000056f95b in PyEval_EvalFrameEx ()\nNo locals.\n#58 0x00000000005747c0 in PyEval_EvalCodeEx ()\nNo locals.\n#59 0x00000000005697b0 in function_call ()\nNo locals.\n#60 0x000000000043a8b6 in PyObject_Call ()\nNo locals.\n#61 0x000000000043b626 in PyEval_CallObjectWithKeywords ()\nNo locals.\n#62 0x0000000000547692 in PyErr_PrintEx.part.3.42666 ()\nNo locals.\n#63 0x000000000056ae1f in PyRun_InteractiveOneFlags ()\nNo locals.\n#64 0x000000000056b155 in PyRun_InteractiveLoopFlags ()\nNo locals.\n#65 0x000000000056bedc in Py_Main ()\nNo locals.\n#66 0x00007f5f04ae576d in __libc_start_main (main=0x41bae0 <main>, argc=1, \n    ubp_av=0x7fff11b14a38, init=<optimized out>, fini=<optimized out>, \n    rtld_fini=<optimized out>, stack_end=0x7fff11b14a28) at libc-start.c:226\n        result = <optimized out>\n        unwind_buf = {cancel_jmp_buf = {{jmp_buf = {0, 8540347331300905646, \n                4307688, 140733490219568, 0, 0, -8540148959998029138, \n                -8630196532358589778}, mask_was_saved = 0}}, priv = {pad = {\n    0x0, 0x0, 0x57d430, 0x7fff11b14a38}, data = {prev = 0x0, cleanup = 0x0, \n              canceltype = 5755952}}}\n        not_first_call = <optimized out>\n#67 0x000000000041bb11 in _start ()\nNo locals.\n\nA:\n\nThe .part forms come from GCC optimization.  GCC will sometimes split a function into multiple parts to enable better inlining of one part.\nFor example, a function might have a test that leads to a fast case and a slow case.  In this situation GCC may choose to put the test and the fast case into a small inlineable function, and then put the slow case in a .part function.  This way the fast path can be inlined into callers.\n\n"
}