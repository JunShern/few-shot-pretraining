{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2059",
    "text": "Q:\n\nCancellationTokenSource.Cancel doesn't work during WPF app exit\n\nHere is a simple async call with cancellation code snippet.  The code sits in a WPF application class.  If I call the Cancel method via a WPF UI Command, the async method will exit properly.  However, if the Cancel is invoked during the OnExit method, nothing happens.  My actual code requires OnExit call because the async method uses IO resources that should be cleaned up properly.\nAny ideas?\nEdit:  the expected behavior is that Task.Delay method should throw the OperationCancelledException when cancel is invoked.  What I want to know is why it doesn't during app exit and if there are work around to get it behaving properly.\npublic partial class App : Application {\n    protected override void OnStartup(StartupEventArgs e) {\n        base.OnStartup(e);\n        ListenAsync(source.Token);\n    }\n\n    ManualResetEvent waitHandle = new ManualResetEvent(false);\n    CancellationTokenSource source = new CancellationTokenSource();\n\n    public void Cancel() {\n        source.Cancel();\n    }\n\n    async void ListenAsync(CancellationToken token) {\n        try {\n            while (true) {\n                await Task.Delay(300000, token);\n            }\n        } catch (OperationCanceledException) {\n            Console.WriteLine(\"Cancelled\");\n        } catch (Exception err) {\n            Console.WriteLine(err.Message);\n        } finally {\n            Console.WriteLine(\"Terminate\");\n            waitHandle.Set();\n        }\n    }\n\n    protected override void OnExit(ExitEventArgs e) {\n        Cancel();\n        waitHandle.WaitOne();\n        base.OnExit(e);\n    }\n}\n\nA:\n\nFound the problem.  \nThe Cancel call during WPF App Exit is on the same synchronization context as the ListenAsync function.  Because the thread is blocked by the waitHandle.WaitOne, there is no way for the ListenAsync method to resume executing on the same synchronization context.  \nThe problem can be resolved by changing the async call to \nawait Task.Delay(300000, token).ConfigureAwait(false);\n\nThis allows the remainder of the ListenAsync function to stay on the sync context of the Task.Delay function.\n\n"
}