{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 8 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2897",
    "text": "// @tag core\n// @define Ext.Boot\n\nvar Ext = Ext || {};\n\n//<editor-fold desc=\"Boot\">\n/**\n * @class Ext.Boot\n * @singleton\n * @private\n */\nExt.Boot = Ext.Boot || (function (emptyFn) {\n\n    var doc = document,\n        _emptyArray = [],\n        _config = {\n            /**\n             * @cfg {Boolean} [disableCaching=true]\n             * If `true` current timestamp is added to script URL's to prevent caching.\n             * In debug builds, adding a \"cache\" or \"disableCacheBuster\" query parameter\n             * to the page's URL will set this to `false`.\n             */\n            disableCaching: (/[?&](?:cache|disableCacheBuster)\\b/i.test(location.search) ||\n                !(/http[s]?\\:/i.test(location.href)) ||\n                /(^|[ ;])ext-cache=1/.test(doc.cookie)) ? false :\n                true,\n\n            /**\n             * @cfg {String} [disableCachingParam=\"_dc\"]\n             * The query parameter name for the cache buster's timestamp.\n             */\n            disableCachingParam: '_dc',\n\n            /**\n             * @cfg {Boolean} loadDelay\n             * Millisecond delay between asynchronous script injection (prevents stack\n             * overflow on some user agents) 'false' disables delay but potentially\n             * increases stack load.\n             */\n            loadDelay: false,\n\n            /**\n             * @cfg {Boolean} preserveScripts\n             * `false` to remove asynchronously loaded scripts, `true` to retain script\n             * element for browser debugger compatibility and improved load performance.\n             */\n            preserveScripts: true,\n\n            /**\n             * @cfg {String} [charset=UTF-8]\n             * Optional charset to specify encoding of dynamic content.\n             */\n            charset: 'UTF-8'\n        },\n\n        _assetConfig= {},\n\n        cssRe = /\\.css(?:\\?|$)/i,\n        resolverEl = doc.createElement('a'),\n        isBrowser = typeof window !== 'undefined',\n        _environment = {\n            browser: isBrowser,\n            node: !isBrowser && (typeof require === 'function'),\n            phantom: (window && (window._phantom || window.callPhantom)) || /PhantomJS/.test(window.navigator.userAgent)\n        },\n        _tags = (Ext.platformTags = {}),\n\n    //<debug>\n        // All calls to _debug are commented out to speed up old browsers a bit;\n        // yes that makes a difference because the cost of concatenating strings\n        // and passing them into _debug() adds up pretty quickly.\n        _debug = function (message) {\n            //console.log(message);\n        },\n    //</debug>\n        _apply = function (object, config, defaults) {\n            if (defaults) {\n                _apply(object, defaults);\n            }\n            if (object && config && typeof config === 'object') {\n                for (var i in config) {\n                    object[i] = config[i];\n                }\n            }\n            return object;\n        },\n        _merge = function() {\n            var lowerCase = false,\n                obj = Array.prototype.shift.call(arguments),\n                index, i, len, value;\n\n            if (typeof arguments[arguments.length - 1] === 'boolean') {\n                lowerCase = Array.prototype.pop.call(arguments);\n            }\n\n            len = arguments.length;\n            for (index = 0; index < len; index++) {\n                value = arguments[index];\n                if (typeof value === 'object') {\n                    for (i in value) {\n                        obj[lowerCase ? i.toLowerCase() : i] = value[i];\n                    }\n                }\n            }\n\n            return obj;\n        },\n        _getKeys = (typeof Object.keys == 'function') ?\n            function(object){\n                if (!object) {\n                    return [];\n                }\n                return Object.keys(object);\n            } :\n            function(object) {\n                var keys = [],\n                    property;\n\n                for (property in object) {\n                    if (object.hasOwnProperty(property)) {\n                        keys.push(property);\n                    }\n                }\n\n                return keys;\n            },\n    /*\n     * The Boot loader class manages Request objects that contain one or\n     * more individual urls that need to be loaded.  Requests can be performed\n     * synchronously or asynchronously, but will always evaluate urls in the\n     * order specified on the request object.\n     */\n        Boot = {\n            loading: 0,\n            loaded: 0,\n            apply: _apply,\n            env: _environment,\n            config: _config,\n\n            /**\n             * @cfg {Object} assetConfig\n             * A map (url->assetConfig) that contains information about assets loaded by the Microlaoder.\n             */\n            assetConfig: _assetConfig,\n\n            // Keyed by absolute URL this object holds \"true\" if that URL is already loaded\n            // or an array of callbacks to call once it loads.\n            scripts: {\n                /*\n                 Entry objects\n\n                 'http://foo.com/bar/baz/Thing.js': {\n                 done: true,\n                 el: scriptEl || linkEl,\n                 preserve: true,\n                 requests: [ request1, ... ]\n                 }\n                 */\n            },\n\n            /**\n             * contains the current script name being loaded\n             * (loadSync or sequential load only)\n             */\n            currentFile: null,\n            suspendedQueue: [],\n            currentRequest: null,\n\n            // when loadSync is called, need to cause subsequent load requests to also be loadSync,\n            // eg, when Ext.require(...) is called\n            syncMode: false,\n\n            /*\n             * simple helper method for debugging\n             */\n            //<debug>\n            debug: _debug,\n            //</debug>\n\n            /**\n             * enables / disables loading scripts via script / link elements rather\n             * than using ajax / eval\n             */\n            useElements: true,\n\n            listeners: [],\n\n            Request: Request,\n\n            Entry: Entry,\n\n            allowMultipleBrowsers: false,\n\n            browserNames: {\n                ie: 'IE',\n                firefox: 'Firefox',\n                safari: 'Safari',\n                chrome: 'Chrome',\n                opera: 'Opera',\n                dolfin: 'Dolfin',\n                edge: 'Edge',\n                webosbrowser: 'webOSBrowser',\n                chromeMobile: 'ChromeMobile',\n                chromeiOS: 'ChromeiOS',\n                silk: 'Silk',\n                other: 'Other'\n            },\n\n            osNames: {\n                ios: 'iOS',\n                android: 'Android',\n                windowsPhone: 'WindowsPhone',\n                webos: 'webOS',\n                blackberry: 'BlackBerry',\n                rimTablet: 'RIMTablet',\n                mac: 'MacOS',\n                win: 'Windows',\n                tizen: 'Tizen',\n                linux: 'Linux',\n                bada: 'Bada',\n                chromeOS: 'ChromeOS',\n                other: 'Other'\n            },\n\n            browserPrefixes: {\n                ie: 'MSIE ',\n                edge: 'Edge/',\n                firefox: 'Firefox/',\n                chrome: 'Chrome/',\n                safari: 'Version/',\n                opera: 'OPR/',\n                dolfin: 'Dolfin/',\n                webosbrowser: 'wOSBrowser/',\n                chromeMobile: 'CrMo/',\n                chromeiOS: 'CriOS/',\n                silk: 'Silk/'\n            },\n\n            // When a UA reports multiple browsers this list is used to prioritize the 'real' browser\n            // lower index number will win\n            browserPriority: [\n                'edge',\n                'opera',\n                'dolfin',\n                'webosbrowser',\n                'silk',\n                'chromeiOS',\n                'chromeMobile',\n                'ie',\n                'firefox',\n                'safari',\n                'chrome'\n            ],\n\n            osPrefixes: {\n                tizen: '(Tizen )',\n                ios: 'i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ',\n                android: '(Android |HTC_|Silk/)', // Some HTC devices ship with an OSX userAgent by default,\n                // so we need to add a direct check for HTC_\n                windowsPhone: 'Windows Phone ',\n                blackberry: '(?:BlackBerry|BB)(?:.*)Version\\/',\n                rimTablet: 'RIM Tablet OS ',\n                webos: '(?:webOS|hpwOS)\\/',\n                bada: 'Bada\\/',\n                chromeOS: 'CrOS '\n            },\n\n            fallbackOSPrefixes: {\n                windows: 'win',\n                mac: 'mac',\n                linux: 'linux'\n            },\n\n            devicePrefixes: {\n                iPhone: 'iPhone',\n                iPod: 'iPod',\n                iPad: 'iPad'\n            },\n\n            maxIEVersion: 12,\n\n\n            /**\n             * The default function that detects various platforms and sets tags\n             * in the platform map accordingly.  Examples are iOS, android, tablet, etc.\n             * @param tags the set of tags to populate\n             */\n            detectPlatformTags: function () {\n                var me = this,\n                    ua = navigator.userAgent,\n                    isMobile = /Mobile(\\/|\\s)/.test(ua),\n                    element = document.createElement('div'),\n                    isEventSupported = function (name, tag) {\n                        if (tag === undefined) {\n                            tag = window;\n                        }\n\n                        var eventName = 'on' + name.toLowerCase(),\n                            isSupported = (eventName in element);\n\n                        if (!isSupported) {\n                            if (element.setAttribute && element.removeAttribute) {\n                                element.setAttribute(eventName, '');\n                                isSupported = typeof element[eventName] === 'function';\n\n                                if (typeof element[eventName] !== 'undefined') {\n                                    element[eventName] = undefined;\n                                }\n\n                                element.removeAttribute(eventName);\n                            }\n                        }\n\n                        return isSupported;\n                    },\n\n                    // Browser Detection\n                    getBrowsers = function () {\n                        var browsers = {},\n                            maxIEVersion, prefix,\n                            value, key, index, len, match, version, matched;\n\n                        // MS Edge browser (and possibly others) can report multiple browsers in the UserAgent\n                        // \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240\"\n                        // we use this to prioritize the actual browser in this situation\n                        len = me.browserPriority.length;\n                        for (index = 0; index < len; index++) {\n                            key = me.browserPriority[index];\n                            if (!matched) {\n                                value = me.browserPrefixes[key];\n                                match = ua.match(new RegExp('(' + value + ')([\\\\w\\\\._]+)'));\n                                version = match && match.length > 1 ? parseInt(match[2]) : 0;\n                                if (version) {\n                                    matched = true;\n                                }\n                            } else {\n                                version = 0;\n                            }\n                            browsers[key] = version;\n                        }\n\n                        //Deal with IE document mode\n                        if (browsers.ie) {\n                            var mode = document.documentMode;\n\n                            if (mode >= 8) {\n                                browsers.ie = mode;\n                            }\n                        }\n\n                        // Fancy IE greater than and less then quick tags\n                        version = browsers.ie || false;\n                        maxIEVersion = Math.max(version, me.maxIEVersion);\n\n                        for (index = 8; index <= maxIEVersion; ++index) {\n                            prefix = 'ie' + index;\n                            browsers[prefix + 'm'] = version ? version <= index : 0;\n                            browsers[prefix] = version ? version === index : 0;\n                            browsers[prefix + 'p'] = version ? version >= index : 0;\n                        }\n\n                        return browsers;\n                    },\n\n                    //OS Detection\n                    getOperatingSystems = function () {\n                        var systems = {},\n                            value, key, keys, index, len, match, matched, version, activeCount;\n\n                        keys = _getKeys(me.osPrefixes);\n                        len = keys.length;\n                        for (index = 0, activeCount = 0; index < len; index++) {\n                            key = keys[index];\n                            value = me.osPrefixes[key];\n                            match = ua.match(new RegExp('(' + value + ')([^\\\\s;]+)'));\n                            matched = match ? match[1] : null;\n\n                            // This is here because some HTC android devices show an OSX Snow Leopard userAgent by default.\n                            // And the Kindle Fire doesn't have any indicator of Android as the OS in its User Agent\n                            if (matched && (matched === 'HTC_' || matched === 'Silk/')) {\n                                version = 2.3;\n                            } else {\n                                version = match && match.length > 1 ? parseFloat(match[match.length - 1]) : 0;\n                            }\n\n                            if (version) {\n                                activeCount++;\n                            }\n                            systems[key] = version;\n                        }\n\n                        keys = _getKeys(me.fallbackOSPrefixes);\n\n                        // If no OS could be found we resort to the fallbacks, otherwise we just\n                        // falsify the fallbacks\n                        len = keys.length;\n                        for (index = 0; index < len; index++) {\n                            key = keys[index];\n\n                            // No OS was detected from osPrefixes\n                            if (activeCount === 0) {\n                                value = me.fallbackOSPrefixes[key];\n                                match = ua.toLowerCase().match(new RegExp(value));\n                                systems[key] = match ? true : 0;\n                            } else {\n                                systems[key] = 0;\n                            }\n                        }\n\n                        return systems;\n                    },\n\n                    // Device Detection\n                    getDevices = function () {\n                        var devices = {},\n                            value, key, keys, index, len, match;\n\n                        keys = _getKeys(me.devicePrefixes);\n                        len = keys.length;\n                        for (index = 0; index < len; index++) {\n                            key = keys[index];\n                            value = me.devicePrefixes[key];\n                            match = ua.match(new RegExp(value));\n                            devices[key] = match ? true : 0;\n                        }\n\n                        return devices;\n                    },\n                    browsers = getBrowsers(),\n                    systems = getOperatingSystems(),\n                    devices = getDevices(),\n                    platformParams = Boot.loadPlatformsParam();\n\n                // We apply platformParams from the query here first to allow for forced user valued\n                // to be used in calculation of generated tags\n                _merge(_tags, browsers, systems, devices, platformParams, true);\n\n                _tags.phone = !!((_tags.iphone || _tags.ipod) ||\n                    (!_tags.silk && (_tags.android && (_tags.android < 3 || isMobile))) ||\n                    (_tags.blackberry && isMobile) ||\n                    (_tags.windowsphone));\n\n                _tags.tablet = !!(!_tags.phone && (\n                        _tags.ipad ||\n                        _tags.android ||\n                        _tags.silk ||\n                        _tags.rimtablet ||\n                        (_tags.ie10 && /; Touch/.test(ua))\n                    ));\n\n                _tags.touch =\n                    // if the browser has touch events we can be reasonably sure the device has\n                    // a touch screen\n                    isEventSupported('touchend') ||\n                    // browsers that use pointer event have maxTouchPoints > 0 if the\n                    // device supports touch input\n                    // http://www.w3.org/TR/pointerevents/#widl-Navigator-maxTouchPoints\n                    navigator.maxTouchPoints ||\n                    // IE10 uses a vendor-prefixed maxTouchPoints property\n                    navigator.msMaxTouchPoints;\n\n                _tags.desktop = !_tags.phone && !_tags.tablet;\n                _tags.cordova = _tags.phonegap = !!(window.PhoneGap || window.Cordova || window.cordova);\n                _tags.webview = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(ua);\n                _tags.androidstock = (_tags.android <= 4.3) && (_tags.safari || _tags.silk);\n\n                // Re-apply any query params here to allow for user override of generated tags (desktop, touch, tablet, etc)\n                _merge(_tags, platformParams, true);\n            },\n\n            /**\n             * Extracts user supplied platform tags from the \"platformTags\" query parameter\n             * of the form:\n             *\n             *      ?platformTags=name:state,name:state,...\n             *\n             * (each tag defaults to true when state is unspecified)\n             *\n             * Example:\n             *\n             *      ?platformTags=isTablet,isPhone:false,isDesktop:0,iOS:1,Safari:true, ...\n             *\n             * @returns {Object} the platform tags supplied by the query string\n             */\n            loadPlatformsParam: function () {\n                // Check if the ?platform parameter is set in the URL\n                var paramsString = window.location.search.substr(1),\n                    paramsArray = paramsString.split(\"&\"),\n                    params = {}, i,\n                    platforms = {},\n                    tmpArray, tmplen, platform, name, enabled;\n\n                for (i = 0; i < paramsArray.length; i++) {\n                    tmpArray = paramsArray[i].split(\"=\");\n                    params[tmpArray[0]] = tmpArray[1];\n                }\n\n                if (params.platformTags) {\n                    tmpArray = params.platformTags.split(\",\");\n                    for (tmplen = tmpArray.length, i = 0; i < tmplen; i++) {\n                        platform = tmpArray[i].split(\":\");\n                        name = platform[0];\n                        enabled=true;\n                        if (platform.length > 1) {\n                            enabled = platform[1];\n                            if (enabled === 'false' || enabled === '0') {\n                                enabled = false;\n                            }\n                        }\n                        platforms[name] = enabled;\n                    }\n                }\n                return platforms;\n            },\n\n            filterPlatform: function (platform, excludes) {\n                platform = _emptyArray.concat(platform || _emptyArray);\n                excludes = _emptyArray.concat(excludes || _emptyArray);\n\n                var plen = platform.length,\n                    elen = excludes.length,\n                    include = (!plen && elen), // default true if only excludes specified\n                    i, tag;\n\n                for (i = 0; i < plen && !include; i++) {\n                    tag = platform[i];\n                    include = !!_tags[tag];\n                }\n\n                for (i = 0; i < elen && include; i++) {\n                    tag = excludes[i];\n                    include = !_tags[tag];\n                }\n\n                return include;\n            },\n\n            init: function () {\n                var scriptEls = doc.getElementsByTagName('script'),\n                    script = scriptEls[0],\n                    len = scriptEls.length,\n                    re = /\\/ext(\\-[a-z\\-]+)?\\.js$/,\n                    entry, src, state, baseUrl, key, n, origin;\n\n                // No check for script definedness because there always should be at least one\n                Boot.hasReadyState = (\"readyState\" in script);\n                Boot.hasAsync = (\"async\" in script);\n                Boot.hasDefer = (\"defer\" in script);\n                Boot.hasOnLoad = (\"onload\" in script);\n                \n                // Feature detecting IE\n                Boot.isIE8 = Boot.hasReadyState && !Boot.hasAsync && Boot.hasDefer && !Boot.hasOnLoad;\n                Boot.isIE9 = Boot.hasReadyState && !Boot.hasAsync && Boot.hasDefer && Boot.hasOnLoad;\n                Boot.isIE10p = Boot.hasReadyState && Boot.hasAsync && Boot.hasDefer && Boot.hasOnLoad;\n\n                Boot.isIE10 = (new Function('/*@cc_on return @_jscript_version @*/')()) === 10;\n                Boot.isIE10m = Boot.isIE10 || Boot.isIE9 || Boot.isIE8;\n                \n                // IE11 does not support conditional compilation so we detect it by exclusion\n                Boot.isIE11 = Boot.isIE10p && !Boot.isIE10;\n\n                // Since we are loading after other scripts, and we needed to gather them\n                // anyway, we track them in _scripts so we don't have to ask for them all\n                // repeatedly.\n                for (n = 0; n < len; n++) {\n                    src = (script = scriptEls[n]).src;\n                    if (!src) {\n                        continue;\n                    }\n                    state = script.readyState || null;\n\n                    // If we find a script file called \"ext-*.js\", then the base path is that file's base path.\n                    if (!baseUrl && re.test(src)) {\n                        baseUrl = src;\n                    }\n\n                    if (!Boot.scripts[key = Boot.canonicalUrl(src)]) {\n                        //<debug>\n//                         _debug(\"creating entry \" + key + \" in Boot.init\");\n                        //</debug>\n                        entry = new Entry({\n                            key: key,\n                            url: src,\n                            done: state === null ||  // non-IE\n                                state === 'loaded' || state === 'complete', // IE only\n                            el: script,\n                            prop: 'src'\n                        });\n                    }\n                }\n\n                if (!baseUrl) {\n                    script = scriptEls[scriptEls.length - 1];\n                    baseUrl = script.src;\n                }\n\n                Boot.baseUrl = baseUrl.substring(0, baseUrl.lastIndexOf('/') + 1);\n                origin = window.location.origin ||\n                    window.location.protocol +\n                    \"//\" +\n                    window.location.hostname +\n                    (window.location.port ? ':' + window.location.port: '');\n                Boot.origin = origin;\n\n                Boot.detectPlatformTags();\n                Ext.filterPlatform = Boot.filterPlatform;\n            },\n\n            /**\n             * This method returns a canonical URL for the given URL.\n             *\n             * For example, the following all produce the same canonical URL (which is the\n             * last one):\n             *\n             *      http://foo.com/bar/baz/zoo/derp/../../goo/Thing.js?_dc=12345\n             *      http://foo.com/bar/baz/zoo/derp/../../goo/Thing.js\n             *      http://foo.com/bar/baz/zoo/derp/../jazz/../../goo/Thing.js\n             *      http://foo.com/bar/baz/zoo/../goo/Thing.js\n             *      http://foo.com/bar/baz/goo/Thing.js\n             *\n             * @private\n             */\n            canonicalUrl: function (url) {\n                // *WARNING WARNING WARNING*\n                // This method yields the most correct result we can get but it is EXPENSIVE!\n                // In ALL browsers! When called multiple times in a sequence, as if when\n                // we resolve dependencies for entries, it will cause garbage collection events\n                // and overall painful slowness. This is why we try to avoid it as much as we can.\n                // \n                // @TODO - see if we need this fallback logic\n                // http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n                resolverEl.href = url;\n\n                var ret = resolverEl.href,\n                    dc = _config.disableCachingParam,\n                    pos = dc ? ret.indexOf(dc + '=') : -1,\n                    c, end;\n\n                // If we have a _dc query parameter we need to remove it from the canonical\n                // URL.\n                if (pos > 0 && ((c = ret.charAt(pos - 1)) === '?' || c === '&')) {\n                    end = ret.indexOf('&', pos);\n                    end = (end < 0) ? '' : ret.substring(end);\n                    if (end && c === '?') {\n                        ++pos; // keep the '?'\n                        end = end.substring(1); // remove the '&'\n                    }\n                    ret = ret.substring(0, pos - 1) + end;\n                }\n\n                return ret;\n            },\n\n            /**\n             * Get the config value corresponding to the specified name. If no name is given, will return the config object\n             * @param {String} name The config property name\n             * @return {Object}\n             */\n            getConfig: function (name) {\n                return name ? Boot.config[name] : Boot.config;\n            },\n\n            /**\n             * Set the configuration.\n             * @param {Object} config The config object to override the default values.\n             * @return {Ext.Boot} this\n             */\n            setConfig: function (name, value) {\n                if (typeof name === 'string') {\n                    Boot.config[name] = value;\n                } else {\n                    for (var s in name) {\n                        Boot.setConfig(s, name[s]);\n                    }\n                }\n                return Boot;\n            },\n\n            getHead: function () {\n                return Boot.docHead ||\n                    (Boot.docHead = doc.head ||\n                        doc.getElementsByTagName('head')[0]);\n            },\n\n            create: function (url, key, cfg) {\n                var config = cfg || {};\n                config.url = url;\n                config.key = key;\n                return Boot.scripts[key] = new Entry(config);\n            },\n\n            getEntry: function (url, cfg, canonicalPath) {\n                var key, entry;\n                \n                // Canonicalizing URLs via anchor element href yields the most correct result\n                // but is *extremely* resource heavy so we need to avoid it whenever possible\n                key = canonicalPath ? url : Boot.canonicalUrl(url);\n                entry = Boot.scripts[key];\n                \n                if (!entry) {\n                    entry = Boot.create(url, key, cfg);\n                    \n                    if (canonicalPath) {\n                        entry.canonicalPath = true;\n                    }\n                }\n                \n                return entry;\n            },\n\n            registerContent: function (url, type, content) {\n                var cfg = {\n                    content: content,\n                    loaded: true,\n                    css: type === 'css'\n                };\n\n                return Boot.getEntry(url, cfg);\n            },\n\n            processRequest: function(request, sync) {\n                request.loadEntries(sync);\n            },\n\n            load: function (request) {\n                //<debug>\n//                 _debug(\"Boot.load called\");\n                //</debug>\n                var request = new Request(request);\n\n                if (request.sync || Boot.syncMode) {\n                    return Boot.loadSync(request);\n                }\n\n                // If there is a request in progress, we must\n                // queue this new request to be fired  when the current request completes.\n                if (Boot.currentRequest) {\n                    //<debug>\n//                     _debug(\"current active request, suspending this request\");\n                    //</debug>\n                    // trigger assignment of entries now to ensure that overlapping\n                    // entries with currently running requests will synchronize state\n                    // with this pending one as they complete\n                    request.getEntries();\n                    Boot.suspendedQueue.push(request);\n                } else {\n                    Boot.currentRequest = request;\n                    Boot.processRequest(request, false);\n                }\n                return Boot;\n            },\n\n            loadSync: function (request) {\n                //<debug>\n//                 _debug(\"Boot.loadSync called\");\n                //</debug>\n                var request = new Request(request);\n\n                Boot.syncMode++;\n                Boot.processRequest(request, true);\n                Boot.syncMode--;\n                return Boot;\n            },\n\n            loadBasePrefix: function(request) {\n                request = new Request(request);\n                request.prependBaseUrl = true;\n                return Boot.load(request);\n            },\n\n            loadSyncBasePrefix: function(request) {\n                request = new Request(request);\n                request.prependBaseUrl = true;\n                return Boot.loadSync(request);\n            },\n\n            requestComplete: function(request) {\n                var next;\n\n                if (Boot.currentRequest === request) {\n                    Boot.currentRequest = null;\n                    while(Boot.suspendedQueue.length > 0) {\n                        next = Boot.suspendedQueue.shift();\n                        if(!next.done) {\n                            //<debug>\n//                             _debug(\"resuming suspended request\");\n                            //</debug>\n                            Boot.load(next);\n                            break;\n                        }\n                    }\n                }\n                if (!Boot.currentRequest && Boot.suspendedQueue.length == 0) {\n                    Boot.fireListeners();\n                }\n            },\n\n            isLoading: function () {\n                return !Boot.currentRequest && Boot.suspendedQueue.length == 0;\n            },\n\n            fireListeners: function () {\n                var listener;\n                while (Boot.isLoading() && (listener = Boot.listeners.shift())) {\n                    listener();\n                }\n            },\n\n            onBootReady: function (listener) {\n                if (!Boot.isLoading()) {\n                    listener();\n                } else {\n                    Boot.listeners.push(listener);\n                }\n            },\n\n            /**\n             * this is a helper function used by Ext.Loader to flush out\n             * 'uses' arrays for classes in some Ext versions\n             */\n            getPathsFromIndexes: function (indexMap, loadOrder) {\n                // In older versions indexMap was an object instead of a sparse array\n                if (!('length' in indexMap)) {\n                    var indexArray = [],\n                        index;\n                    \n                    for (index in indexMap) {\n                        if (!isNaN(+index)) {\n                            indexArray[+index] = indexMap[index];\n                        }\n                    }\n                    \n                    indexMap = indexArray;\n                }\n                \n                return Request.prototype.getPathsFromIndexes(indexMap, loadOrder);\n            },\n\n            createLoadOrderMap: function(loadOrder) {\n                return Request.prototype.createLoadOrderMap(loadOrder);\n            },\n\n            fetch: function(url, complete, scope, async) {\n                async = (async === undefined) ? !!complete : async;\n\n                var xhr = new XMLHttpRequest(),\n                    result, status, content, exception = false,\n                    readyStateChange = function () {\n                        if (xhr && xhr.readyState == 4) {\n                            status = (xhr.status === 1223) ? 204 :\n                                (xhr.status === 0 && ((self.location || {}).protocol === 'file:' ||\n                                    (self.location || {}).protocol === 'ionp:')) ? 200 : xhr.status;\n                            content = xhr.responseText;\n                            result = {\n                                content: content,\n                                status: status,\n                                exception: exception\n                            };\n                            if (complete) {\n                                complete.call(scope, result);\n                            }\n                            xhr.onreadystatechange = emptyFn;\n                            xhr = null;\n                        }\n                    };\n\n                if (async) {\n                    xhr.onreadystatechange = readyStateChange;\n                }\n\n                try {\n                    //<debug>\n//                     _debug(\"fetching \" + url + \" \" + (async ? \"async\" : \"sync\"));\n                    //</debug>\n                    xhr.open('GET', url, async);\n                    xhr.send(null);\n                } catch (err) {\n                    exception = err;\n                    readyStateChange();\n                    return result;\n                }\n\n                if (!async) {\n                    readyStateChange();\n                }\n\n                return result;\n            },\n\n            notifyAll: function(entry) {\n                entry.notifyRequests();\n            }\n        };\n\n    function Request(cfg) {\n         //The request class encapsulates a series of Entry objects\n         //and provides notification around the completion of all Entries\n         //in this request.\n\n        if(cfg.$isRequest) {\n            return cfg;\n        }\n\n        var cfg = cfg.url ? cfg : {url: cfg},\n            url = cfg.url,\n            urls = url.charAt ? [ url ] : url,\n            charset = cfg.charset || Boot.config.charset;\n\n        _apply(this, cfg);\n            \n        delete this.url;\n        this.urls = urls;\n        this.charset = charset;\n    };\n    \n    Request.prototype = {\n        $isRequest: true,\n\n        createLoadOrderMap: function (loadOrder) {\n            var len = loadOrder.length,\n                loadOrderMap = {},\n                i, element;\n\n            for (i = 0; i < len; i++) {\n                element = loadOrder[i];\n                loadOrderMap[element.path] = element;\n            }\n\n            return loadOrderMap;\n        },\n\n        getLoadIndexes: function (item, indexMap, loadOrder, includeUses, skipLoaded) {\n            var resolved = [],\n                queue = [item],\n                itemIndex = item.idx,\n                queue, entry, dependencies, depIndex, i, len;\n            \n            if (indexMap[itemIndex]) {\n                // prevent cycles\n                return resolved;\n            }\n            \n            // Both indexMap and resolved are sparse arrays keyed by indexes.\n            // This gives us a naturally sorted sequence of indexes later on\n            // when we need to convert them to paths.\n            // indexMap is the map of all indexes we have visited at least once\n            // per the current expandUrls() invocation, and resolved is the map\n            // of all dependencies for the current item that are not included\n            // in indexMap.\n            indexMap[itemIndex] = resolved[itemIndex] = true;\n            \n            while (item = queue.shift()) {\n                // Canonicalizing URLs is expensive, we try to avoid it\n                if (item.canonicalPath) {\n                    entry = Boot.getEntry(item.path, null, true);\n                }\n                else {\n                    entry = Boot.getEntry(this.prepareUrl(item.path));\n                }\n                \n                if (!(skipLoaded && entry.done)) {\n                    if (includeUses && item.uses && item.uses.length) {\n                        dependencies = item.requires.concat(item.uses);\n                    }\n                    else {\n                        dependencies = item.requires;\n                    }\n                    \n                    for (i = 0, len = dependencies.length; i < len; i++) {\n                        depIndex = dependencies[i];\n                        \n                        if (!indexMap[depIndex]) {\n                            indexMap[depIndex] = resolved[depIndex] = true;\n                            queue.push(loadOrder[depIndex]);\n                        }\n                    }\n                }\n            }\n            \n            return resolved;\n        },\n\n        getPathsFromIndexes: function (indexes, loadOrder) {\n            var paths = [],\n                index, len;\n            \n            // indexes is a sparse array with values being true for defined indexes\n            for (index = 0, len = indexes.length; index < len; index++) {\n                if (indexes[index]) {\n                    paths.push(loadOrder[index].path);\n                }\n            }\n            \n            return paths;\n        },\n\n        expandUrl: function (url, loadOrder, loadOrderMap, indexMap, includeUses, skipLoaded) {\n            var item, resolved;\n            \n            if (loadOrder) {\n                item = loadOrderMap[url];\n                \n                if (item) {\n                    resolved = this.getLoadIndexes(item, indexMap, loadOrder, includeUses, skipLoaded);\n                    \n                    if (resolved.length) {\n                        return this.getPathsFromIndexes(resolved, loadOrder);\n                    }\n                }\n            }\n            \n            return [url];\n        },\n\n        expandUrls: function (urls, includeUses) {\n            var me = this,\n                loadOrder = me.loadOrder,\n                expanded = [],\n                expandMap = {},\n                indexMap = [],\n                loadOrderMap, tmpExpanded, i, len, t, tlen, tUrl;\n            \n            if (typeof urls === \"string\") {\n                urls = [urls];\n            }\n            \n            if (loadOrder) {\n                loadOrderMap = me.loadOrderMap;\n                \n                if (!loadOrderMap) {\n                    loadOrderMap = me.loadOrderMap = me.createLoadOrderMap(loadOrder);\n                }\n            }\n            \n            for (i = 0, len = urls.length; i < len; i++) {\n                // We don't want to skip loaded entries (last argument === false).\n                // There are some overrides that get loaded before their respective classes,\n                // and when the class dependencies are processed we don't want to skip over\n                // the overrides' dependencies just because they were loaded first.\n                tmpExpanded = this.expandUrl(urls[i], loadOrder, loadOrderMap, indexMap, includeUses, false);\n                \n                for (t = 0, tlen = tmpExpanded.length; t < tlen; t++) {\n                    tUrl = tmpExpanded[t];\n                    \n                    if (!expandMap[tUrl]) {\n                        expandMap[tUrl] = true;\n                        expanded.push(tUrl);\n                    }\n                }\n            }\n            \n            if (expanded.length === 0) {\n                expanded = urls;\n            }\n            \n            return expanded;\n        },\n\n        expandLoadOrder: function () {\n            var me = this,\n                urls = me.urls,\n                expanded;\n\n            if (!me.expanded) {\n                expanded = this.expandUrls(urls, true);\n                me.expanded = true;\n            } else {\n                expanded = urls;\n            }\n\n            me.urls = expanded;\n\n            // if we added some urls to the request to honor the indicated\n            // load order, the request needs to be sequential\n            if (urls.length != expanded.length) {\n                me.sequential = true;\n            }\n\n            return me;\n        },\n\n        getUrls: function () {\n            this.expandLoadOrder();\n            return this.urls;\n        },\n\n        prepareUrl: function(url) {\n            if(this.prependBaseUrl) {\n                return Boot.baseUrl + url;\n            }\n            return url;\n        },\n\n        getEntries: function () {\n            var me = this,\n                entries = me.entries,\n                loadOrderMap, item, i, entry, urls, url;\n            \n            if (!entries) {\n                entries = [];\n                urls = me.getUrls();\n                \n                // If we have loadOrder array then the map will be expanded by now\n                if (me.loadOrder) {\n                    loadOrderMap = me.loadOrderMap;\n                }\n                \n                for (i = 0; i < urls.length; i++) {\n                    url = me.prepareUrl(urls[i]);\n                    \n                    if (loadOrderMap) {\n                        item = loadOrderMap[url];\n                    }\n                    \n                    entry = Boot.getEntry(url, {\n                        buster: me.buster,\n                        charset: me.charset\n                    }, item && item.canonicalPath);\n                    \n                    entry.requests.push(me);\n                    entries.push(entry);\n                }\n                \n                me.entries = entries;\n            }\n            \n            return entries;\n        },\n\n        loadEntries: function(sync) {\n            var me = this,\n                entries = me.getEntries(),\n                len = entries.length,\n                start = me.loadStart || 0,\n                continueLoad, entries, entry, i;\n\n            if(sync !== undefined) {\n                me.sync = sync;\n            }\n\n            me.loaded = me.loaded || 0;\n            me.loading = me.loading || len;\n\n            for(i = start; i < len; i++) {\n                entry = entries[i];\n                if(!entry.loaded) {\n                    continueLoad = entries[i].load(me.sync);\n                } else {\n                    continueLoad = true;\n                }\n                if(!continueLoad) {\n                    me.loadStart = i;\n                    entry.onDone(function(){\n                        me.loadEntries(sync);\n                    });\n                    break;\n                }\n            }\n            me.processLoadedEntries();\n        },\n\n        processLoadedEntries: function () {\n            var me = this,\n                entries = me.getEntries(),\n                len = entries.length,\n                start = me.startIndex || 0,\n                i, entry;\n\n            if (!me.done) {\n                for (i = start; i < len; i++) {\n                    entry = entries[i];\n\n                    if (!entry.loaded) {\n                        me.startIndex = i;\n                        return;\n                    }\n\n                    if (!entry.evaluated) {\n                        entry.evaluate();\n                    }\n\n                    if (entry.error) {\n                        me.error = true;\n                    }\n                }\n                me.notify();\n            }\n        },\n\n        notify: function () {\n            var me = this;\n            if (!me.done) {\n                var error = me.error,\n                    fn = me[error ? 'failure' : 'success'],\n                    delay = ('delay' in me)\n                        ? me.delay\n                        : (error ? 1 : Boot.config.chainDelay),\n                    scope = me.scope || me;\n                me.done = true;\n                if (fn) {\n                    if (delay === 0 || delay > 0) {\n                        // Free the stack (and defer the next script)\n                        setTimeout(function () {\n                            fn.call(scope, me);\n                        }, delay);\n                    } else {\n                        fn.call(scope, me);\n                    }\n                }\n                me.fireListeners();\n                Boot.requestComplete(me);\n            }\n        },\n\n        onDone: function(listener) {\n            var me = this,\n                listeners = me.listeners || (me.listeners = []);\n            if(me.done) {\n                listener(me);\n            } else {\n                listeners.push(listener);\n            }\n        },\n\n        fireListeners: function() {\n            var listeners = this.listeners,\n                listener;\n            if(listeners) {\n                //<debug>\n//                 _debug(\"firing request listeners\");\n                //</debug>\n                while((listener = listeners.shift())) {\n                    listener(this);\n                }\n            }\n        }\n    };\n\n    function Entry(cfg) {\n         //The Entry class is a token to manage the load and evaluation\n         //state of a particular url.  It is used to notify all Requests\n         //interested in this url that the content is available.\n\n        if(cfg.$isEntry) {\n            return cfg;\n        }\n\n        //<debug>\n//         _debug(\"creating entry for \" + cfg.url);\n        //</debug>\n\n        var charset = cfg.charset || Boot.config.charset,\n            manifest = Ext.manifest,\n            loader = manifest && manifest.loader,\n            cache = (cfg.cache !== undefined) ? cfg.cache : (loader && loader.cache),\n            buster, busterParam;\n\n        if (Boot.config.disableCaching) {\n            if (cache === undefined) {\n                cache = !Boot.config.disableCaching;\n            }\n\n            if (cache === false) {\n                buster = +new Date();\n            } else if (cache !== true) {\n                buster = cache;\n            }\n\n            if (buster) {\n                busterParam = (loader && loader.cacheParam) || Boot.config.disableCachingParam;\n                buster = busterParam + \"=\" + buster;\n            }\n        }\n\n        _apply(this, cfg);\n        \n        this.charset = charset;\n        this.buster = buster;\n        this.requests = [];\n    };\n    \n    Entry.prototype = {\n        $isEntry: true,\n        done: false,\n        evaluated: false,\n        loaded: false,\n\n        isCrossDomain: function() {\n            var me = this;\n            if(me.crossDomain === undefined) {\n                //<debug>\n//                 _debug(\"checking \" + me.getLoadUrl() + \" for prefix \" + Boot.origin);\n                //</debug>\n                me.crossDomain = (me.getLoadUrl().indexOf(Boot.origin) !== 0);\n            }\n            return me.crossDomain;\n        },\n\n        isCss: function () {\n            var me = this;\n            if (me.css === undefined) {\n                if (me.url) {\n                    var assetConfig = Boot.assetConfig[me.url];\n                    me.css = assetConfig ? assetConfig.type === \"css\" : cssRe.test(me.url);\n                } else {\n                    me.css = false;\n                }\n            }\n            return this.css;\n        },\n\n        getElement: function (tag) {\n            var me = this,\n                el = me.el;\n            if (!el) {\n                //<debug>\n//                 _debug(\"creating element for \" + me.url);\n                //</debug>\n                if (me.isCss()) {\n                    tag = tag || \"link\";\n                    el = doc.createElement(tag);\n                    if(tag == \"link\") {\n                        el.rel = 'stylesheet';\n                        me.prop = 'href';\n                    } else {\n                        me.prop=\"textContent\";\n                    }\n                    el.type = \"text/css\";\n                } else {\n                    tag = tag || \"script\";\n                    el = doc.createElement(tag);\n                    el.type = 'text/javascript';\n                    me.prop = 'src';\n\n                    if (me.charset) {\n                        el.charset = me.charset;\n                    }\n\n                    if (Boot.hasAsync) {\n                        el.async = false;\n                    }\n                }\n                me.el = el;\n            }\n            return el;\n        },\n\n        getLoadUrl: function () {\n            var me = this,\n                url;\n            \n            url = me.canonicalPath ? me.url : Boot.canonicalUrl(me.url);\n            \n            if (!me.loadUrl) {\n                me.loadUrl = !!me.buster\n                    ? (url + (url.indexOf('?') === -1 ? '?' : '&') + me.buster)\n                    : url;\n            }\n            return me.loadUrl;\n        },\n\n        fetch: function (req) {\n            var url = this.getLoadUrl(),\n                async = !!req.async,\n                complete = req.complete;\n\n            Boot.fetch(url, complete, this, async);\n        },\n\n        onContentLoaded: function (response) {\n            var me = this,\n                status = response.status,\n                content = response.content,\n                exception = response.exception,\n                url = this.getLoadUrl();\n            me.loaded = true;\n            if ((exception || status === 0) && !_environment.phantom) {\n                me.error =\n                    //<debug>\n                    (\"Failed loading synchronously via XHR: '\" + url +\n                        \"'. It's likely that the file is either being loaded from a \" +\n                        \"different domain or from the local file system where cross \" +\n                        \"origin requests are not allowed for security reasons. Try \" +\n                        \"asynchronous loading instead.\") ||\n                    //</debug>\n                    true;\n                me.evaluated = true;\n            }\n            else if ((status >= 200 && status < 300) || status === 304\n                || _environment.phantom\n                || (status === 0 && content.length > 0)\n                ) {\n                me.content = content;\n            }\n            else {\n                me.error =\n                    //<debug>\n                    (\"Failed loading synchronously via XHR: '\" + url +\n                        \"'. Please verify that the file exists. XHR status code: \" +\n                        status) ||\n                    //</debug>\n                    true;\n                me.evaluated = true;\n            }\n        },\n\n        createLoadElement: function(callback) {\n            var me = this,\n                el = me.getElement();\n            \n            me.preserve = true;\n            \n            el.onerror = function() {\n                me.error = true;\n                \n                if (callback) {\n                    callback();\n                    callback = null;\n                }\n            };\n            \n            if (Boot.isIE10m) {\n                el.onreadystatechange = function() {\n                    if (this.readyState === 'loaded' || this.readyState === 'complete') {\n                        if (callback) {\n                            callback();\n                            callback = this.onreadystatechange = this.onerror = null;\n                        }\n                    }\n                };\n            }\n            else {\n                el.onload = function() {\n                    callback();\n                    callback = this.onload = this.onerror = null;\n                };\n            }\n            \n            // IE starts loading here\n            el[me.prop] = me.getLoadUrl();\n        },\n\n        onLoadElementReady: function() {\n            Boot.getHead().appendChild(this.getElement());\n            this.evaluated = true;\n        },\n\n        inject: function (content, asset) {\n            //<debug>\n//             _debug(\"injecting content for \" + this.url);\n            //</debug>\n            var me = this,\n                head = Boot.getHead(),\n                url = me.url,\n                key = me.key,\n                base, el, ieMode, basePath;\n\n            if (me.isCss()) {\n                me.preserve = true;\n                basePath = key.substring(0, key.lastIndexOf(\"/\") + 1);\n                base = doc.createElement('base');\n                base.href = basePath;\n                if(head.firstChild) {\n                    head.insertBefore(base, head.firstChild);\n                } else {\n                    head.appendChild(base);\n                }\n                // reset the href attribute to cuase IE to pick up the change\n                base.href = base.href;\n\n                if (url) {\n                    content += \"\\n/*# sourceURL=\" + key + \" */\";\n                }\n\n                // create element after setting base\n                el = me.getElement(\"style\");\n\n                ieMode = ('styleSheet' in el);\n\n                head.appendChild(base);\n                if(ieMode) {\n                    head.appendChild(el);\n                    el.styleSheet.cssText = content;\n                } else {\n                    el.textContent = content;\n                    head.appendChild(el);\n                }\n                head.removeChild(base);\n\n            } else {\n                // Debugger friendly, file names are still shown even though they're\n                // eval'ed code. Breakpoints work on both Firebug and Chrome's Web\n                // Inspector.\n                if (url) {\n                    content += \"\\n//# sourceURL=\" + key;\n                }\n                Ext.globalEval(content);\n            }\n            return me;\n        },\n\n        loadCrossDomain: function() {\n            var me = this,\n                complete = function(){\n                    me.el.onerror = me.el.onload = emptyFn;\n                    me.el = null;\n                    me.loaded = me.evaluated = me.done = true;\n                    me.notifyRequests();\n                };\n            me.createLoadElement(function(){\n                complete();\n            });\n            me.evaluateLoadElement();\n            // at this point, we need sequential evaluation,\n            // which means we can't advance the load until\n            // this entry has fully completed\n            return false;\n        },\n\n        loadElement: function() {\n            var me = this,\n                complete = function(){\n                    me.el.onerror = me.el.onload = emptyFn;\n                    me.el = null;\n                    me.loaded = me.evaluated = me.done = true;\n                    me.notifyRequests();\n                };\n            me.createLoadElement(function(){\n                complete();\n            });\n            me.evaluateLoadElement();\n            return true;\n        },\n\n        loadSync: function() {\n            var me = this;\n            me.fetch({\n                async: false,\n                complete: function (response) {\n                    me.onContentLoaded(response);\n                }\n            });\n            me.evaluate();\n            me.notifyRequests();\n        },\n\n        load: function (sync) {\n            var me = this;\n            if (!me.loaded) {\n                if(me.loading) {\n                    // if we're calling back through load and we're loading but haven't\n                    // yet loaded, then we should be in a sequential, cross domain\n                    // load scenario which means we can't continue the load on the\n                    // request until this entry has fully evaluated, which will mean\n                    // loaded = evaluated = done = true in one step.  For css files, this\n                    // will happen immediately upon <link> element creation / insertion,\n                    // but <script> elements will set this upon load notification\n                    return false;\n                }\n                me.loading = true;\n\n                // for async modes, we have some options\n                if (!sync) {\n                    // if cross domain, just inject the script tag and let the onload\n                    // events drive the progression.\n                    // IE10 also needs sequential loading because of a bug that makes it\n                    // fire readystate event prematurely:\n                    // https://connect.microsoft.com/IE/feedback/details/729164/ie10-dynamic-script-element-fires-loaded-readystate-prematurely\n                    if (Boot.isIE10 || me.isCrossDomain()) {\n                        return me.loadCrossDomain();\n                    }\n                    // for IE, use the readyStateChange allows us to load scripts in parallel\n                    // but serialize the evaluation by appending the script node to the\n                    // document\n                    else if(!me.isCss() && Boot.hasReadyState) {\n                        me.createLoadElement(function () {\n                            me.loaded = true;\n                            me.notifyRequests();\n                        });\n                    }\n\n                    else if(Boot.useElements &&\n                        // older webkit, phantomjs included, won't fire load for link elements\n                        !(me.isCss() && _environment.phantom)) {\n                        return me.loadElement();\n                    }\n                    // for other browsers, just ajax the content down in parallel, and use\n                    // globalEval to serialize evaluation\n                    else {\n                        me.fetch({\n                            async: !sync,\n                            complete: function (response) {\n                                me.onContentLoaded(response);\n                                me.notifyRequests();\n                            }\n                        });\n                    }\n                }\n\n                // for sync mode in js, global eval FTW.  IE won't honor the comment\n                // paths in the debugger, so eventually we need a sync mode for IE that\n                // uses the readyStateChange mechanism\n                else {\n                    me.loadSync();\n                }\n            }\n            // signal that the load process can continue\n            return true;\n        },\n\n        evaluateContent: function () {\n            this.inject(this.content);\n            this.content = null;\n        },\n\n        evaluateLoadElement: function() {\n            Boot.getHead().appendChild(this.getElement());\n        },\n\n        evaluate: function () {\n            var me = this;\n            if(!me.evaluated) {\n                if(me.evaluating) {\n                    return;\n                }\n                me.evaluating = true;\n                if(me.content !== undefined) {\n                    me.evaluateContent();\n                } else if(!me.error) {\n                    me.evaluateLoadElement();\n                }\n                me.evaluated = me.done = true;\n                me.cleanup();\n            }\n        },\n\n        cleanup: function () {\n            var me = this,\n                el = me.el,\n                prop;\n\n            if (!el) {\n                return;\n            }\n\n            if (!me.preserve) {\n                me.el = null;\n\n                el.parentNode.removeChild(el); // Remove, since its useless now\n\n                for (prop in el) {\n                    try {\n                        if (prop !== me.prop) {\n                            // If we set the src property to null IE\n                            // will try and request a script at './null'\n                            el[prop] = null;\n                        }\n                        delete el[prop];      // and prepare for GC\n                    } catch (cleanEx) {\n                        //ignore\n                    }\n                }\n            }\n\n            // Setting to null can cause exceptions if IE ever needs to call these\n            // again (like onreadystatechange). This emptyFn has nothing locked in\n            // closure scope so it is about as safe as null for memory leaks.\n            el.onload = el.onerror = el.onreadystatechange = emptyFn;\n        },\n\n        notifyRequests: function () {\n            var requests = this.requests,\n                len = requests.length,\n                i, request;\n            for (i = 0; i < len; i++) {\n                request = requests[i];\n                request.processLoadedEntries();\n            }\n            if(this.done) {\n                this.fireListeners();\n            }\n        },\n\n        onDone: function(listener) {\n            var me = this,\n                listeners = me.listeners || (me.listeners = []);\n            if(me.done) {\n                listener(me);\n            } else {\n                listeners.push(listener);\n            }\n        },\n\n        fireListeners: function() {\n            var listeners = this.listeners,\n                listener;\n            if(listeners && listeners.length > 0) {\n                //<debug>\n//                 _debug(\"firing event listeners for url \" + this.url);\n                //</debug>\n                while((listener = listeners.shift())) {\n                    listener(this);\n                }\n            }\n        }\n    };\n\n    /**\n     * Turns on or off the \"cache buster\" applied to dynamically loaded scripts. Normally\n     * dynamically loaded scripts have an extra query parameter appended to avoid stale\n     * cached scripts. This method can be used to disable this mechanism, and is primarily\n     * useful for testing. This is done using a cookie.\n     * @param {Boolean} disable True to disable the cache buster.\n     * @param {String} [path=\"/\"] An optional path to scope the cookie.\n     */\n    Ext.disableCacheBuster = function (disable, path) {\n        var date = new Date();\n        date.setTime(date.getTime() + (disable ? 10 * 365 : -1) * 24 * 60 * 60 * 1000);\n        date = date.toGMTString();\n        doc.cookie = 'ext-cache=1; expires=' + date + '; path=' + (path || '/');\n    };\n\n//<if nonBrowser>\n    if (_environment.node) {\n        Boot.prototype.load = Boot.prototype.loadSync = function (request) {\n            // @TODO\n            require(filePath);\n            onLoad.call(scope);\n        };\n        Boot.prototype.init = emptyFn;\n    }\n//</if>\n\n    Boot.init();\n    return Boot;\n\n// NOTE: We run the eval at global scope to protect the body of the function and allow\n// compressors to still process it.\n}(function () {\n}));//(eval(\"/*@cc_on!@*/!1\"));\n\n/**\n * This method evaluates the given code free of any local variable. This\n * will be at global scope, in others it will be in a function.\n * @param {String} code The code to evaluate.\n * @private\n * @method\n * @member Ext\n */\nExt.globalEval = Ext.globalEval || (this.execScript\n    ? function (code) { execScript(code); }\n    : function ($$code) { eval.call(window, $$code); });\n\n//<feature legacyBrowser>\n/*\n * Only IE8 & IE/Quirks lack Function.prototype.bind so we polyfill that here.\n */\nif (!Function.prototype.bind) {\n    (function () {\n        var slice = Array.prototype.slice,\n        // To reduce overhead on call of the bound fn we have two flavors based on\n        // whether we have args to prepend or not:\n            bind = function (me) {\n                var args = slice.call(arguments, 1),\n                    method = this;\n\n                if (args.length) {\n                    return function () {\n                        var t = arguments;\n                        // avoid the slice/concat if the caller does not supply args\n                        return method.apply(me, t.length ? args.concat(slice.call(t)) : args);\n                    };\n                }\n                // this is the majority use case - just fn.bind(this) and no args\n\n                args = null;\n                return function () {\n                    return method.apply(me, arguments);\n                };\n            };\n        Function.prototype.bind = bind;\n        bind.$extjs = true; // to detect this polyfill if one want to improve it\n    }());\n}\n//</feature>\n\n//</editor-fold>\n\nExt.setResourcePath = function (poolName, path) {\n    var manifest = Ext.manifest || (Ext.manifest = {}),\n        paths = manifest.resources || (manifest.resources = {});\n\n    if (manifest) {\n        if (typeof poolName !== 'string') {\n            Ext.apply(paths, poolName);\n        } else {\n            paths[poolName] = path;\n        }\n        manifest.resources = paths;\n    }\n};\n\nExt.getResourcePath = function (path, poolName, packageName) {\n    if (typeof path !== 'string') {\n        poolName = path.pool;\n        packageName = path.packageName;\n        path = path.path;\n    }\n    var manifest = Ext.manifest,\n        paths = manifest && manifest.resources,\n        poolPath = paths[poolName],\n        output = [];\n\n    if (poolPath == null) {\n        poolPath = paths.path;\n        if (poolPath == null) {\n            poolPath = 'resources';\n        }\n    }\n\n    if (poolPath) {\n        output.push(poolPath);\n    }\n\n    if (packageName) {\n        output.push(packageName);\n    }\n\n    output.push(path);\n    return output.join('/');\n};"
}