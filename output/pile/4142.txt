{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['Because both are just different wrapping for the same thing. (0.198)']."
        }
    ],
    "doc_id": "4142",
    "text": "Q:\n\nIs there a way to return a value with async/await instead of a Promise ? As a synchronous function do\n\nFirstly I am familiar with the concept of asynchronous/synchronous function. \nThere is also a lot of questions related to mine. But I can't find my answer anywhere. \nSo the question is: \n Is there a way to return a value instead of a Promise using async/await ? As a synchronous function do.\nFor example: \nasync doStuff(param) {\n  return await new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('doStuff after a while.');\n      resolve('mystuffisdone'+param);\n    }, 2000);\n  });\n}\n\nconsole.log(doStuff('1'));\n\nThe only way to get the value of this function is by using the .then function.\ndoStuff('1').then(response => {\n  console.log(response); // output: mystuffisdone1\n  doOtherStuffWithMyResponse(response);\n  // ...\n});\n\nNow, what I want is:\nconst one = doStuff('1');\nconsole.log(one) // mystuffisdone1\nconst two = doStuff('2');\nconsole.log(two) // mystuffisdone2\n\nTo explain myself, I have an asynchronous library full of callbacks. I can turn this asynchronous behavior to a synchronous behavior by using Promises and async/await to faking a synchronous behavior.\nBut there is still a problem, it is still asynchronous in the end; outside of the scope of the async function.\ndoStuff('1').then((r) => {console.log(r)};\nconsole.log('Hello wolrd');\n\nIt will result in: Hello world then mystuffisdone1. This is the expected behavior when using async/await functions. But that's not what I want.\nNow my question would be: Is there a way to do the same thing as await do without the keyword async ? To make the code  being synchronous ? And if not possible, why ?\nEdit:\nThank you for all you answers, I think my question is not obsvious for all. To clear up what I think here is my comment to @Nikita Isaev answer.\n\"I understand why all I/O operations are asynchronously done; or done in parallel. But my question is more about the fact that why the engine doesn't block the caller of the sync function in an asynchronous manner ? I mean const a = doStuff(...) is a Promise. We need to call .then to get the result of this function. But why JavaScript or Node engine does not block the caller (just the block where the call is made). If this is possible, we could do const a = doStuff(...), wait and get the result in a without blocking the main thread. As async/await does, why there is no place for sync/wait ?\"\nHope this is more clear now, feel free to comment or ask anything :)\nEdit 2: \nAll precisions of the why of the answer are in the comments of the accepted answer.\n\nA:\n\nNo, going from promise to async/await will not get you from async code to sync code. Why? Because both are just different wrapping for the same thing. Async function returns immediately just like a promise does. \nYou would need to prevent the Event Loop from going to next call. Simple while(!isMyPromiseResolved){} will not work either because it will also block callback from promises so the isMyPromiseResolved flag will never be set.\nBUT... There are ways to achieve what you have described without async/await. For example: \n\nOPTION 1: using deasync approach. Example:\n\nfunction runSync(value) {\n\n    let isDone = false;\n    let result = null;\n\n    runAsync(value)\n    .then(res => {\n        result = res;\n        isDone = true;\n    })\n    .catch(err => {\n        result = err;\n        isDone = true;\n    })\n\n    //magic happens here\n    require('deasync').loopWhile(function(){return !isDone;});\n\n    return result;\n}\n\nrunAsync = (value) => {\n\n    return new Promise((resolve, reject) => {\n\n        setTimeout(() => {\n            // if passed value is 1 then it is a success\n            if(value == 1){\n                resolve('**success**');\n            }else if (value == 2){\n                reject('**error**');\n            }\n        }, 1000);\n\n    });\n\n}\n\nconsole.log('runSync(2): ', runSync(2));\nconsole.log('runSync(1): ', runSync(1));\n\nOR\n\nOPTION 2: calling execFileSync('node yourScript.js') Example:\n\nconst {execFileSync} = require('child_process');\nexecFileSync('node',['yourScript.js']);\n\nBoth approaches will block the user thread so they should be used only for automation scripts or similar purposes.  \n\nA:\n\nThere are some hacky ways to do what is desired, but that would be an anti-pattern. I\u2019ll try to explain. Callbacks is one of the core concepts in javascript. When your code launches, you may set up event listeners, timers, etc. You just tell the engine to schedule some tasks: \u201cwhen A happens, do B\u201d. This is what asynchrony is. But callbacks are ugly and difficult to debug, that\u2019s why promises and async-await were introduced. It is important to understand that this is just a syntax sugar, your code still is asynchronous when using async-await. As there are no threads in javascript, waiting for some events to fire or some complicated operations to finish in a synchronous way would block your entire application. The UI or the server would just stop responding to any other user interactions and would keep waiting for a single event to fire.\nReal world cases:\nExample 1.\nLet\u2019s say we have a web UI. We have a button that downloads the latest information from the server on click. Imagine we do it synchronously. What happens?\nmyButton.onclick = function () {\n  const data = loadSomeDataSync(); // 0\n  useDataSomehow(data);\n}\n\nEverything\u2019s synchronous, the code is flat and we are happy. But the user is not.\nA javascript process can only ever execute a single line of code in a particular moment.  User will not be able to click other buttons, see any animations etc, the app is stuck waiting for loadSomeDataSync() to finish. Even if this lasts 3 seconds, it\u2019s a terrible user experience, you can neither cancel nor see the progress nor do something else.\nExample 2.\nWe have a node.js http server which has over 1 million users. For each user, we need to execute a heavy operation that lasts 5 seconds and return the result. We can do it in a synchronous or asynchronous manner. What happens if we do it in async?\n\nUser 1 connects\nWe start execution of heavy operation for user 1\nUser 2 connects\nWe return data for user 1\nWe start execution of heavy operation for user 2\n\u2026\n\nI.e we do everything in parallel and asap. Now imagine we do the heavy operation in a sync manner.\n\nUser 1 connects\nWe start execution of heavy operation for user 1, everyone else is waiting for it to accomplish\nWe return data for user 1\nUser 2 connects\n\u2026\n\nNow imagine the heavy operation takes 5 seconds to accomplish, and our server is under high load, it has over 1 million users. The last one will have to wait for nearly 5 million seconds, which is definitely not ok.\nThat\u2019s why:\n\nIn browser and server API, most of the i/o operations are asynchronous\nDevelopers strive to make all heavy calculation asynchronous, even React renders in an asynchronous manner.\n\n"
}