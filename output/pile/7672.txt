{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": true,
            "reason": "Text contains Markdown."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['-', '-', '1', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-']."
        }
    ],
    "doc_id": "7672",
    "text": "\nShow HN: Bon \u2013 programming language designed for simplicity, performance, safety - FBMachine\nhttps://github.com/FBMachine/bon\n======\nngcc_hk\nHave a quick look. Quite easy to read. Just not sure does it have an advantage\nover swift which seems quite easy to read, cross 2 platform at least (linux\nand macOS, the windows seems not on equal footing and five code not working),\ntarget llvm.\n\nThe basic features of a new language is hard as you can see the posting what\nexpected. Macro (may not be lisp level but template), memory Managrment,\npurpose (embedded, os, driver and application, ai library, CUDA, mobile app\netc.), library, platform, examples and q&a under stackoverflow etc.\n\n... wonder what is the point of learning a new one.\n\n------\nubertaco\nThis is really neat!\n\nI'm a big fan of Crystal-lang, and I dig the similarity in the sense of \"let's\nstart with Ruby-like syntax, and add more static structure\". I can see the\ndifference here as being that Bon appears to _behave_ more like Haskell or\nOCaml rather than like Ruby, which means that there's still a good niche here.\n\nI hope this neat language finds success!\n\n~~~\nFBMachine\nThanks, I really appreciate it!\n\n------\nchrislopez\nHow is memory managed? I'm assuming some form of garbage collection. So this\ncan be used in any instance C or C++ can? Can it use C and C++ libraries\nbecause it runs on clang?\n\nSorry if these are n00b questions. Bon seems like it could be a nice mix of\nthe wonderful syntax of a python or ruby, and the speed of a C or C++ (or at\nleast a compiled language)\n\n~~~\nFBMachine\nHi Chris, thanks for checking it out. The first code push for Bon was today,\nso many things are of course rough around the edges.\n\nMemory will be garbage collected, though I am aiming for zero-cost as much as\npossible. At the moment it just leaks memory like a sieve as I work out the\nsemantics.\n\nYou can indeed import standard c library calls by using a cdef. You can find\nexamples in the stdlib, e.g.:\n\ncdef sqrt(x:float) -> float\n\nThanks again for taking a look!\n\n~~~\nbendmorris\nWhat is \"zero-cost\" garbage collection?\n\n~~~\nswiftcoder\nI've seen both Rust's lifetimes/borrow-checker and Objective-C/Swift's\nautomatic reference counting described as \"zero cost\" (since the bulk of the\nwork is done at compile time).\n\n~~~\nm0th87\nRust's borrow checker is zero-cost because it's not doing runtime analysis.\nBut it's not a garbage collector, unless you're using Steve Klabnik's \"static\ngarbage collector\" terminology [1]. Reference counting is definitely not zero\ncost. It reduces GC runtime latency for most workloads, but not to zero, and\nit does so at the cost of reduced bandwidth.\n\n1: [https://words.steveklabnik.com/borrow-checking-escape-\nanalys...](https://words.steveklabnik.com/borrow-checking-escape-analysis-and-\nthe-generational-hypothesis)\n\n------\nCJefferson\nSimplicity, performance and safety? That's everything!\n\nWhat's it bad at?\n\n~~~\northoxerox\nHaving an stdlib, having a dependency manager and overall stability.\n\n~~~\ngiancarlostoro\nYeah Rust and Go (and D) all have: decent standard libraries (Go exceeds the\nother two, somewhat resembling Python), a package manager of sorts (Go needsa\nimprove in this aspect, but the strong standard library makes up for it for\nnow, and they are working on it atm), and they're all usually stable.\n\nI think the biggest game changers for any new language is a highly competitive\nstandard library out of the box: web server of sorts that can somewhat scale\nout of the box is usually a must, but at least a simple enough one is ok too,\nfile IO, crypto, etc are also useful, the less code I have to write the more\nproductive I feel.\n\nPackage management is a must too, even if primitive at first (Go's approach is\nclean and decentralized to some degree, I love that).\n\n------\ncharlesetc\nIt seems a bit premature to claim high performance without having a story for\nmemory. I'm sure ocaml, swift, and basically all languages that do any type of\nruntime garbage collection would be significantly faster without it.\n\n~~~\nbunderbunder\nIt's complicated. The best runtime GC nowadays tends to take on some of the\nperformance characteristics of a stack, including that finding a new memory\nslot is O(1). Heap allocation in many non-GC languages, by contrast, ends up\ninvolving some sort of relatively gross search for free memory. The same\nmechanisms also mean that, if you aren't doing anything in particular to\nmanage your memory layout, the GC language is likely to achieve better\nlocality of reference at run time.\n\nThis isn't to say that better performance isn't achievable in languages with\nmanual memory management, but doing so often requires a special effort that\njust isn't going to happen most the time, for reasons of practicality.\n\nThat said, there are certain classes of program where the story is different:\n[https://en.wikipedia.org/wiki/The_Computer_Language_Benchmar...](https://en.wikipedia.org/wiki/The_Computer_Language_Benchmarks_Game#Benchmark_programs)\n\n~~~\nzokier\nI think the point was that you can make memory allocation _very fast_ if you\ndo not care about ever freeing memory, but obviously that is not exactly\nsustainable strategy. So that is why making claims about performance before\nfiguring out memory management story is bit premature.\n\n------\nQ6T46nT668w6i3m\nIs this an extension of Kaleidoscope (the language implemented in the LLVM\ntutorial)?\n\n~~~\nFBMachine\nI wouldn't call it an extension, but I did use the tutorial to quickly\nprototype from. There are still some remnants left in the code, but I don't\nexpect much if any to be left in the near future.\n\n------\nzestyping\nI'm curious about scoping. How come `main` in the typeclass.bon example gets\nto call `norm()` unqualified? Do all the functions in all `impl` definitions\njust get tossed in one global namespace? If `Norm` is a class, then why are\nthere no `Norm` objects?\n\n~~~\nperfunctory\nThis seems to be straight from Haskell. `class` here doesn't mean what it\nmeans in oop languages.\n\n~~~\nFBMachine\nYeah, 'class' in Bon defines a typeclass. While I plan on adding x.norm() as\nsyntactic sugar for norm(x), typeclasses in general are a bit more flexible.\nFor example, while you can use it for polymorphic operator overloading [0],\nyou can also overload a function by changing the types of multiple parameters\n[1] (as in multiple dispatch).\n\n[0]\n[https://github.com/FBMachine/bon/blob/master/examples/equali...](https://github.com/FBMachine/bon/blob/master/examples/equality.bon)\n\n[1]\n[https://github.com/FBMachine/bon/blob/master/examples/multip...](https://github.com/FBMachine/bon/blob/master/examples/multiple_dispatch.bon)\n\n~~~\nbausshf\nYou should look into UFCS from dlang, maybe that can give you some\ninspiration.\n\n[https://dlang.org/spec/function.html#pseudo-\nmember](https://dlang.org/spec/function.html#pseudo-member)\n\n------\nFBMachine\nFor those who had questions about how memory is to be managed, the\ndocumentation for that work is being tracked here:\n\n[https://github.com/FBMachine/bon/blob/auto_mem/docs/ch02-01-...](https://github.com/FBMachine/bon/blob/auto_mem/docs/ch02-01-memory.md)\n\nThanks for all of the feedback!\n\n------\nRivieraKid\nI would love if there was a language combining the strengths of Julia and\nSwift.\n\nSwift has: much nicer handling of optional values, static typing, better for\nOOP, function calls via dot notation, zero-based indexing.\n\nJulia has: better ecosystem for scientific computing, the standard library\nmakes lot of things easier, better REPL, working with arrays is easier.\n\n(Just from the top of my head, there are other things.)\n\n------\ntropo\nThis is a terrible name conflict.\n\nBon, along with New B, was an immediate ancestor to C. The history gets more\nconfusing with another Bon showing up half a century later.\n\nBon was created for Multics by Ken Thompson. His wife Bonnie, like this other\nperson's mother, was the inspiration for the name.\n\nKen Thompson has naming priority.\n\n~~~\nchrislopez\nKen Thompson is a person, plain and simple. He is not a god. Naming priority\ndoesn't matter when most programmers haven't heard of old Bon. No one is going\nto think that new Bon is old Bon if no one knows about old Bon. Maybe there\nwill confusion looking at the history if new Bon takes off, but when is there\nnot in computer science? A simple footnote could suffice to avoid confusion.\n\n------\nrurban\nI esp. like the multiple dispatch and the unifying typesystem. I'll definitely\nsteal something from it\n\n------\nIshKebab\nLooks nicely designed, but are lists really implemented as linked lists?\nThat's surely going to be very slow.\n\n~~~\nFBMachine\nThanks for checking it out. They are currently implemented similarly to OCaml,\nso yes they are linked lists.\n\nThis was purely for simplicity (they can be implemented in a couple of lines\nof code with algebraic data types). Simplicity of implementation is certainly\nnot my priority, just a short term drive, so it will be revisited in the near\nfuture.\n\nThanks!\n\n------\nchrislopez\nLooks interesting! I'll give it a spin.\n\n"
}