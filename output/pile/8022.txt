{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['Finally, I want to formulate a summary of the relevant keywords and their most common use: (0.180)', 'Can save some memory resources, but only if the method is not reimplemented in all descendant classes and there are many objects created from such classes. (0.199)', 'You can look up for examples on that. (0.199)']."
        }
    ],
    "doc_id": "8022",
    "text": "Q:\n\nTThread and inheritance\n\nI am having a hard time implementing multi-tier inheritance from the basic TThread class.\nBased on my knowledge of OOP it should be possible but maybe it just can't be applied to threads.\nMy goal is to use TMyBaseThread to implement all the code that will be common to descendent classes. This is what I have have tried:  \nTMyBaseThread = class(TThread)\nprivate\n    procedure BuildBaseObjects(aParam : TParam);\n    procedure Execute; virtual; abstract;\nprotected\n    constructor Create(Param : TParam); reintroduce; virtual;\nend;\n\nTMyFileThread = class(TMyBaseThread)\nprivate\n    procedure Execute; reintroduce;\npublic\n    constructor Create(OtherParam : TOtherParam); reintroduce; overload;\nend;\n\nTMyDBThread = class(TMyBaseThread)\nprivate\n    procedure Execute; reintroduce;\npublic\n    constructor Create(aDB : TDatabase); reintroduce; overload;\nend;\n\nimplementation\n\nconstructor TMyBaseThread.Create(Param : TParam);\nbegin\n    inherited Create(False);\n    Self.BuildBaseObjects(Param);\n    [do some stuff]\nend;\n\nconstructor TMyFileThread.Create(OtherParam : TOtherParam);\nvar\n    param : TParam;\nbegin\n    inherited Create(param);\n    [do some other stuff]\nend;\n\nprocedure TMyFileThread.Execute;\nbegin\n    while not Terminated do\n        doWork(); <-- this is never called\nend;\n\nconstructor TMyDBThread.Create(aDB : TDatabase);\nvar\n    param : TParam;\nbegin\n    inherited Create(param);\nend;\n\nprocedure TMyDBThread.Execute;\nbegin\n    while not Terminated do\n        doDatabaseWork(); <-- this is never called\nend;\n\nI see in TThread's implementation that the Executed method is called automatically in the AfterConstruction but how can I have it point to the one declared in the derived classes?  \nThanks!\n\nA:\n\nFirst, I can't support more Craig's comment about using composition instead of inheritance for implementing the common functionality.\nAnd although the architecture choice is under question, there is a lot to learn from your example.\nBefore inheriting a class, you should investigate the interface of the parent class that you want to inherit. To do that you can either look for the class definition in the interface section of the source code or look up the relevant documentation - System.Classes.TThread.\nIt seems you have already read the documentation, so let's take a look at an except from the class definition of TThread:\nTThread = class\n  private\n    ...\n  protected\n    procedure CheckThreadError(ErrCode: Integer); overload;\n    procedure CheckThreadError(Success: Boolean); overload;\n    procedure DoTerminate; virtual;\n    procedure Execute; virtual; abstract;\n    procedure Queue(AMethod: TThreadMethod); overload;\n    procedure Synchronize(AMethod: TThreadMethod); overload;\n    property ReturnValue: Integer read FReturnValue write FReturnValue;\n    property Terminated: Boolean read FTerminated;\n  public\n    constructor Create(CreateSuspended: Boolean);\n    destructor Destroy; override;\n    procedure AfterConstruction; override;\n    procedure Resume;\n    procedure Suspend;\n    procedure Terminate;\n    function WaitFor: LongWord;\n    class procedure Queue(AThread: TThread; AMethod: TThreadMethod); overload;\n    class procedure RemoveQueuedEvents(AThread: TThread; AMethod: TThreadMethod);\n    class procedure StaticQueue(AThread: TThread; AMethod: TThreadMethod);\n    class procedure Synchronize(AThread: TThread; AMethod: TThreadMethod); overload;\n    class procedure StaticSynchronize(AThread: TThread; AMethod: TThreadMethod);\n    property FatalException: TObject read FFatalException;\n    property FreeOnTerminate: Boolean read FFreeOnTerminate write FFreeOnTerminate;\n    property Handle: THandle read FHandle;\n    property Priority: TThreadPriority read GetPriority write SetPriority;\n    property Suspended: Boolean read FSuspended write SetSuspended;\n    property ThreadID: THandle read FThreadID;\n    property OnTerminate: TNotifyEvent read FOnTerminate write FOnTerminate;\n  end;\n\nFirst, ignore anything that is in the private section of the class. If those fields and methods were marked as private, we are not supposed to be able to use them at all in descendant classes.\nThen, look for any abstract methods. The implementation of abstract methods is left for descendant classes. So those are the methods you are expected to implement in your code. Abstract methods are usually called indirectly by using one of the methods from the parent class.\nIn your case the TThread class has only one abstract method:\nprocedure Execute; virtual; abstract;\n\nThe documentation says that you need to \n\nDefine the thread object's Execute method by inserting the code that\n  should execute when the thread is executed.\n\nIt's true that the documentation sounds a bit vague, but the right way to do that is to \"override\" the method in the interface, and not to \"reintroduce\" it:\n  TMyFileThread = class(TMyBaseThread)\n  ...\n  protected\n      procedure Execute; override;\n  ...\n\nand then implement it in the implementation:\nprocedure TMyFileThread.Execute;\nbegin\n    while not Terminated do\n      Sleep(1); // do some other stuff\nend;\n\nYou probably notice how we declared the overrided definition of Execute method in the protected section. This is required as the definition of the method in the parent class is also in the protected section, so we can only override it in a section with higher visibility (protected or public).\nYou rarely need to increase the visibility when overriding a method, so we just keep the same visibility.\nWe used the override keyword to tell the base class to use this variant of the method instead of its own. If you miss the override keyword the Execute method will not be called at all, and the base class will try calling it's own Execute method, if there is any.\nAnother thing to note is that you don't need to redeclare the Execute method in your base class as you are not implementing it there. That's why you should remove the following definition:\nTMyBaseThread = class(TThread)\n...\n    //procedure Execute; virtual; abstract;  <- remove this\n...\n\nThe execute method is already defined in the TThread class.\nNow, let's look at the constructors. The base class has a regular constructor that is neither virtual, nor dynamic:\n  public\n    constructor Create(CreateSuspended: Boolean);\n\nThis means you cannot override those constructors and if you want to add additional logic on object creation, you should create your own constructors that wrap those.\nThe proper way to do that is to just declare a constructor with a different set of parameters, without reintroducing, overloading or overriding the base one:\npublic\n      //constructor Create(Param : TParam); reintroduce; virtual;\n      constructor Create(Param : TParam);\n\nAlso, remember that constructors should almost always be in the public section.\nYou also don't need to make the constructor virtual. You could do that if your TMyFileThread and TMyDBThread classes needed to add some logic inside the constructor, without changing the constructor parameters.\nWhen you change the set of parameters all that is required is that you call the inherited constructor as first thing inside the new one:\nconstructor TMyFileThread.Create(OtherParam : TOtherParam);\nvar\n    param : TParam;\nbegin\n    inherited Create(param); // It is enough to call the base constructor at the top\n    // do some other stuff\nend;\n\nThe definition requires no keywords:\n  TMyFileThread = class(TMyBaseThread)\n  ...\n  public\n      constructor Create(OtherParam : TOtherParam);\n\nDid you notice how we used inherited Create(param) to call the base constructor, but we did not use inherited Execute;? That's because the Execute method was marked as abstract and have no default implementation in the base class. Using inherited on an abstract method would cause an exception as there is no default method to call.\nAs a general rule calling inherited Create is a must if the base constructor you are calling is marked as virtual, but is almost always required even if it is not marked so.\nFinally, I want to formulate a summary of the relevant keywords and their most common use:\n\nvirtual - declare a method that can be reimplemented in descendant classes. That is descendant classes can change the behaviour of the method. They can replace all the code inside it with their own, or can both call the base method and then add additional behaviour before/after that. This keyword is used only in the base class that defines the method for the first time. Descendant classes use the other keywords.\ndynamic - consider it the same as virtual. Can save some memory resources, but only if the method is not reimplemented in all descendant classes and there are many objects created from such classes. Rarely used.\noverride - declare a method that reimplements the base class by providing code that replaces the default one in the base class. You use override in descendant classes. You can use the inherited keyword inside your implementation to call the base method.\noverload - You declare an alternative variant of the method with another set of parameters. Note that overloading a method has nothing to do with inheritance. An overloaded version of the method is not executed when the base class is calling the original method. Usually overloaded methods normalize the parameters (converting them to other types, adding default values for some parameters) and then call one of the other overloaded methods. Again, this has nothing to do with inheritance and the virtual, override keywords. Although sometimes you can combine both effects.\nreintroduce - This again is not inheritance. You use this keyword in descendant classes. The purpose is to make calls to the method from inside your class (and only calls from your class, not calls from the base class) to execute that reintroduced version of the method instead of the base one. Calls from the base class still execute the original version. Rarely used.\n\nHaving said that, here is my interpretation of your code:\ninterface\n\nuses\n  Classes, SysUtils;\n\ntype\n  TParam = class\n  end;\n\n  TOtherParam = class\n  end;\n\n  TDatabase = class\n  end;\n\n  TMyBaseThread = class(TThread)\n  private\n      procedure BuildBaseObjects(aParam : TParam);\n  protected\n  public\n      constructor Create(Param : TParam);\n  end;\n\n  TMyFileThread = class(TMyBaseThread)\n  private\n  protected\n      procedure Execute; override;\n  public\n      constructor Create(OtherParam : TOtherParam);\n  end;\n\n  TMyDBThread = class(TMyBaseThread)\n  private\n  protected\n      procedure Execute; override;\n  public\n      constructor Create(aDB : TDatabase);\n  end;\n\nimplementation\n\n{ TMyBaseThread }\n\nconstructor TMyBaseThread.Create(Param : TParam);\nbegin\n    inherited Create(False);\n    Self.BuildBaseObjects(Param);\n    // Do some stuff\nend;\n\nprocedure TMyBaseThread.BuildBaseObjects(aParam : TParam);\nbegin\n    // Do some stuff\nend;\n\n{ TMyFileThread }\n\nconstructor TMyFileThread.Create(OtherParam : TOtherParam);\nvar\n    param : TParam;\nbegin\n    inherited Create(param); // Remember to initialize param somehow\n    // Do some other stuff\nend;\n\nprocedure TMyFileThread.Execute;\nbegin\n    while not Terminated do\n      Sleep(1);\nend;\n\n{ TMyDBThread }\n\nconstructor TMyDBThread.Create(aDB : TDatabase);\nvar\n    param : TParam;\nbegin\n    inherited Create(param); // Remember to initialize param somehow\nend;\n\nprocedure TMyDBThread.Execute;\nbegin\n    while not Terminated do\n        Sleep(1);\nend;\n\nPS. Actually using inheritance on TThread is mostly useful for plugin architectures or task workers. You can look up for examples on that.\n\n"
}