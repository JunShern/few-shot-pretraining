{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['For those applications that require such behavior, it is possible to simulate the two separate steps with the facilities that are currently provided. (0.163)']."
        }
    ],
    "doc_id": "9588",
    "text": "Q:\n\nDoes pthread_create start the created thread?\n\nDoes the function \"pthread_create\" start the thread (starts executing its function), or does it just creates it and make it wait for the right moment to start?\n\nA:\n\npthread_create creates the thread (by using clone syscall internally), and return the tid (thread id, like pid). So, at the time when pthread_create returns, the new thread is at least created. But there are no guaranties when it will be started.\nFrom the Man:\nhttp://man7.org/linux/man-pages/man3/pthread_create.3.html\n\nUnless real-time scheduling policies\n   are being employed, after a call to pthread_create(), it is\n   indeterminate which thread\u2014the caller or the new thread\u2014will next\n   execute.\n\nPOSIX has the similar comment in the informative description of pthread_create http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_create.html\n\nThere is no requirement on the implementation that the ID of the created thread be available before the newly created thread starts executing. \n\nThere is also long \"Rationale\" why pthread_create is single step process without separate thread creation and start_execution (as it was in good old Java epoch): \n\nA suggested alternative to pthread_create() would be to define two separate operations: create and start. Some applications would find such behavior more natural. Ada, in particular, separates the \"creation\" of a task from its \"activation\".\nSplitting the operation was rejected by the standard developers for many reasons:\n\nThe number of calls required to start a thread would increase from one to two and thus place an additional burden on applications that do not require the additional synchronization. The second call, however, could be avoided by the additional complication of a start-up state attribute.\nAn extra state would be introduced: \"created but not started\". This would require the standard to specify the behavior of the thread operations when the target has not yet started executing.\nFor those applications that require such behavior, it is possible to simulate the two separate steps with the facilities that are currently provided. The start_routine() can synchronize by waiting on a condition variable that is signaled by the start operation.\n\nYou may use RT scheduling; or just add some synchronization in the created thread to get exact information about it's execution. It can be also useful in some cases to manually bind the thread to specific CPU core using pthread_setaffinity_np\n\nA:\n\nIt creates the thread and enters the ready queue. When it gets its slice from the scheduler, it starts to run. \nHow early it gets to run will depend upon thread's priority, no of threads it is competing against among other factors.\n\n"
}