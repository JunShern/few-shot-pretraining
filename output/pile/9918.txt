{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": true,
            "reason": "Text contains GRE."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 3 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['These may be more convenient in some places. (0.181)']."
        }
    ],
    "doc_id": "9918",
    "text": "/*\n * jpeglib.h\n *\n * Copyright (C) 1991-1998, Thomas G. Lane.\n * Modified 2002-2012 by Guido Vollbeding.\n * This file is part of the Independent JPEG Group's software.\n * For conditions of distribution and use, see the accompanying README file.\n *\n * This file defines the application interface for the JPEG library.\n * Most applications using the library need only include this file,\n * and perhaps jerror.h if they want to know the exact error codes.\n */\n\n#ifndef JPEGLIB_H\n#define JPEGLIB_H\n\n/*\n * First we include the configuration files that record how this\n * installation of the JPEG library is set up.  jconfig.h can be\n * generated automatically for many systems.  jmorecfg.h contains\n * manual configuration options that most people need not worry about.\n */\n\n#ifndef JCONFIG_INCLUDED\t/* in case jinclude.h already did */\n#include \"jconfig.h\"\t\t/* widely used configuration options */\n#endif\n#include \"jmorecfg.h\"\t\t/* seldom changed options */\n\n\n#ifdef __cplusplus\n#ifndef DONT_USE_EXTERN_C\nextern \"C\" {\n#endif\n#endif\n\n/* Version IDs for the JPEG library.\n * Might be useful for tests like \"#if JPEG_LIB_VERSION >= 90\".\n */\n\n#define JPEG_LIB_VERSION        90\t/* Compatibility version 9.0 */\n#define JPEG_LIB_VERSION_MAJOR  9\n#define JPEG_LIB_VERSION_MINOR  0\n\n\n/* Various constants determining the sizes of things.\n * All of these are specified by the JPEG standard, so don't change them\n * if you want to be compatible.\n */\n\n#define DCTSIZE\t\t    8\t/* The basic DCT block is 8x8 coefficients */\n#define DCTSIZE2\t    64\t/* DCTSIZE squared; # of elements in a block */\n#define NUM_QUANT_TBLS      4\t/* Quantization tables are numbered 0..3 */\n#define NUM_HUFF_TBLS       4\t/* Huffman tables are numbered 0..3 */\n#define NUM_ARITH_TBLS      16\t/* Arith-coding tables are numbered 0..15 */\n#define MAX_COMPS_IN_SCAN   4\t/* JPEG limit on # of components in one scan */\n#define MAX_SAMP_FACTOR     4\t/* JPEG limit on sampling factors */\n/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;\n * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.\n * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU\n * to handle it.  We even let you do this from the jconfig.h file.  However,\n * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe\n * sometimes emits noncompliant files doesn't mean you should too.\n */\n#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */\n#ifndef D_MAX_BLOCKS_IN_MCU\n#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */\n#endif\n\n\n/* Data structures for images (arrays of samples and of DCT coefficients).\n * On 80x86 machines, the image arrays are too big for near pointers,\n * but the pointer arrays can fit in near memory.\n */\n\ntypedef JSAMPLE FAR *JSAMPROW;\t/* ptr to one image row of pixel samples. */\ntypedef JSAMPROW *JSAMPARRAY;\t/* ptr to some rows (a 2-D sample array) */\ntypedef JSAMPARRAY *JSAMPIMAGE;\t/* a 3-D sample array: top index is color */\n\ntypedef JCOEF JBLOCK[DCTSIZE2];\t/* one block of coefficients */\ntypedef JBLOCK FAR *JBLOCKROW;\t/* pointer to one row of coefficient blocks */\ntypedef JBLOCKROW *JBLOCKARRAY;\t\t/* a 2-D array of coefficient blocks */\ntypedef JBLOCKARRAY *JBLOCKIMAGE;\t/* a 3-D array of coefficient blocks */\n\ntypedef JCOEF FAR *JCOEFPTR;\t/* useful in a couple of places */\n\n\n/* Types for JPEG compression parameters and working tables. */\n\n\n/* DCT coefficient quantization tables. */\n\ntypedef struct {\n  /* This array gives the coefficient quantizers in natural array order\n   * (not the zigzag order in which they are stored in a JPEG DQT marker).\n   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.\n   */\n  UINT16 quantval[DCTSIZE2];\t/* quantization step for each coefficient */\n  /* This field is used only during compression.  It's initialized FALSE when\n   * the table is created, and set TRUE when it's been output to the file.\n   * You could suppress output of a table by setting this to TRUE.\n   * (See jpeg_suppress_tables for an example.)\n   */\n  boolean sent_table;\t\t/* TRUE when table has been output */\n} JQUANT_TBL;\n\n\n/* Huffman coding tables. */\n\ntypedef struct {\n  /* These two fields directly represent the contents of a JPEG DHT marker */\n  UINT8 bits[17];\t\t/* bits[k] = # of symbols with codes of */\n\t\t\t\t/* length k bits; bits[0] is unused */\n  UINT8 huffval[256];\t\t/* The symbols, in order of incr code length */\n  /* This field is used only during compression.  It's initialized FALSE when\n   * the table is created, and set TRUE when it's been output to the file.\n   * You could suppress output of a table by setting this to TRUE.\n   * (See jpeg_suppress_tables for an example.)\n   */\n  boolean sent_table;\t\t/* TRUE when table has been output */\n} JHUFF_TBL;\n\n\n/* Basic info about one component (color channel). */\n\ntypedef struct {\n  /* These values are fixed over the whole image. */\n  /* For compression, they must be supplied by parameter setup; */\n  /* for decompression, they are read from the SOF marker. */\n  int component_id;\t\t/* identifier for this component (0..255) */\n  int component_index;\t\t/* its index in SOF or cinfo->comp_info[] */\n  int h_samp_factor;\t\t/* horizontal sampling factor (1..4) */\n  int v_samp_factor;\t\t/* vertical sampling factor (1..4) */\n  int quant_tbl_no;\t\t/* quantization table selector (0..3) */\n  /* These values may vary between scans. */\n  /* For compression, they must be supplied by parameter setup; */\n  /* for decompression, they are read from the SOS marker. */\n  /* The decompressor output side may not use these variables. */\n  int dc_tbl_no;\t\t/* DC entropy table selector (0..3) */\n  int ac_tbl_no;\t\t/* AC entropy table selector (0..3) */\n  \n  /* Remaining fields should be treated as private by applications. */\n  \n  /* These values are computed during compression or decompression startup: */\n  /* Component's size in DCT blocks.\n   * Any dummy blocks added to complete an MCU are not counted; therefore\n   * these values do not depend on whether a scan is interleaved or not.\n   */\n  JDIMENSION width_in_blocks;\n  JDIMENSION height_in_blocks;\n  /* Size of a DCT block in samples,\n   * reflecting any scaling we choose to apply during the DCT step.\n   * Values from 1 to 16 are supported.\n   * Note that different components may receive different DCT scalings.\n   */\n  int DCT_h_scaled_size;\n  int DCT_v_scaled_size;\n  /* The downsampled dimensions are the component's actual, unpadded number\n   * of samples at the main buffer (preprocessing/compression interface);\n   * DCT scaling is included, so\n   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_h_scaled_size/DCTSIZE)\n   * and similarly for height.\n   */\n  JDIMENSION downsampled_width;\t /* actual width in samples */\n  JDIMENSION downsampled_height; /* actual height in samples */\n  /* This flag is used only for decompression.  In cases where some of the\n   * components will be ignored (eg grayscale output from YCbCr image),\n   * we can skip most computations for the unused components.\n   */\n  boolean component_needed;\t/* do we need the value of this component? */\n\n  /* These values are computed before starting a scan of the component. */\n  /* The decompressor output side may not use these variables. */\n  int MCU_width;\t\t/* number of blocks per MCU, horizontally */\n  int MCU_height;\t\t/* number of blocks per MCU, vertically */\n  int MCU_blocks;\t\t/* MCU_width * MCU_height */\n  int MCU_sample_width;\t/* MCU width in samples: MCU_width * DCT_h_scaled_size */\n  int last_col_width;\t\t/* # of non-dummy blocks across in last MCU */\n  int last_row_height;\t\t/* # of non-dummy blocks down in last MCU */\n\n  /* Saved quantization table for component; NULL if none yet saved.\n   * See jdinput.c comments about the need for this information.\n   * This field is currently used only for decompression.\n   */\n  JQUANT_TBL * quant_table;\n\n  /* Private per-component storage for DCT or IDCT subsystem. */\n  void * dct_table;\n} jpeg_component_info;\n\n\n/* The script for encoding a multiple-scan file is an array of these: */\n\ntypedef struct {\n  int comps_in_scan;\t\t/* number of components encoded in this scan */\n  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */\n  int Ss, Se;\t\t\t/* progressive JPEG spectral selection parms */\n  int Ah, Al;\t\t\t/* progressive JPEG successive approx. parms */\n} jpeg_scan_info;\n\n/* The decompressor can save APPn and COM markers in a list of these: */\n\ntypedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;\n\nstruct jpeg_marker_struct {\n  jpeg_saved_marker_ptr next;\t/* next in list, or NULL */\n  UINT8 marker;\t\t\t/* marker code: JPEG_COM, or JPEG_APP0+n */\n  unsigned int original_length;\t/* # bytes of data in the file */\n  unsigned int data_length;\t/* # bytes of data saved at data[] */\n  JOCTET FAR * data;\t\t/* the data contained in the marker */\n  /* the marker length word is not counted in data_length or original_length */\n};\n\n/* Known color spaces. */\n\ntypedef enum {\n\tJCS_UNKNOWN,\t\t/* error/unspecified */\n\tJCS_GRAYSCALE,\t\t/* monochrome */\n\tJCS_RGB,\t\t/* red/green/blue */\n\tJCS_YCbCr,\t\t/* Y/Cb/Cr (also known as YUV) */\n\tJCS_CMYK,\t\t/* C/M/Y/K */\n\tJCS_YCCK\t\t/* Y/Cb/Cr/K */\n} J_COLOR_SPACE;\n\n/* Supported color transforms. */\n\ntypedef enum {\n\tJCT_NONE           = 0,\n\tJCT_SUBTRACT_GREEN = 1\n} J_COLOR_TRANSFORM;\n\n/* DCT/IDCT algorithm options. */\n\ntypedef enum {\n\tJDCT_ISLOW,\t\t/* slow but accurate integer algorithm */\n\tJDCT_IFAST,\t\t/* faster, less accurate integer method */\n\tJDCT_FLOAT\t\t/* floating-point: accurate, fast on fast HW */\n} J_DCT_METHOD;\n\n#ifndef JDCT_DEFAULT\t\t/* may be overridden in jconfig.h */\n#define JDCT_DEFAULT  JDCT_ISLOW\n#endif\n#ifndef JDCT_FASTEST\t\t/* may be overridden in jconfig.h */\n#define JDCT_FASTEST  JDCT_IFAST\n#endif\n\n/* Dithering options for decompression. */\n\ntypedef enum {\n\tJDITHER_NONE,\t\t/* no dithering */\n\tJDITHER_ORDERED,\t/* simple ordered dither */\n\tJDITHER_FS\t\t/* Floyd-Steinberg error diffusion dither */\n} J_DITHER_MODE;\n\n\n/* Common fields between JPEG compression and decompression master structs. */\n\n#define jpeg_common_fields \\\n  struct jpeg_error_mgr * err;\t/* Error handler module */\\\n  struct jpeg_memory_mgr * mem;\t/* Memory manager module */\\\n  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\\\n  void * client_data;\t\t/* Available for use by application */\\\n  boolean is_decompressor;\t/* So common code can tell which is which */\\\n  int global_state\t\t/* For checking call sequence validity */\n\n/* Routines that are to be used by both halves of the library are declared\n * to receive a pointer to this structure.  There are no actual instances of\n * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.\n */\nstruct jpeg_common_struct {\n  jpeg_common_fields;\t\t/* Fields common to both master struct types */\n  /* Additional fields follow in an actual jpeg_compress_struct or\n   * jpeg_decompress_struct.  All three structs must agree on these\n   * initial fields!  (This would be a lot cleaner in C++.)\n   */\n};\n\ntypedef struct jpeg_common_struct * j_common_ptr;\ntypedef struct jpeg_compress_struct * j_compress_ptr;\ntypedef struct jpeg_decompress_struct * j_decompress_ptr;\n\n\n/* Master record for a compression instance */\n\nstruct jpeg_compress_struct {\n  jpeg_common_fields;\t\t/* Fields shared with jpeg_decompress_struct */\n\n  /* Destination for compressed data */\n  struct jpeg_destination_mgr * dest;\n\n  /* Description of source image --- these fields must be filled in by\n   * outer application before starting compression.  in_color_space must\n   * be correct before you can even call jpeg_set_defaults().\n   */\n\n  JDIMENSION image_width;\t/* input image width */\n  JDIMENSION image_height;\t/* input image height */\n  int input_components;\t\t/* # of color components in input image */\n  J_COLOR_SPACE in_color_space;\t/* colorspace of input image */\n\n  double input_gamma;\t\t/* image gamma of input image */\n\n  /* Compression parameters --- these fields must be set before calling\n   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to\n   * initialize everything to reasonable defaults, then changing anything\n   * the application specifically wants to change.  That way you won't get\n   * burnt when new parameters are added.  Also note that there are several\n   * helper routines to simplify changing parameters.\n   */\n\n  unsigned int scale_num, scale_denom; /* fraction by which to scale image */\n\n  JDIMENSION jpeg_width;\t/* scaled JPEG image width */\n  JDIMENSION jpeg_height;\t/* scaled JPEG image height */\n  /* Dimensions of actual JPEG image that will be written to file,\n   * derived from input dimensions by scaling factors above.\n   * These fields are computed by jpeg_start_compress().\n   * You can also use jpeg_calc_jpeg_dimensions() to determine these values\n   * in advance of calling jpeg_start_compress().\n   */\n\n  int data_precision;\t\t/* bits of precision in image data */\n\n  int num_components;\t\t/* # of color components in JPEG image */\n  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */\n\n  jpeg_component_info * comp_info;\n  /* comp_info[i] describes component that appears i'th in SOF */\n\n  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];\n  int q_scale_factor[NUM_QUANT_TBLS];\n  /* ptrs to coefficient quantization tables, or NULL if not defined,\n   * and corresponding scale factors (percentage, initialized 100).\n   */\n\n  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  /* ptrs to Huffman coding tables, or NULL if not defined */\n\n  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */\n  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */\n  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */\n\n  int num_scans;\t\t/* # of entries in scan_info array */\n  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */\n  /* The default value of scan_info is NULL, which causes a single-scan\n   * sequential JPEG file to be emitted.  To create a multi-scan file,\n   * set num_scans and scan_info to point to an array of scan definitions.\n   */\n\n  boolean raw_data_in;\t\t/* TRUE=caller supplies downsampled data */\n  boolean arith_code;\t\t/* TRUE=arithmetic coding, FALSE=Huffman */\n  boolean optimize_coding;\t/* TRUE=optimize entropy encoding parms */\n  boolean CCIR601_sampling;\t/* TRUE=first samples are cosited */\n  boolean do_fancy_downsampling; /* TRUE=apply fancy downsampling */\n  int smoothing_factor;\t\t/* 1..100, or 0 for no input smoothing */\n  J_DCT_METHOD dct_method;\t/* DCT algorithm selector */\n\n  /* The restart interval can be specified in absolute MCUs by setting\n   * restart_interval, or in MCU rows by setting restart_in_rows\n   * (in which case the correct restart_interval will be figured\n   * for each scan).\n   */\n  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */\n  int restart_in_rows;\t\t/* if > 0, MCU rows per restart interval */\n\n  /* Parameters controlling emission of special markers. */\n\n  boolean write_JFIF_header;\t/* should a JFIF marker be written? */\n  UINT8 JFIF_major_version;\t/* What to write for the JFIF version number */\n  UINT8 JFIF_minor_version;\n  /* These three values are not used by the JPEG code, merely copied */\n  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */\n  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */\n  /* ratio is defined by X_density/Y_density even when density_unit=0. */\n  UINT8 density_unit;\t\t/* JFIF code for pixel size units */\n  UINT16 X_density;\t\t/* Horizontal pixel density */\n  UINT16 Y_density;\t\t/* Vertical pixel density */\n  boolean write_Adobe_marker;\t/* should an Adobe marker be written? */\n\n  J_COLOR_TRANSFORM color_transform;\n  /* Color transform identifier, writes LSE marker if nonzero */\n\n  /* State variable: index of next scanline to be written to\n   * jpeg_write_scanlines().  Application may use this to control its\n   * processing loop, e.g., \"while (next_scanline < image_height)\".\n   */\n\n  JDIMENSION next_scanline;\t/* 0 .. image_height-1  */\n\n  /* Remaining fields are known throughout compressor, but generally\n   * should not be touched by a surrounding application.\n   */\n\n  /*\n   * These fields are computed during compression startup\n   */\n  boolean progressive_mode;\t/* TRUE if scan script uses progressive mode */\n  int max_h_samp_factor;\t/* largest h_samp_factor */\n  int max_v_samp_factor;\t/* largest v_samp_factor */\n\n  int min_DCT_h_scaled_size;\t/* smallest DCT_h_scaled_size of any component */\n  int min_DCT_v_scaled_size;\t/* smallest DCT_v_scaled_size of any component */\n\n  JDIMENSION total_iMCU_rows;\t/* # of iMCU rows to be input to coef ctlr */\n  /* The coefficient controller receives data in units of MCU rows as defined\n   * for fully interleaved scans (whether the JPEG file is interleaved or not).\n   * There are v_samp_factor * DCTSIZE sample rows of each component in an\n   * \"iMCU\" (interleaved MCU) row.\n   */\n  \n  /*\n   * These fields are valid during any one scan.\n   * They describe the components and MCUs actually appearing in the scan.\n   */\n  int comps_in_scan;\t\t/* # of JPEG components in this scan */\n  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];\n  /* *cur_comp_info[i] describes component that appears i'th in SOS */\n  \n  JDIMENSION MCUs_per_row;\t/* # of MCUs across the image */\n  JDIMENSION MCU_rows_in_scan;\t/* # of MCU rows in the image */\n  \n  int blocks_in_MCU;\t\t/* # of DCT blocks per MCU */\n  int MCU_membership[C_MAX_BLOCKS_IN_MCU];\n  /* MCU_membership[i] is index in cur_comp_info of component owning */\n  /* i'th block in an MCU */\n\n  int Ss, Se, Ah, Al;\t\t/* progressive JPEG parameters for scan */\n\n  int block_size;\t\t/* the basic DCT block size: 1..16 */\n  const int * natural_order;\t/* natural-order position array */\n  int lim_Se;\t\t\t/* min( Se, DCTSIZE2-1 ) */\n\n  /*\n   * Links to compression subobjects (methods and private variables of modules)\n   */\n  struct jpeg_comp_master * master;\n  struct jpeg_c_main_controller * main;\n  struct jpeg_c_prep_controller * prep;\n  struct jpeg_c_coef_controller * coef;\n  struct jpeg_marker_writer * marker;\n  struct jpeg_color_converter * cconvert;\n  struct jpeg_downsampler * downsample;\n  struct jpeg_forward_dct * fdct;\n  struct jpeg_entropy_encoder * entropy;\n  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */\n  int script_space_size;\n};\n\n\n/* Master record for a decompression instance */\n\nstruct jpeg_decompress_struct {\n  jpeg_common_fields;\t\t/* Fields shared with jpeg_compress_struct */\n\n  /* Source of compressed data */\n  struct jpeg_source_mgr * src;\n\n  /* Basic description of image --- filled in by jpeg_read_header(). */\n  /* Application may inspect these values to decide how to process image. */\n\n  JDIMENSION image_width;\t/* nominal image width (from SOF marker) */\n  JDIMENSION image_height;\t/* nominal image height */\n  int num_components;\t\t/* # of color components in JPEG image */\n  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */\n\n  /* Decompression processing parameters --- these fields must be set before\n   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes\n   * them to default values.\n   */\n\n  J_COLOR_SPACE out_color_space; /* colorspace for output */\n\n  unsigned int scale_num, scale_denom; /* fraction by which to scale image */\n\n  double output_gamma;\t\t/* image gamma wanted in output */\n\n  boolean buffered_image;\t/* TRUE=multiple output passes */\n  boolean raw_data_out;\t\t/* TRUE=downsampled data wanted */\n\n  J_DCT_METHOD dct_method;\t/* IDCT algorithm selector */\n  boolean do_fancy_upsampling;\t/* TRUE=apply fancy upsampling */\n  boolean do_block_smoothing;\t/* TRUE=apply interblock smoothing */\n\n  boolean quantize_colors;\t/* TRUE=colormapped output wanted */\n  /* the following are ignored if not quantize_colors: */\n  J_DITHER_MODE dither_mode;\t/* type of color dithering to use */\n  boolean two_pass_quantize;\t/* TRUE=use two-pass color quantization */\n  int desired_number_of_colors;\t/* max # colors to use in created colormap */\n  /* these are significant only in buffered-image mode: */\n  boolean enable_1pass_quant;\t/* enable future use of 1-pass quantizer */\n  boolean enable_external_quant;/* enable future use of external colormap */\n  boolean enable_2pass_quant;\t/* enable future use of 2-pass quantizer */\n\n  /* Description of actual output image that will be returned to application.\n   * These fields are computed by jpeg_start_decompress().\n   * You can also use jpeg_calc_output_dimensions() to determine these values\n   * in advance of calling jpeg_start_decompress().\n   */\n\n  JDIMENSION output_width;\t/* scaled image width */\n  JDIMENSION output_height;\t/* scaled image height */\n  int out_color_components;\t/* # of color components in out_color_space */\n  int output_components;\t/* # of color components returned */\n  /* output_components is 1 (a colormap index) when quantizing colors;\n   * otherwise it equals out_color_components.\n   */\n  int rec_outbuf_height;\t/* min recommended height of scanline buffer */\n  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows\n   * high, space and time will be wasted due to unnecessary data copying.\n   * Usually rec_outbuf_height will be 1 or 2, at most 4.\n   */\n\n  /* When quantizing colors, the output colormap is described by these fields.\n   * The application can supply a colormap by setting colormap non-NULL before\n   * calling jpeg_start_decompress; otherwise a colormap is created during\n   * jpeg_start_decompress or jpeg_start_output.\n   * The map has out_color_components rows and actual_number_of_colors columns.\n   */\n  int actual_number_of_colors;\t/* number of entries in use */\n  JSAMPARRAY colormap;\t\t/* The color map as a 2-D pixel array */\n\n  /* State variables: these variables indicate the progress of decompression.\n   * The application may examine these but must not modify them.\n   */\n\n  /* Row index of next scanline to be read from jpeg_read_scanlines().\n   * Application may use this to control its processing loop, e.g.,\n   * \"while (output_scanline < output_height)\".\n   */\n  JDIMENSION output_scanline;\t/* 0 .. output_height-1  */\n\n  /* Current input scan number and number of iMCU rows completed in scan.\n   * These indicate the progress of the decompressor input side.\n   */\n  int input_scan_number;\t/* Number of SOS markers seen so far */\n  JDIMENSION input_iMCU_row;\t/* Number of iMCU rows completed */\n\n  /* The \"output scan number\" is the notional scan being displayed by the\n   * output side.  The decompressor will not allow output scan/row number\n   * to get ahead of input scan/row, but it can fall arbitrarily far behind.\n   */\n  int output_scan_number;\t/* Nominal scan number being displayed */\n  JDIMENSION output_iMCU_row;\t/* Number of iMCU rows read */\n\n  /* Current progression status.  coef_bits[c][i] indicates the precision\n   * with which component c's DCT coefficient i (in zigzag order) is known.\n   * It is -1 when no data has yet been received, otherwise it is the point\n   * transform (shift) value for the most recent scan of the coefficient\n   * (thus, 0 at completion of the progression).\n   * This pointer is NULL when reading a non-progressive file.\n   */\n  int (*coef_bits)[DCTSIZE2];\t/* -1 or current Al value for each coef */\n\n  /* Internal JPEG parameters --- the application usually need not look at\n   * these fields.  Note that the decompressor output side may not use\n   * any parameters that can change between scans.\n   */\n\n  /* Quantization and Huffman tables are carried forward across input\n   * datastreams when processing abbreviated JPEG datastreams.\n   */\n\n  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];\n  /* ptrs to coefficient quantization tables, or NULL if not defined */\n\n  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];\n  /* ptrs to Huffman coding tables, or NULL if not defined */\n\n  /* These parameters are never carried across datastreams, since they\n   * are given in SOF/SOS markers or defined to be reset by SOI.\n   */\n\n  int data_precision;\t\t/* bits of precision in image data */\n\n  jpeg_component_info * comp_info;\n  /* comp_info[i] describes component that appears i'th in SOF */\n\n  boolean is_baseline;\t\t/* TRUE if Baseline SOF0 encountered */\n  boolean progressive_mode;\t/* TRUE if SOFn specifies progressive mode */\n  boolean arith_code;\t\t/* TRUE=arithmetic coding, FALSE=Huffman */\n\n  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */\n  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */\n  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */\n\n  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */\n\n  /* These fields record data obtained from optional markers recognized by\n   * the JPEG library.\n   */\n  boolean saw_JFIF_marker;\t/* TRUE iff a JFIF APP0 marker was found */\n  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */\n  UINT8 JFIF_major_version;\t/* JFIF version number */\n  UINT8 JFIF_minor_version;\n  UINT8 density_unit;\t\t/* JFIF code for pixel size units */\n  UINT16 X_density;\t\t/* Horizontal pixel density */\n  UINT16 Y_density;\t\t/* Vertical pixel density */\n  boolean saw_Adobe_marker;\t/* TRUE iff an Adobe APP14 marker was found */\n  UINT8 Adobe_transform;\t/* Color transform code from Adobe marker */\n\n  J_COLOR_TRANSFORM color_transform;\n  /* Color transform identifier derived from LSE marker, otherwise zero */\n\n  boolean CCIR601_sampling;\t/* TRUE=first samples are cosited */\n\n  /* Aside from the specific data retained from APPn markers known to the\n   * library, the uninterpreted contents of any or all APPn and COM markers\n   * can be saved in a list for examination by the application.\n   */\n  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */\n\n  /* Remaining fields are known throughout decompressor, but generally\n   * should not be touched by a surrounding application.\n   */\n\n  /*\n   * These fields are computed during decompression startup\n   */\n  int max_h_samp_factor;\t/* largest h_samp_factor */\n  int max_v_samp_factor;\t/* largest v_samp_factor */\n\n  int min_DCT_h_scaled_size;\t/* smallest DCT_h_scaled_size of any component */\n  int min_DCT_v_scaled_size;\t/* smallest DCT_v_scaled_size of any component */\n\n  JDIMENSION total_iMCU_rows;\t/* # of iMCU rows in image */\n  /* The coefficient controller's input and output progress is measured in\n   * units of \"iMCU\" (interleaved MCU) rows.  These are the same as MCU rows\n   * in fully interleaved JPEG scans, but are used whether the scan is\n   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block\n   * rows of each component.  Therefore, the IDCT output contains\n   * v_samp_factor*DCT_v_scaled_size sample rows of a component per iMCU row.\n   */\n\n  JSAMPLE * sample_range_limit; /* table for fast range-limiting */\n\n  /*\n   * These fields are valid during any one scan.\n   * They describe the components and MCUs actually appearing in the scan.\n   * Note that the decompressor output side must not use these fields.\n   */\n  int comps_in_scan;\t\t/* # of JPEG components in this scan */\n  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];\n  /* *cur_comp_info[i] describes component that appears i'th in SOS */\n\n  JDIMENSION MCUs_per_row;\t/* # of MCUs across the image */\n  JDIMENSION MCU_rows_in_scan;\t/* # of MCU rows in the image */\n\n  int blocks_in_MCU;\t\t/* # of DCT blocks per MCU */\n  int MCU_membership[D_MAX_BLOCKS_IN_MCU];\n  /* MCU_membership[i] is index in cur_comp_info of component owning */\n  /* i'th block in an MCU */\n\n  int Ss, Se, Ah, Al;\t\t/* progressive JPEG parameters for scan */\n\n  /* These fields are derived from Se of first SOS marker.\n   */\n  int block_size;\t\t/* the basic DCT block size: 1..16 */\n  const int * natural_order; /* natural-order position array for entropy decode */\n  int lim_Se;\t\t\t/* min( Se, DCTSIZE2-1 ) for entropy decode */\n\n  /* This field is shared between entropy decoder and marker parser.\n   * It is either zero or the code of a JPEG marker that has been\n   * read from the data source, but has not yet been processed.\n   */\n  int unread_marker;\n\n  /*\n   * Links to decompression subobjects (methods, private variables of modules)\n   */\n  struct jpeg_decomp_master * master;\n  struct jpeg_d_main_controller * main;\n  struct jpeg_d_coef_controller * coef;\n  struct jpeg_d_post_controller * post;\n  struct jpeg_input_controller * inputctl;\n  struct jpeg_marker_reader * marker;\n  struct jpeg_entropy_decoder * entropy;\n  struct jpeg_inverse_dct * idct;\n  struct jpeg_upsampler * upsample;\n  struct jpeg_color_deconverter * cconvert;\n  struct jpeg_color_quantizer * cquantize;\n};\n\n\n/* \"Object\" declarations for JPEG modules that may be supplied or called\n * directly by the surrounding application.\n * As with all objects in the JPEG library, these structs only define the\n * publicly visible methods and state variables of a module.  Additional\n * private fields may exist after the public ones.\n */\n\n\n/* Error handler object */\n\nstruct jpeg_error_mgr {\n  /* Error exit handler: does not return to caller */\n  JMETHOD(noreturn_t, error_exit, (j_common_ptr cinfo));\n  /* Conditionally emit a trace or warning message */\n  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));\n  /* Routine that actually outputs a trace or error message */\n  JMETHOD(void, output_message, (j_common_ptr cinfo));\n  /* Format a message string for the most recent JPEG error or message */\n  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));\n#define JMSG_LENGTH_MAX  200\t/* recommended size of format_message buffer */\n  /* Reset error state variables at start of a new image */\n  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));\n  \n  /* The message ID code and any parameters are saved here.\n   * A message can have one string parameter or up to 8 int parameters.\n   */\n  int msg_code;\n#define JMSG_STR_PARM_MAX  80\n  union {\n    int i[8];\n    char s[JMSG_STR_PARM_MAX];\n  } msg_parm;\n  \n  /* Standard state variables for error facility */\n  \n  int trace_level;\t\t/* max msg_level that will be displayed */\n  \n  /* For recoverable corrupt-data errors, we emit a warning message,\n   * but keep going unless emit_message chooses to abort.  emit_message\n   * should count warnings in num_warnings.  The surrounding application\n   * can check for bad data by seeing if num_warnings is nonzero at the\n   * end of processing.\n   */\n  long num_warnings;\t\t/* number of corrupt-data warnings */\n\n  /* These fields point to the table(s) of error message strings.\n   * An application can change the table pointer to switch to a different\n   * message list (typically, to change the language in which errors are\n   * reported).  Some applications may wish to add additional error codes\n   * that will be handled by the JPEG library error mechanism; the second\n   * table pointer is used for this purpose.\n   *\n   * First table includes all errors generated by JPEG library itself.\n   * Error code 0 is reserved for a \"no such error string\" message.\n   */\n  const char * const * jpeg_message_table; /* Library errors */\n  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */\n  /* Second table can be added by application (see cjpeg/djpeg for example).\n   * It contains strings numbered first_addon_message..last_addon_message.\n   */\n  const char * const * addon_message_table; /* Non-library errors */\n  int first_addon_message;\t/* code for first string in addon table */\n  int last_addon_message;\t/* code for last string in addon table */\n};\n\n\n/* Progress monitor object */\n\nstruct jpeg_progress_mgr {\n  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));\n\n  long pass_counter;\t\t/* work units completed in this pass */\n  long pass_limit;\t\t/* total number of work units in this pass */\n  int completed_passes;\t\t/* passes completed so far */\n  int total_passes;\t\t/* total number of passes expected */\n};\n\n\n/* Data destination object for compression */\n\nstruct jpeg_destination_mgr {\n  JOCTET * next_output_byte;\t/* => next byte to write in buffer */\n  size_t free_in_buffer;\t/* # of byte spaces remaining in buffer */\n\n  JMETHOD(void, init_destination, (j_compress_ptr cinfo));\n  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));\n  JMETHOD(void, term_destination, (j_compress_ptr cinfo));\n};\n\n\n/* Data source object for decompression */\n\nstruct jpeg_source_mgr {\n  const JOCTET * next_input_byte; /* => next byte to read from buffer */\n  size_t bytes_in_buffer;\t/* # of bytes remaining in buffer */\n\n  JMETHOD(void, init_source, (j_decompress_ptr cinfo));\n  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));\n  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));\n  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));\n  JMETHOD(void, term_source, (j_decompress_ptr cinfo));\n};\n\n\n/* Memory manager object.\n * Allocates \"small\" objects (a few K total), \"large\" objects (tens of K),\n * and \"really big\" objects (virtual arrays with backing store if needed).\n * The memory manager does not allow individual objects to be freed; rather,\n * each created object is assigned to a pool, and whole pools can be freed\n * at once.  This is faster and more convenient than remembering exactly what\n * to free, especially where malloc()/free() are not too speedy.\n * NB: alloc routines never return NULL.  They exit to error_exit if not\n * successful.\n */\n\n#define JPOOL_PERMANENT\t0\t/* lasts until master record is destroyed */\n#define JPOOL_IMAGE\t1\t/* lasts until done with image/datastream */\n#define JPOOL_NUMPOOLS\t2\n\ntypedef struct jvirt_sarray_control * jvirt_sarray_ptr;\ntypedef struct jvirt_barray_control * jvirt_barray_ptr;\n\n\nstruct jpeg_memory_mgr {\n  /* Method pointers */\n  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,\n\t\t\t\tsize_t sizeofobject));\n  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,\n\t\t\t\t     size_t sizeofobject));\n  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,\n\t\t\t\t     JDIMENSION samplesperrow,\n\t\t\t\t     JDIMENSION numrows));\n  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,\n\t\t\t\t      JDIMENSION blocksperrow,\n\t\t\t\t      JDIMENSION numrows));\n  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,\n\t\t\t\t\t\t  int pool_id,\n\t\t\t\t\t\t  boolean pre_zero,\n\t\t\t\t\t\t  JDIMENSION samplesperrow,\n\t\t\t\t\t\t  JDIMENSION numrows,\n\t\t\t\t\t\t  JDIMENSION maxaccess));\n  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,\n\t\t\t\t\t\t  int pool_id,\n\t\t\t\t\t\t  boolean pre_zero,\n\t\t\t\t\t\t  JDIMENSION blocksperrow,\n\t\t\t\t\t\t  JDIMENSION numrows,\n\t\t\t\t\t\t  JDIMENSION maxaccess));\n  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));\n  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,\n\t\t\t\t\t   jvirt_sarray_ptr ptr,\n\t\t\t\t\t   JDIMENSION start_row,\n\t\t\t\t\t   JDIMENSION num_rows,\n\t\t\t\t\t   boolean writable));\n  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,\n\t\t\t\t\t    jvirt_barray_ptr ptr,\n\t\t\t\t\t    JDIMENSION start_row,\n\t\t\t\t\t    JDIMENSION num_rows,\n\t\t\t\t\t    boolean writable));\n  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));\n  JMETHOD(void, self_destruct, (j_common_ptr cinfo));\n\n  /* Limit on memory allocation for this JPEG object.  (Note that this is\n   * merely advisory, not a guaranteed maximum; it only affects the space\n   * used for virtual-array buffers.)  May be changed by outer application\n   * after creating the JPEG object.\n   */\n  long max_memory_to_use;\n\n  /* Maximum allocation request accepted by alloc_large. */\n  long max_alloc_chunk;\n};\n\n\n/* Routine signature for application-supplied marker processing methods.\n * Need not pass marker code since it is stored in cinfo->unread_marker.\n */\ntypedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));\n\n\n/* Declarations for routines called by application.\n * The JPP macro hides prototype parameters from compilers that can't cope.\n * Note JPP requires double parentheses.\n */\n\n#ifdef HAVE_PROTOTYPES\n#define JPP(arglist)\targlist\n#else\n#define JPP(arglist)\t()\n#endif\n\n\n/* Short forms of external names for systems with brain-damaged linkers.\n * We shorten external names to be unique in the first six letters, which\n * is good enough for all known systems.\n * (If your compiler itself needs names to be unique in less than 15 \n * characters, you are out of luck.  Get a better compiler.)\n */\n\n#ifdef NEED_SHORT_EXTERNAL_NAMES\n#define jpeg_std_error\t\tjStdError\n#define jpeg_CreateCompress\tjCreaCompress\n#define jpeg_CreateDecompress\tjCreaDecompress\n#define jpeg_destroy_compress\tjDestCompress\n#define jpeg_destroy_decompress\tjDestDecompress\n#define jpeg_stdio_dest\t\tjStdDest\n#define jpeg_stdio_src\t\tjStdSrc\n#define jpeg_mem_dest\t\tjMemDest\n#define jpeg_mem_src\t\tjMemSrc\n#define jpeg_set_defaults\tjSetDefaults\n#define jpeg_set_colorspace\tjSetColorspace\n#define jpeg_default_colorspace\tjDefColorspace\n#define jpeg_set_quality\tjSetQuality\n#define jpeg_set_linear_quality\tjSetLQuality\n#define jpeg_default_qtables\tjDefQTables\n#define jpeg_add_quant_table\tjAddQuantTable\n#define jpeg_quality_scaling\tjQualityScaling\n#define jpeg_simple_progression\tjSimProgress\n#define jpeg_suppress_tables\tjSuppressTables\n#define jpeg_alloc_quant_table\tjAlcQTable\n#define jpeg_alloc_huff_table\tjAlcHTable\n#define jpeg_start_compress\tjStrtCompress\n#define jpeg_write_scanlines\tjWrtScanlines\n#define jpeg_finish_compress\tjFinCompress\n#define jpeg_calc_jpeg_dimensions\tjCjpegDimensions\n#define jpeg_write_raw_data\tjWrtRawData\n#define jpeg_write_marker\tjWrtMarker\n#define jpeg_write_m_header\tjWrtMHeader\n#define jpeg_write_m_byte\tjWrtMByte\n#define jpeg_write_tables\tjWrtTables\n#define jpeg_read_header\tjReadHeader\n#define jpeg_start_decompress\tjStrtDecompress\n#define jpeg_read_scanlines\tjReadScanlines\n#define jpeg_finish_decompress\tjFinDecompress\n#define jpeg_read_raw_data\tjReadRawData\n#define jpeg_has_multiple_scans\tjHasMultScn\n#define jpeg_start_output\tjStrtOutput\n#define jpeg_finish_output\tjFinOutput\n#define jpeg_input_complete\tjInComplete\n#define jpeg_new_colormap\tjNewCMap\n#define jpeg_consume_input\tjConsumeInput\n#define jpeg_core_output_dimensions\tjCoreDimensions\n#define jpeg_calc_output_dimensions\tjCalcDimensions\n#define jpeg_save_markers\tjSaveMarkers\n#define jpeg_set_marker_processor\tjSetMarker\n#define jpeg_read_coefficients\tjReadCoefs\n#define jpeg_write_coefficients\tjWrtCoefs\n#define jpeg_copy_critical_parameters\tjCopyCrit\n#define jpeg_abort_compress\tjAbrtCompress\n#define jpeg_abort_decompress\tjAbrtDecompress\n#define jpeg_abort\t\tjAbort\n#define jpeg_destroy\t\tjDestroy\n#define jpeg_resync_to_restart\tjResyncRestart\n#endif /* NEED_SHORT_EXTERNAL_NAMES */\n\n\n/* Default error-management setup */\nEXTERN(struct jpeg_error_mgr *) jpeg_std_error\n\tJPP((struct jpeg_error_mgr * err));\n\n/* Initialization of JPEG compression objects.\n * jpeg_create_compress() and jpeg_create_decompress() are the exported\n * names that applications should call.  These expand to calls on\n * jpeg_CreateCompress and jpeg_CreateDecompress with additional information\n * passed for version mismatch checking.\n * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.\n */\n#define jpeg_create_compress(cinfo) \\\n    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \\\n\t\t\t(size_t) sizeof(struct jpeg_compress_struct))\n#define jpeg_create_decompress(cinfo) \\\n    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \\\n\t\t\t  (size_t) sizeof(struct jpeg_decompress_struct))\nEXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,\n\t\t\t\t      int version, size_t structsize));\nEXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,\n\t\t\t\t\tint version, size_t structsize));\n/* Destruction of JPEG compression objects */\nEXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));\nEXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));\n\n/* Standard data source and destination managers: stdio streams. */\n/* Caller is responsible for opening the file before and closing after. */\nEXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));\nEXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));\n\n/* Data source and destination managers: memory buffers. */\nEXTERN(void) jpeg_mem_dest JPP((j_compress_ptr cinfo,\n\t\t\t       unsigned char ** outbuffer,\n\t\t\t       unsigned long * outsize));\nEXTERN(void) jpeg_mem_src JPP((j_decompress_ptr cinfo,\n\t\t\t      unsigned char * inbuffer,\n\t\t\t      unsigned long insize));\n\n/* Default parameter setup for compression */\nEXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));\n/* Compression parameter setup aids */\nEXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,\n\t\t\t\t      J_COLOR_SPACE colorspace));\nEXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));\nEXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,\n\t\t\t\t   boolean force_baseline));\nEXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,\n\t\t\t\t\t  int scale_factor,\n\t\t\t\t\t  boolean force_baseline));\nEXTERN(void) jpeg_default_qtables JPP((j_compress_ptr cinfo,\n\t\t\t\t       boolean force_baseline));\nEXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,\n\t\t\t\t       const unsigned int *basic_table,\n\t\t\t\t       int scale_factor,\n\t\t\t\t       boolean force_baseline));\nEXTERN(int) jpeg_quality_scaling JPP((int quality));\nEXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));\nEXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,\n\t\t\t\t       boolean suppress));\nEXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));\nEXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));\n\n/* Main entry points for compression */\nEXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,\n\t\t\t\t      boolean write_all_tables));\nEXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,\n\t\t\t\t\t     JSAMPARRAY scanlines,\n\t\t\t\t\t     JDIMENSION num_lines));\nEXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));\n\n/* Precalculate JPEG dimensions for current compression parameters. */\nEXTERN(void) jpeg_calc_jpeg_dimensions JPP((j_compress_ptr cinfo));\n\n/* Replaces jpeg_write_scanlines when writing raw downsampled data. */\nEXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,\n\t\t\t\t\t    JSAMPIMAGE data,\n\t\t\t\t\t    JDIMENSION num_lines));\n\n/* Write a special marker.  See libjpeg.txt concerning safe usage. */\nEXTERN(void) jpeg_write_marker\n\tJPP((j_compress_ptr cinfo, int marker,\n\t     const JOCTET * dataptr, unsigned int datalen));\n/* Same, but piecemeal. */\nEXTERN(void) jpeg_write_m_header\n\tJPP((j_compress_ptr cinfo, int marker, unsigned int datalen));\nEXTERN(void) jpeg_write_m_byte\n\tJPP((j_compress_ptr cinfo, int val));\n\n/* Alternate compression function: just write an abbreviated table file */\nEXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));\n\n/* Decompression startup: read start of JPEG datastream to see what's there */\nEXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,\n\t\t\t\t  boolean require_image));\n/* Return value is one of: */\n#define JPEG_SUSPENDED\t\t0 /* Suspended due to lack of input data */\n#define JPEG_HEADER_OK\t\t1 /* Found valid image datastream */\n#define JPEG_HEADER_TABLES_ONLY\t2 /* Found valid table-specs-only datastream */\n/* If you pass require_image = TRUE (normal case), you need not check for\n * a TABLES_ONLY return code; an abbreviated file will cause an error exit.\n * JPEG_SUSPENDED is only possible if you use a data source module that can\n * give a suspension return (the stdio source module doesn't).\n */\n\n/* Main entry points for decompression */\nEXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));\nEXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,\n\t\t\t\t\t    JSAMPARRAY scanlines,\n\t\t\t\t\t    JDIMENSION max_lines));\nEXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));\n\n/* Replaces jpeg_read_scanlines when reading raw downsampled data. */\nEXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,\n\t\t\t\t\t   JSAMPIMAGE data,\n\t\t\t\t\t   JDIMENSION max_lines));\n\n/* Additional entry points for buffered-image mode. */\nEXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));\nEXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,\n\t\t\t\t       int scan_number));\nEXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));\nEXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));\nEXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));\nEXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));\n/* Return value is one of: */\n/* #define JPEG_SUSPENDED\t0    Suspended due to lack of input data */\n#define JPEG_REACHED_SOS\t1 /* Reached start of new scan */\n#define JPEG_REACHED_EOI\t2 /* Reached end of image */\n#define JPEG_ROW_COMPLETED\t3 /* Completed one iMCU row */\n#define JPEG_SCAN_COMPLETED\t4 /* Completed last iMCU row of a scan */\n\n/* Precalculate output dimensions for current decompression parameters. */\nEXTERN(void) jpeg_core_output_dimensions JPP((j_decompress_ptr cinfo));\nEXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));\n\n/* Control saving of COM and APPn markers into marker_list. */\nEXTERN(void) jpeg_save_markers\n\tJPP((j_decompress_ptr cinfo, int marker_code,\n\t     unsigned int length_limit));\n\n/* Install a special processing method for COM or APPn markers. */\nEXTERN(void) jpeg_set_marker_processor\n\tJPP((j_decompress_ptr cinfo, int marker_code,\n\t     jpeg_marker_parser_method routine));\n\n/* Read or write raw DCT coefficients --- useful for lossless transcoding. */\nEXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));\nEXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,\n\t\t\t\t\t  jvirt_barray_ptr * coef_arrays));\nEXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,\n\t\t\t\t\t\tj_compress_ptr dstinfo));\n\n/* If you choose to abort compression or decompression before completing\n * jpeg_finish_(de)compress, then you need to clean up to release memory,\n * temporary files, etc.  You can just call jpeg_destroy_(de)compress\n * if you're done with the JPEG object, but if you want to clean it up and\n * reuse it, call this:\n */\nEXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));\nEXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));\n\n/* Generic versions of jpeg_abort and jpeg_destroy that work on either\n * flavor of JPEG object.  These may be more convenient in some places.\n */\nEXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));\nEXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));\n\n/* Default restart-marker-resync procedure for use by data source modules */\nEXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,\n\t\t\t\t\t    int desired));\n\n\n/* These marker codes are exported since applications and data source modules\n * are likely to want to use them.\n */\n\n#define JPEG_RST0\t0xD0\t/* RST0 marker code */\n#define JPEG_EOI\t0xD9\t/* EOI marker code */\n#define JPEG_APP0\t0xE0\t/* APP0 marker code */\n#define JPEG_COM\t0xFE\t/* COM marker code */\n\n\n/* If we have a brain-damaged compiler that emits warnings (or worse, errors)\n * for structure definitions that are never filled in, keep it quiet by\n * supplying dummy definitions for the various substructures.\n */\n\n#ifdef INCOMPLETE_TYPES_BROKEN\n#ifndef JPEG_INTERNALS\t\t/* will be defined in jpegint.h */\nstruct jvirt_sarray_control { long dummy; };\nstruct jvirt_barray_control { long dummy; };\nstruct jpeg_comp_master { long dummy; };\nstruct jpeg_c_main_controller { long dummy; };\nstruct jpeg_c_prep_controller { long dummy; };\nstruct jpeg_c_coef_controller { long dummy; };\nstruct jpeg_marker_writer { long dummy; };\nstruct jpeg_color_converter { long dummy; };\nstruct jpeg_downsampler { long dummy; };\nstruct jpeg_forward_dct { long dummy; };\nstruct jpeg_entropy_encoder { long dummy; };\nstruct jpeg_decomp_master { long dummy; };\nstruct jpeg_d_main_controller { long dummy; };\nstruct jpeg_d_coef_controller { long dummy; };\nstruct jpeg_d_post_controller { long dummy; };\nstruct jpeg_input_controller { long dummy; };\nstruct jpeg_marker_reader { long dummy; };\nstruct jpeg_entropy_decoder { long dummy; };\nstruct jpeg_inverse_dct { long dummy; };\nstruct jpeg_upsampler { long dummy; };\nstruct jpeg_color_deconverter { long dummy; };\nstruct jpeg_color_quantizer { long dummy; };\n#endif /* JPEG_INTERNALS */\n#endif /* INCOMPLETE_TYPES_BROKEN */\n\n\n/*\n * The JPEG library modules define JPEG_INTERNALS before including this file.\n * The internal structure declarations are read only when that is true.\n * Applications using the library should not include jpegint.h, but may wish\n * to include jerror.h.\n */\n\n#ifdef JPEG_INTERNALS\n#include \"jpegint.h\"\t\t/* fetch private declarations */\n#include \"jerror.h\"\t\t/* fetch error codes too */\n#endif\n\n#ifdef __cplusplus\n#ifndef DONT_USE_EXTERN_C\n}\n#endif\n#endif\n\n#endif /* JPEGLIB_H */\n"
}