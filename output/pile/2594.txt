{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains For example."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2594",
    "text": "Q:\n\nHow do I turn a string into the name of an array?\n\nI've think I've created multiple arrays from strings but if I try to inspect the array I receive an error.\nFile.open(\"livestock.txt\", \"r\") do |file|\n    file.readlines.each do |x|\n\n        if x.match(/:*:/)\n            # puts x.inspect\n            # strip string\n            x.gsub!(/[^A-Za-z]/, '')\n            x.downcase!\n            puts x.inspect\n            x = Array.new(){Hash.new}\n            # puts x.inspect\n            pigs.inspect\n        else\n            # puts \"no\"\n        end\n\n    end\nend\n\nanimals.rb:12:in `block (2 levels) in <main>': undefined local variable or method `pigs' for main:Object (NameError)\n    from animals.rb:2:in `each'\n    from animals.rb:2:in `block in <main>'\n    from animals.rb:1:in `open'\n    from animals.rb:1:in `<main>'\n\nIdeally I want to create pigs =[]\nthen add hashes to this array such as:\npigs = [{\"name\"=>\"peggy\", \"id\"=>1, \"owner\"=>\"wolcott farms\"},\n{\"name\"=>\"sue\", \"id\"=>2, \"owner\"=>\"blue moon farms\"},\n{\"name\"=>\"eddie\", \"id\"=>3, \"owner\"=>\"sunrise farms\"}\n]\n\nand the same for cows, etc.\nmy text file animals.txt is \n::pigs::  \nname, id, owner\npeggy, 1, wolcott farms \nsue, 2, blue moon farms\neddie, 3, sunrise farms\n\n::cows:: \nname, id, owner \ndee, 3, black hat farms \nsunny, 2, blue moon farms \nbess, 4, wolcott farms\n\nA:\n\nParse Text, Then Assign Using Instance Variables\nYou can't use local variables, but you can use Object#instance_variable_get and Object#instance_variable_set to do this kind of metaprogramming. For example:\nstr     = File.read '/tmp/livestock.txt'\nrecords = str.split /\\n\\n+/\nrecords.map! { |r| r.split /\\n/ }\nrecords.map do |r| \n  var    = ?@ << r.shift.strip.delete(?:)\n  fields = r.shift.strip.scan /[^,]+/\n  hashes = r.map { |e| e.split(?,).flat_map &:strip }.\n             map { |e| fields.zip e }.\n             map &:to_h\n  instance_variable_set var,\n    instance_variable_get(var).to_a.push(hashes).flatten!\nend;\n\n# The data is now stored correctly in the following instance variables.\n@pigs\n@cows\n\nCaveat\nNote that if @pigs or @cows already exist because you're testing in the REPL, your results may not be what you expect. Make sure you invoke Object#remove_instance_variable, set your variables to nil, or create a new instance of your class between tests.\n\n"
}