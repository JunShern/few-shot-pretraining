{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9107",
    "text": "Q:\n\nHow to parse RxJava to receive just the data that i want?\n\nI just want the numbers, but this is what i'm receiving at log:\n\n[Boletim(grade=4.5), Boletim(grade=9.5)]\n\nThe Response:\npublic class GradeResponse {\n\n    @Inject\n    Retrofit retrofit;\n\n    @Inject\n    MainPresenter mainPresenter;\n\n    public void getGradeRx() {\n\n        MyApplication.getMainComponent().injectIntoGradeResponse(this);// informando ao dagger sobre o uso de um component e a necessidade de injetar depend\u00eancia\n\n        Subscription getGrade = retrofit\n                .create(GradeService.class)\n                .getGrade()\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .map(model -> {\n\n                    return model.getBoletim();\n\n                })\n                .subscribe(new Observer<Boletim[]>() {\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        Log.i(TAG, \"saporra vai me matar ainda\");\n                    }\n\n                    @Override\n                    public void onNext(Boletim[] grades) {\n                        Log.i(TAG, Arrays.asList(grades).toString());\n                    }\n                });\n    }\n}\n\nThe models:\nGradeModel:\n@SerializedName(\"boletim\")\n    @Expose\n    private Boletim[] boletim;\n\nBoletim.class\npublic class Boletim {\n\n    @SerializedName(\"grade\")\n    @Expose\n    private double grade;\n\nThe retrofit service is ok, the dependency injection is working. I'm receiving the onSuccess method from rxJava, i just need now receiving only the numbers without this \"[Boletim(grade=\".\n\nA:\n\nYou are seeing the toString of your objects because you get the entire object in your map!\n\nonly the numbers without this \"[Boletim(grade=\".\n\nWay can't you map again and extract it? \n.map(model -> {               // This map returns a Boletim[]\n     return model.getBoletim();\n })\n.map(boletim -> {             // This map returns a double[]\n    Double grades = new Double[boletim.length];\n    for (int i =0; i < grades.length ; i++) {\n        grades[i] = boletim[i].getGrade() ;\n    } \n    return grades;\n}).subscribe(new Observer<Double[]>() {   // This subscribes to a double[]\n    @Override\n    public void onCompleted() {\n\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        Log.i(TAG, \"saporra vai me matar ainda\");\n    }\n\n    @Override\n    public void onNext(Double[] grades) {\n        Log.i(TAG, Arrays.toString(grades));\n    }\n}\n\nOr you could put the for loop into onNext \nIf you don't want an Observable of arrays, then use flatMap \n\n"
}