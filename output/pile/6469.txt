{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": true,
            "reason": "Text contains ['With that, here are four variations of DistinctCount(): (0.174)']."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['With that, here are four variations of DistinctCount(): (0.144)', 'Do the tests have the right amount of coverage or are there more particular cases to consider? (0.176)', 'Anyway, instead of having different versions with actual implementations for the same purpose (count the distinct elements), you can create one private method with the full implementation, and then, just call back this method on the other methods. (0.192)', 'The beginning of the test name is also quite valuable real-estate since your test runner/window is likely to truncate what it displays after a certain number of characters. (0.194)']."
        }
    ],
    "doc_id": "6469",
    "text": "Q:\n\nDistinctCount extension method\n\nHere I go again. I have been finding a fairly common pattern in business logic code. And that pattern looks like this: int sprocketCount = datastore.GetSprocketOrders(parameters).Distinct().Count(); I decided I wanted to build DistinctCount() (again from \"first principles\") as Distinct() will create a second enumerable off of the first before Count() is executed. With that, here are four variations of DistinctCount():\npublic static int DistinctCount<TSource>(this IEnumerable<TSource> source) =>\n    source?.DistinctCount((IEqualityComparer<TSource>)null) ?? throw new ArgumentNullException(nameof(source));\n\npublic static int DistinctCount<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)\n{\n    if (source is null)\n    {\n        throw new ArgumentNullException(nameof(source));\n    }\n\n    ISet<TSource> set = new HashSet<TSource>(comparer);\n    int num = 0;\n\n    using (IEnumerator<TSource> enumerator = source.GetEnumerator())\n    {\n        while (enumerator.MoveNext())\n        {\n            // ReSharper disable once AssignNullToNotNullAttribute\n            if (set.Add(enumerator.Current))\n            {\n                checked\n                {\n                    ++num;\n                }\n            }\n        }\n    }\n\n    return num;\n}\n\npublic static int DistinctCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)\n{\n    if (source is null)\n    {\n        throw new ArgumentNullException(nameof(source));\n    }\n\n    if (predicate is null)\n    {\n        throw new ArgumentNullException(nameof(predicate));\n    }\n\n    return source.DistinctCount(predicate, null);\n}\n\npublic static int DistinctCount<TSource>(\n    this IEnumerable<TSource> source,\n    Func<TSource, bool> predicate,\n    IEqualityComparer<TSource> comparer)\n{\n    if (source is null)\n    {\n        throw new ArgumentNullException(nameof(source));\n    }\n\n    if (predicate is null)\n    {\n        throw new ArgumentNullException(nameof(predicate));\n    }\n\n    ISet<TSource> set = new HashSet<TSource>(comparer);\n    int num = 0;\n\n    foreach (TSource source1 in source)\n    {\n        if (predicate(source1) && set.Add(source1))\n        {\n            checked\n            {\n                ++num;\n            }\n        }\n    }\n\n    return num;\n}\n\nAnd here are a battery of unit tests:\n[TestMethod]\n[ExpectedException(typeof(ArgumentNullException))]\npublic void TestNull()\n{\n    int[] nullArray = null;\n\n    // ReSharper disable once ExpressionIsAlwaysNull\n    Assert.AreEqual(0, nullArray.DistinctCount());\n}\n\n[TestMethod]\n[ExpectedException(typeof(ArgumentNullException))]\npublic void TestNullPredicate()\n{\n    int[] zero = Array.Empty<int>();\n    Func<int, bool> predicate = null;\n\n    // ReSharper disable once ExpressionIsAlwaysNull\n    Assert.AreEqual(0, zero.DistinctCount(predicate));\n}\n\n[TestMethod]\npublic void TestZero()\n{\n    int[] zero = Array.Empty<int>();\n\n    Assert.AreEqual(0, zero.DistinctCount());\n}\n\n[TestMethod]\npublic void TestOne()\n{\n    int[] one = { 1 };\n\n    Assert.AreEqual(1, one.DistinctCount());\n}\n\n[TestMethod]\npublic void TestOneWithDuplicate()\n{\n    int[] oneWithDuplicate = { 1, 1, 1, 1, 1 };\n\n    Assert.AreEqual(1, oneWithDuplicate.DistinctCount());\n}\n\n[TestMethod]\npublic void TestTwo()\n{\n    int[] two = { 1, 2 };\n\n    Assert.AreEqual(2, two.DistinctCount());\n}\n\n[TestMethod]\npublic void TestTwoWithDuplicate()\n{\n    int[] twoWithDuplicate = { 2, 1, 2, 1, 2, 2, 1, 2 };\n\n    Assert.AreEqual(2, twoWithDuplicate.DistinctCount());\n}\n\n[TestMethod]\npublic void TestTwoWithDuplicateUsingPredicate()\n{\n    int[] twoWithDuplicate = { 2, 1, 3, 2, 1, 2, 2, 1, 2, 3 };\n\n    Assert.AreEqual(2, twoWithDuplicate.DistinctCount(x => x > 1));\n}\n\n[TestMethod]\npublic void TestTwoUsingNullComparer()\n{\n    int[] two = { 1, 2 };\n    IEqualityComparer<int> comparer = null;\n\n    // ReSharper disable once ExpressionIsAlwaysNull\n    Assert.AreEqual(2, two.DistinctCount(comparer));\n}\n\n[TestMethod]\npublic void TestOneWithDuplicateUsingComparer()\n{\n    string[] one = { \"one\", \"One\", \"oNe\", \"ONE\" };\n\n    Assert.AreEqual(1, one.DistinctCount(StringComparer.InvariantCultureIgnoreCase));\n}\n\n[TestMethod]\npublic void TestTwoWithDuplicateUsingPredicateAndComparer()\n{\n    string[] two = { \"one\", \"two\", \"One\", \"Two\", \"oNe\", \"TWO\", \"ONE\", \"tWo\", \"three\" };\n\n    Assert.AreEqual(2, two.DistinctCount(x => x != \"three\", StringComparer.InvariantCultureIgnoreCase));\n}\n\nAs always, ooking for overall review - is the code readable, maintainable, performant? Do the tests have the right amount of coverage or are there more particular cases to consider?\n\nA:\n\nAs slepic in his comment, I also wonder why you use an enumerator in the first and foreach in the second place?\n\nYou can eliminate null checks in the versions that call other overrides:\n\npublic static int DistinctCount<TSource>(this IEnumerable<TSource> source) =>\n        source?.DistinctCount((IEqualityComparer<TSource>)null) ?? throw new ArgumentNullException(nameof(source));\n\ncan be reduced to:\npublic static int DistinctCount<TSource>(this IEnumerable<TSource> source) => DistinctCount(source, (IEqualityComparer<TSource>)null);\n\nAnd the other to:\npublic static int DistinctCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate) => DistinctCount(source, predicate, null);\n\nDo you really need num? Couldn't you just return set.Count?\n\nBy using ToHashSet<T>() directly as show below I only find a minor loss (if any) in performance compared to your versions:\n  public static class ExtensionsReview\n  {\n    public static int DistinctCount<TSource>(this IEnumerable<TSource> source) => DistinctCount(source, (IEqualityComparer<TSource>)null);\n\n    public static int DistinctCount<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)\n    {\n      if (source is null)\n      {\n        throw new ArgumentNullException(nameof(source));\n      }\n\n      return source.ToHashSet(comparer).Count;\n    }\n\n    public static int DistinctCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate) => DistinctCount(source, predicate, null);\n\n    public static int DistinctCount<TSource>(\n        this IEnumerable<TSource> source,\n        Func<TSource, bool> predicate,\n        IEqualityComparer<TSource> comparer)\n    {\n      if (source is null)\n      {\n        throw new ArgumentNullException(nameof(source));\n      }\n\n      if (predicate is null)\n      {\n        throw new ArgumentNullException(nameof(predicate));\n      }\n\n      return source.Where(predicate).ToHashSet(comparer).Count;\n\n    }\n  }\n\nAccording to your tests, I think you should test reference types (classes) with override of Equals()/GetHashCode() (and implementation of IEquatable<T>) with and without a custom comparer.\n\nA:\n\nSlepic and Henrik are wondering about the use of foreach and enumerator, and I'm too.\nAnyway, instead of having different versions with actual implementations for the same purpose (count the distinct elements), you can create one private method with the full implementation, and then, just call back this method on the other methods. \nSo, the main implementation would be like this : \nprivate static int CountDistinctIterator<TSource>(IEnumerable<TSource> source, Func<TSource, bool> predicate, IEqualityComparer<TSource> comparer)\n{\n    if (source == null) throw new ArgumentNullException(nameof(source));\n\n    var set = new HashSet<TSource>(comparer);\n    var count = 0;\n    foreach (TSource element in source)\n    {\n        checked\n        {\n            if (set.Add(element) && predicate(element))\n            {\n                count++;\n            }\n\n        }\n    }\n\n    return count;\n}\n\nNow, it's a matter of calling back this method with the appropriate arguments. \nLike this : \npublic static int CountDistinct<TSource>(this IEnumerable<TSource> source)\n{\n    return CountDistinctIterator<TSource>(source, (s) => true, null);\n}\n\npublic static int CountDistinct<TSource>(this IEnumerable<TSource> source,  IEqualityComparer<TSource> comparer)\n{\n    return CountDistinctIterator<TSource>(source, (s) => true, comparer);\n}\n\npublic static bool AnyDistinct<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)\n{\n    return CountDistinctIterator<TSource>(source, predicate, null) == 1;\n}\n\npublic static bool AnyDistinct<TSource>(this IEnumerable<TSource> source)\n{\n    return CountDistinctIterator<TSource>(source, (s) => true, null) == 1;\n}\n\nalthough, for this Distinct I don't see any usage for Func<TSource, bool> predicate except for checking if the element exists or not. As the Distinct would get the unique elements, and if you say element == xxx it'll always return 1 if exists, and 0 if not. Unless there is any other uses except this one, in my opinion, I find it beneficial if rename this method: \nDistinctCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)\n\nto something meaningful other than DistinctCount like for instance DistinctAny which return boolean (true if DistinctCount returns 1, false if 0). \nUPDATE : \nI have changed the methods name from DistinctCount to CountDistinct the reason of this is because the method is Counting, so the Count needs to be first so it would be easier to picked up, the other reason is doing this will make it appear after Count on the intellisense list. I also added AnyDistinct methods which replaced the mentioned method (the one with Func<TSource, bool>).\n\nA:\n\nJust looking at your tests, there's a couple of points to consider...\nNaming\nHaving Test at the front of every test case is usually redundant (public methods in test classes are tests...).  The beginning of the test name is also quite valuable real-estate since your test runner/window is likely to truncate what it displays after a certain number of characters.  Consider removing the 'Test'.  A better prefix might be the name of the method under test (although you may be using the name of the `TestClass for that, since you don't include that part of your code).\nMake it clear what you're testing\nI found your test methods that are testing for exceptions to be less than clear.\n\n[TestMethod]\n[ExpectedException(typeof(ArgumentNullException))]\npublic void TestNullPredicate()\n{\n    int[] zero = Array.Empty<int>();\n    Func<int, bool> predicate = null;\n\n    // ReSharper disable once ExpressionIsAlwaysNull\n    Assert.AreEqual(0, zero.DistinctCount(predicate));\n}\n\nInitially I skipped over the method annotation and just rest the test code.  On the face of it, it look like if there was a null predicate, you are expecting the method to return 0.  This seemed odd, however possible behaviour.  There's nothing in the test name (such as DistinctCount_NullPredicate_Throws) to indicate what the expected outcome was, then eventually there's the ExpectedException attribute, which explains that actually the test is expecting an ArgumentNullException.\nHaving an Assert statement when you're not actually expecting a value to be returned from the call is misleading.  It would be better to just call the method (zero.DistinctCount(predicate)).  The lack of an assertion helps to make it more obvious that the attributes indicate the success criteria for the test.\n\n"
}