{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "6650",
    "text": "Q:\n\nConnecting to Google via OAuth 2, \"invalid_request\" when requesting an access token\n\nThere are several questions along these lines already on SE, but I've read everything I can find that seems relevant, and I'm still not quite there.\nI got an authentication code, so now I need to exchange it for an access token and a refresh token.  However, Google returns the wonderfully non-specific error \"invalid_request\".  Here's my code:\nprivate const string  BaseAccessTokenUrl = \"https://accounts.google.com/o/oauth2/token\";\nprivate const string  ContentType        = \"application/x-www-form-urlencoded\";\n\npublic static string  GetRefreshToken(string clientId, string clientSecret, string authCode)\n    {\n    Dictionary<string, string>  parameters = new Dictionary<string, string>\n        {\n        { \"code\",          authCode },\n        { \"client_id\",     clientId },\n        { \"client_secret\", clientSecret },\n        { \"redirect_uri\",  \"http://localhost\" },\n        { \"grant_type\",    \"authorization_code\" }\n        };\n    string  rawJson = WebUtilities.Post(BaseAccessTokenUrl, parameters, ContentType);\n    return rawJson;  // TODO: Parse out the actual refresh token\n    }\n\nMy Post() method URL-encodes the parameters keys and values and concatenates them:\npublic static string  Post(string uri, Dictionary<string, string> properties, string contentType = \"application/x-www-form-urlencoded\")\n    {\n    string  content = String.Join(\"&\", from kvp in properties select UrlEncode(kvp.Key) + \"=\" + UrlEncode(kvp.Value) );\n    return Post(uri, content);\n    }\n\nThe two-parameter Post() method just handles converting the content to bytes, adding content-length, etc., then returns the contents of the response even if it came as a WebException.  I can include it if it's of any interest.\nThe authorization code looks right, it's similar to others I've seen: 62 characters, and it starts with \"4/\".  The client ID, secret, and redirect URL I've carefully copied from the Google API Console.  The app is registered as an \"Other\" app, and I'm connecting from a Windows machine.\nPer this and this post, I've tried NOT URL-encoding, with no change.  The OAuth Playground suggests that URL-encoding is correct.\nPer this post and this one, the properties are concatenated on a single line.\nPer this post, I've tried approval_prompt=force in the authorization request, but the new auth code did not work any better.  Do auth codes expire?  I'm using new codes within a few seconds, usually.\nPer the Google docs and this post, I'm using content-type \"application/x-www-form-encoded\".\nMy authorization request is for scope \"https://www.googleapis.com/auth/analytics.readonly\".\nPer this post, there's no leading question mark in the parameters.\nThere is a Google .NET OAuth library, but I was not able to get it working easily, and ~50,000 lines of code is more than I'd like to study if I have a choice.  I prefer to write something clean from the ground up than to blindly copy over a bunch of libraries, cargo cult-style.\n\nA:\n\nFound it.  The redirect_uri used to request tokens needs to match what was used when getting the authorization code.  Here's my working code to get an auth code:\nprivate const string  BaseAuthorizationUrl = \"https://accounts.google.com/o/oauth2/auth\";\npublic string  GetAuthorizationUrl(string clientId, IEnumerable<string> scopes)\n    {\n    var  parameters = new Dictionary<string, string>\n        {\n        { \"response_type\",   \"code\" },\n        { \"client_id\",       clientId },\n        { \"redirect_uri\",    RedirectUrl },\n        { \"scope\",           String.Join(\" \", scopes) },\n        { \"approval_prompt\", \"auto\" }\n        };\n    return WebUtilities.BuildUrl(BaseAuthorizationUrl, parameters);\n    }\n\n...here's my code to get an access token and a refresh token:\nprivate const string  BaseAccessTokenUrl = \"https://accounts.google.com/o/oauth2/token\";\npublic void  GetTokens(string clientId, string clientSecret, string authorizationCode, out string accessToken, out string refreshToken)\n    {\n    var  parameters = new Dictionary<string, string>\n        {\n        { \"code\",          authorizationCode },\n        { \"redirect_uri\",  RedirectUrl },  // Must match that used when authorizing an app\n        { \"client_id\",     clientId },\n        { \"scope\",         String.Empty },\n        { \"client_secret\", clientSecret },\n        { \"grant_type\",    \"authorization_code\" }\n        };\n    string   rawJson    = WebUtilities.Post(BaseAccessTokenUrl, parameters, \"application/x-www-form-urlencoded\");\n    dynamic  parsedJson = JsonUtilities.DeserializeObject(rawJson);\n    accessToken  = parsedJson.access_token;\n    refreshToken = parsedJson.refresh_token;\n    }\n\n...here's the code to get a fresh access token:\npublic string  GetAccessToken(string clientId, string clientSecret, string refreshToken)\n    {\n    var  parameters = new Dictionary<string, string>\n        {\n        { \"client_id\",     clientId },\n        { \"client_secret\", clientSecret },\n        { \"refresh_token\", refreshToken },\n        { \"grant_type\",    \"refresh_token\" }\n        };\n    string   rawJson    = WebUtilities.Post(BaseAccessTokenUrl, parameters, \"application/x-www-form-urlencoded\");\n    dynamic  parsedJson = JsonUtilities.DeserializeObject(rawJson);\n    return parsedJson.access_token;\n    }\n\n"
}