{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4856",
    "text": "Q:\n\nHow to specify a git merge \"ours\" strategy with .gitattributes for deleted files?\n\nI have 2 branches in my project: A (master) & B. In branch B some of the files that are in master have been deleted. I want to avoid merge conflicts when there are changes in master to files that have been deleted in B.\nI have added the files to .gitattributes, e.g.\nREADME.adoc merge=ours\n\nFor my merge driver I have\n[merge \"ours\"]\nname = Always keep mine during merge\ndriver = true\n\nHowever I still get conflicts and I can't figure out what I'm doing wrong.\ngit merge master\nCONFLICT (modify/delete): README.adoc deleted in HEAD and modified in master. Version master of README.adoc left in tree.\n\nWhat am I doing wrong? I have run git check-attr and it shows\nREADME.adoc: merge: ours\n\nI've also tried GIT_TRACE=2 but it provides no useful info; it only tells me where it is getting the binaries from.\n\nA:\n\nA modify/delete conflict is a high level conflict.  Merge drivers, defined in .gitattributes, are used only for solving low level conflicts: the merge driver is used only when the file (a) exists in all three versions (base and both branch tips) and (b) differs in all three versions.  Here, the file exists in two versions\u2014base and one branch tip\u2014and differs in those two versions, but the third version is simply deleted entirely, and the merge driver is never invoked.\nFor the recursive, resolve, and subtree strategies, high level conflicts always result in a merge conflict and a suspended-in-mid-process merge.  High level conflicts simply never occur in the ours strategy (-s ours, very different from the -X ours extended-option) as it looks only at the current tree.  High level conflicts in octopus are (I think) fatal: the octopus merge is aborted entirely.2\n\nI want to avoid merge conflicts when there are changes in A to files that have been deleted in B.\n\nTo do this, you must write a merge strategy.  This is hard.1  See my answer to git \"trivial\" merge strategy that directly commits merge conflicts.\n\n1The main evidence I have for \"hard\" is the fact that Git comes with those five strategies\u2014resolve, recursive, ours, octopus, and subtree\u2014and despite well over a decade of development, Git still has only those five strategies.\n2I never actually do octopus merges, so my experience here is limited.\n\n"
}