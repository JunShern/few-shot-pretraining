{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "6513",
    "text": "Q:\n\nO que \u00e9 mais r\u00e1pido para ser lido e editado, um banco de dados ou um .txt?\n\nSeria para armazenar e reescrever apenas 1 d\u00edgito INT, apagando um e escrevendo outro, na condi\u00e7\u00e3o de que quando chegar a 5, voltar pro 1, e ir fazendo esse loop toda vez que algu\u00e9m acessar.\nSempre que algu\u00e9m acessar a p\u00e1gina, o valor seria acrescido de +1 e gravado, exceto que j\u00e1 tivesse em 5, a\u00ed voltaria pro 1.\nEnfim. PHP + MySQL, ou PHP + .txt, qual \u00e9 mais r\u00e1pido para essa finalidade?\nConsiderando que se fazendo centenas de requests simult\u00e2neos n\u00e3o bugue o sistema, qual \u00e9 melhor? \n\nA:\n\nUm arquivo texto flat ser\u00e1 sempre mais r\u00e1pido, ele n\u00e3o tem que fazer quase nada. Um banco de dados executa um conjunto monumental de coisas para garantir a integridade dos dados e fazer isso de uma forma f\u00e1cil e padronizada.\nIsso n\u00e3o quer dizer que seja a melhor op\u00e7\u00e3o. Se for acessar o arquivo concorrentemente tem que saber o que est\u00e1 fazendo, caso contr\u00e1rio ter\u00e1 problemas, mesmo em um padr\u00e3o simples como o relatado.\nO que n\u00e3o cria bugs no sistema \u00e9 dominar todo o processo de desenvolvimento de software, implanta\u00e7\u00e3o e manuten\u00e7\u00e3o da infraestrutura. Isso n\u00e3o \u00e9 s\u00f3 saber se \u00e9 melhor usar MySQL ou .txt. Mas se n\u00e3o sabe o que \u00e9 melhor, v\u00e1 no mais seguro que \u00e9 o banco de dados. Pelo menos ele exige menos cuidado.\nUma alternativa intermedi\u00e1ria seria o uso do SQLite que possui as caracter\u00edsticas do banco de dados com algumas facilidades do acesso ao arquivo, incluindo melhor performance.\nEm alguns casos outro banco de dados pode ser mais \u00fatil, quem sabe um NoSQL.\n\nA:\n\nSegundo o que descreveu, haver\u00e1 centenas de conex\u00f5es simult\u00e2neas. Cada conex\u00e3o incrementa um valor e quando chegar a 5, volta ao valor 1.\nCom arquivo txt isso pode ser um problema pois ter\u00e1 que criar condi\u00e7\u00f5es para impedir inconsist\u00eancias.\nUma l\u00f3gica \u00e9 travar a edi\u00e7\u00e3o ou acesso ao arquivo caso j\u00e1 esteja aberto por algum usu\u00e1rio:\n$f = fopen('fit.txt', 'a');\nif(flock($f, LOCK_EX | LOCK_NB)) {\n    $n = fread($fp, 4);\n    ($n == 5)? $n = 1: $n++;\n    fwrite($f, $n);\n    flock($f, LOCK_UN);\n}\nfclose($f);\n\nUsando um banco de dados essa opera\u00e7\u00e3o \u00e9 mais segura, no entanto, \u00e9 \u00f3bvio que ter\u00e1 um custo muito maior de processos.\nAntes de pensar em performance, pense em consist\u00eancia. Se a rotina \u00e9 segura e tem certeza de que n\u00e3o haver\u00e1 falha, voc\u00ea vai para o \"pr\u00f3ximo est\u00e1gio\" que \u00e9 a otimiza\u00e7\u00e3o.\nNesse exemplo acima com flock(), o processo \u00e9 \"super r\u00e1pido\" mas ainda assim pode acontecer alguma falha. Algo inexperado onde demore muito para liberar para o pr\u00f3ximo usu\u00e1rio.\nImagine ent\u00e3o um cen\u00e1rio onde 200 usu\u00e1rios acessaram no mesmo exato tempo.\nO primeiro ser\u00e1 o \"sortudo\". Vai ler e escrever o n\u00famero e liberar para o segundo, terceiro, quarto. Mas o que estiver por \u00faltimo na fila conseguir\u00e1 ler e escrever o valor corretamente ou retornar\u00e1 algum erro por longo tempo de espera?\nConsidere que se o sistema tem centenas de acessos simult\u00e2neos, digamos que num \u00fanico segundo receba 150 conex\u00f5es e depois de 2 segundos mais 200 e depois de 2 segundos mais 100. S\u00f3 a\u00ed voc\u00ea j\u00e1 tem, num espa\u00e7o de 5 segundos, 350 neguinho na fila de espera para ler e escrever nesse txt. O sistema pode interromper a execu\u00e7\u00e3o por volta do n\u00famero 200 devido a longa espera. \nPode ser o caso de repensar a l\u00f3gica do neg\u00f3cio.\nCaso n\u00e3o tenha essa grande quantidade de conex\u00f5es simult\u00e2neas, a\u00ed sim, o simples flock(), como no exemplo, pode resolver e ser ainda uma op\u00e7\u00e3o mais vi\u00e1vel que um banco de dados, em termos de performance.\n\n"
}