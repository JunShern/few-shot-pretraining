{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains For example."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['-', '3', '-', '-', '-', '-']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['In the example above, the C++ class EventDispatcherObject will have two (0.178)', 'In  the example above, the C++ class StackFrame will have two generted (0.178)']."
        }
    ],
    "doc_id": "2572",
    "text": "Layout of member constants and member variables of AS3 classes in memory\n------------------------------------------------------------------------\n\nThe AS3 class below defines a member variable v of type number and a\nmember constant c of type Boolean.\n\nclass MyClass {\n    public var v : Number;\n    public const c : Boolean;\n}\n\nWhen the VM allocates an instance of MyClass it must reserve space in\nthe instance to contain the values of v and c.  The VM refers to the\nspace reserved for v and c as \"slots\".  The slot for v is always 8 bytes\nand the slot for c is always 4 bytes. Slots whose type is not one of\nBoolean, Number, uint, or int are the same size as pointers ( 4 bytes in\n32 bit targets, 8 bytes in 64 bit targets ).\n\n\nThe memory layout of an instance of MyClass is shown below:\n\n-------------------------------------------\n| avmplus::ScriptObject                   |\n|   includes C++ vtable and               |\n|   base classes of avmplus::ScriptObject |\n|-----------------------------------------|\n| 4 byte slots for MyClass ( slot for c ) |\n| pointer slots for MyClass ( empty )     |\n| 8 byte slots for MyClass ( slot for v ) |\n------------------------------------------|\n\nClasses that are part of the AS3 API exposed by the FlashPlayer, AIR\nRuntime, or AVM shell often contain native methods.  If a class contains\na native method, then it is a native class.  Native classes must extend\nObject or another native class.  Consider the following classes:\n\n\n[native(cls=\"EventDispatcherClass\", instance=\"EventDispatcherObject\", methods=\"auto\")]\nclass EventDispatcher {\n  .\n  .\n  .\n  public native function dispatchEvent(ev : Event, bubbles : Boolean, cancelable : Boolean) : Boolean;\n  private var m_handlers : Dictionary;\n}\n\n[native(cls=\"DisplayObjectClass\", instance=\"DisplayObject\", methods=\"auto\")]\nclass DisplayObject extends EventDispatcher {\n  \n  public function get x() : Number { return m_x; }\n  public native function set x(newX : Number);\n  .\n  .\n  .\n  private var m_x : Number;\n  .\n  .\n  .\n}\n\nThe memory layout of instances of all subclasses of DisplayObject will\nstart with the layout shown below:\n-------------------------------------------------------------\n| avmplus::ScriptObject                                     |\n|   includes C++ vtable and                                 |\n|   base classes of avmplus::ScriptObject                   |\n|-----------------------------------------------------------|\n| avmplus::EventDispatchObject C++ member                   |\n|    variables.                                             |\n| 4 byte slots for EventDispatcher ( empty )                |\n| pointer slots for EventDispatcher ( slot for m_handlers ) |\n| 8 byte slots for MyClass ( empty )                        |\n|-----------------------------------------------------------|\n| avmplus::DisplayObject C++ member variables               |\n| 4 byte slots for DisplayObject ( none )                   |\n| pointer slots for DisplayObject ( none )                  |\n| 8 byte slots for DisplayObject ( slot for m_x )           |\n-------------------------------------------------------------\n\nThis memory layout has the property that the offset to a slot of a given\nclass does not depend on which C++ class is actually instantiated.  This\nis an important property that previous slot layout schemes did not have.\n\nThis slot layout also make it possible for nativegen.py to generate C++\ncode that can get or set any slot on an instance of a native AS3 class. \nFor each native AS3 class nativegen.py determines if that class has any\ninstance or class slots.  nativegen.py will generate a class will\ngenerate C++ class and macro for the class instance and class closure if\nthey each have slots.  The macros expand to accessor methods for the\nslots and an instance of the generate C++ classes. The last statement of\nthe C++ instance class and the C++ class closure classes of all AS3\nnative classes should a reference to the corresponding generated macros.\n\nFrom the previous example, the C++ class definitions for instance and\nclasses closure classes for EventDispatch and DisplayObject should be as\nfollows:\n\nnamespace avmplus\n{\n    class EventDispatcherClass : public ClassClosure\n    {\n        .\n        .\n        .\n        DECLARE_SLOTS_EventDispatcherClass;\n    };\n    \n    \n    class EventDispatcherObject : public ScriptObject\n    {\n        .\n        .\n        .\n        DECLARE_SLOTS_EventDispatcherObject;\n    };\n    \n    .\n    .\n    .\n    .\n    \n    class DisplayObjectClass : public ClassClosure\n    {\n        .\n        .\n        .\n        DECLARE_SLOTS_DisplayObjectClass;\n    };\n    \n    class DisplayObject : public EventDispatcherObject\n    {\n        .\n        .\n        .\n        DECLARE_SLOTS_DisplayObject;\n    };\n}\n\nIn the example above, the C++ class EventDispatcherObject will have two\ngenerated methods for setting and getting the m_handlers slot: void\nEventDispatcherObject::set_private_m_handlers(DictionaryObject*);\nDictionaryObject* EventDispatcherObject::get_private_m_handlers() const;\n\nBoth methods are protected methods of EventDispatcherObject and should\nfully inline.  The get methods should compile down to a single load from\nmemory instruction in the release build.  The set method will need to\nfire a ref-counted write barrier, but is none the less as efficient as\ncode be written by hand or by the JIT.\n\nThe C++ class DisplayObject will have two generated methods for setting\nand getting the m_x slot: void DisplayObject::set_private_m_x(double);\ndouble DisplayObject::get_private_m_x() const;\n\nBoth of these methods will fully inline in the release build to memory\nstore and load instructions.\n\nIf a slot is declared using the const keyword instead of the var\nkeyword, then by default nativegen.py will not generate C++ setter\nmethods for that slot.  If the C++ code needs to set the value of a\nconst slot, the constsetters meta data attribute should be added to the\nnative metadata of the AS3 class.  For example:\n\n[native(cls=\"StackFrameClass\", instance=\"StackFrameObject\", methods=\"auto\", constsetters=\"true\")] // @todo: native only for slot getter/setter\npublic final class StackFrame\n{\n    .\n    .\n    .\n    public const name:String;\n}\n\nIn  the example above, the C++ class StackFrame will have two generted\nmethods for setting and getting the name slot: void\nStackFrameObject::set_name(AvmString newVal); AvmString\nStackFrameObject::get_name();\n\n\n\n"
}