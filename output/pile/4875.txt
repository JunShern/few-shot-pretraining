{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4875",
    "text": "Q:\n\nHow to sort a Map by Key and Value, whereas the Val is a Map/List itself\n\nI am having a hard time understanding the right syntax to  sort Maps which values aren't simply one type, but can be nested again.\nI'll try to come up with a fitting example here:\nLet's make a random class for that first:\nclass NestedFoo{\nint valA;\nint valB;\nString textA;\n\npublic NestedFoo(int a, int b, String t){\n  this.valA = a;\n  this.valB = b;\n  this.textA = t;\n  }\n}\n\nAlright, that is our class.\nHere comes the list:\nHashMap<Integer, ArrayList<NestedFoo>> sortmePlz = new HashMap<>();\n\nLet's create 3 entries to start with, that should show sorting works already.\nArrayList<NestedFoo> l1 = new ArrayList<>();\nn1 = new NestedFoo(3,2,\"a\");\nn2 = new NestedFoo(2,2,\"a\");\nn3 = new NestedFoo(1,4,\"c\");\nl1.add(n1);\nl1.add(n2);\nl1.add(n3);\n\nArrayList<NestedFoo> l2 = new ArrayList<>();\nn1 = new NestedFoo(3,2,\"a\");\nn2 = new NestedFoo(2,2,\"a\");\nn3 = new NestedFoo(2,2,\"b\");\nn4 = new NestedFoo(1,4,\"c\");\nl2.add(n1);\nl2.add(n2);\nl2.add(n3);\nl2.add(n4);\n\nArrayList<NestedFoo> l3 = new ArrayList<>();\nn1 = new NestedFoo(3,2,\"a\");\nn2 = new NestedFoo(2,3,\"b\");\nn3 = new NestedFoo(2,2,\"b\");\nn4 = new NestedFoo(5,4,\"c\");\nl3.add(n1);\nl3.add(n2);\nl3.add(n3);\nl3.add(n4);\n\nSweet, now put them in our Map.\nsortmePlz.put(5,l1);\nsortmePlz.put(2,l2);\nsortmePlz.put(1,l3);\n\nWhat I want now, is to sort the Entire Map first by its Keys, so the order should be l3 l2 l1.\nThen, I want the lists inside each key to be sorted by the following Order:\nintA,intB,text (all ascending)\nI have no idea how to do this.  Especially not since Java 8 with all those lambdas, I tried to read on the subject but feel overwhelmed by the code there.\nThanks in advance!\nI hope the code has no syntatical errors, I made it up on the go\n\nA:\n\nYou can use TreeSet instead of regular HashMap and your values will be automatically sorted by key:\nMap<Integer, ArrayList<NestedFoo>> sortmePlz = new TreeMap<>();\nSecond step I'm a little confused.\n\nto be sorted by the following Order: intA,intB,text (all ascending)\n\nI suppose you want to sort the list by comparing first the intA values, then if they are equal compare by intB and so on. If I understand you correctly you can use Comparator with  comparing and thenComparing.\nsortmePlz.values().forEach(list -> list\n            .sort(Comparator.comparing(NestedFoo::getValA)\n                            .thenComparing(NestedFoo::getValB)\n                            .thenComparing(NestedFoo::getTextA)));\n\n"
}