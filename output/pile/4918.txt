{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['1', '2', '3', '4', '5', '1', '2', '3', '4', '5']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4918",
    "text": "Q:\n\nAggregate variables in list of data frames into single data frame\n\nI am performing a per policy life insurance valuation in R. Monthly cash flow projections are performed per policy and returns a data frame in the following format (for example):\nPolicy1 = data.frame(ProjM = 1:200,\n                     Cashflow1 = rep(5,200),\n                     Cashflow2 = rep(10,200))\n\nMy model returns a list (using lapply and a function which performs the per policy cashflow projection - based on various per policy details, escalation assumptions and life contingencies). I want to aggregate the cash flows across all policies by ProjM. The following code does what I want, but looking for a more memory efficient way (ie not using the rbindlist function). Example data:\nPolicy1 = data.frame(ProjM = 1:5,\n                     Cashflow1 = rep(5,5),\n                     Cashflow2 = rep(10,5))\n\nPolicy2 = data.frame(ProjM = 1:3,\n                     Cashflow1 = rep(50,3),\n                     Cashflow2 = rep(-45,3))\n\n# this is the output containing 35000 data frames:\nListOfDataFrames = list(Policy1 = Policy1, Policy2 = Policy2)\n\nMy code:\nlibrary(data.table)\nOneBigDataFrame <- rbindlist(ListOfDataFrames)\nMyOutput <- aggregate(. ~ ProjM, data = OneBigDataFrame, FUN = sum)\n\nOutput required:\nProjM Cashflow1 Cashflow2\n 1        55       -35\n 2        55       -35\n 3        55       -35\n 4         5        10\n 5         5        10\n\nI have looked for examples, and R aggregate list of dataframe performs aggregation for all data frames, but do not combine them into 1 data frame.\n\nA:\n\nWith data.table syntax the one step approach would be to create the big data.table first and then do the aggregation:\nlibrary(data.table)\nOneBigDataFrame <- rbindlist(ListOfDataFrames)\nOneBigDataFrame[, lapply(.SD, sum), by = ProjM]\n\nor, more concise\nrbindlist(ListOfDataFrames)[, lapply(.SD, sum), by = ProjM]\n\n   ProjM Cashflow1 Cashflow2\n1:     1        55       -35\n2:     2        55       -35\n3:     3        55       -35\n4:     4         5        10\n5:     5         5        10\n\nNow, the OP has requested to avoid creating the big data.table first in order to save memory. This requires a two step approach where the aggregates are computed for each data.table which are then aggregated to a grand total in the final step:\nrbindlist(\n  lapply(ListOfDataFrames, \n         function(x) setDT(x)[, lapply(.SD, sum), by = ProjM])\n  )[, lapply(.SD, sum), by = ProjM]\n\n   ProjM Cashflow1 Cashflow2\n1:     1        55       -35\n2:     2        55       -35\n3:     3        55       -35\n4:     4         5        10\n5:     5         5        10\n\nNote that setDT() is used here to coerce the data.frames to data.table by reference, i.e., without creating an additional copy which saves time and memory.\nBenchmark\nUsing the benchmark data of d.b (list of 10000 data.frames with 100 rows each, 28.5 Mb in total) with all answers provided so far:\nmb <- microbenchmark::microbenchmark(\n  malan = {\n    OneBigDataFrame <- rbindlist(test)\n    malan <- aggregate(. ~ ProjM, data = OneBigDataFrame, FUN = sum)\n  },\n  d.b = d.b <- with(data = data.frame(do.call(dplyr::bind_rows, test)),\n             expr = aggregate(x = list(Cashflow1 = Cashflow1, Cashflow2 = Cashflow2),\n                              by = list(ProjM = ProjM),\n                              FUN = sum)),\n  a.gore = {\n    newagg <- function(dataset) { \n      dataset <- data.table(dataset)\n      dataset <- dataset[,lapply(.SD,sum),by=ProjM,.SDcols=c(\"Cashflow1\",\"Cashflow2\")]\n      return(dataset)\n    }\n    a.gore <- newagg(rbindlist(lapply(test,newagg)))\n  },\n  dt1 = dt1 <- rbindlist(test)[, lapply(.SD, sum), by = ProjM],\n  dt2 = dt2 <- rbindlist(\n    lapply(test, \n           function(x) setDT(x)[, lapply(.SD, sum), by = ProjM])\n  )[, lapply(.SD, sum), by = ProjM],\n  times = 5L\n)\nmb\n\nUnit: milliseconds\n   expr         min          lq        mean      median          uq        max neval  cld\n  malan   565.43967   583.08300   631.15898   600.45790   605.60237   801.2120     5  b  \n    d.b   707.50261   710.31127   719.25591   713.54526   721.26691   743.6535     5  b  \n a.gore 14706.40442 14747.76305 14861.61641 14778.88547 14805.29412 15269.7350     5    d\n    dt1    40.10061    40.92474    42.27034    41.55434    42.07951    46.6925     5 a   \n    dt2  8806.85039  8846.47519  9144.00399  9295.29432  9319.17251  9452.2275     5   c\n\nThe fastest solution is the one step approach using data.table which is 15 times faster than the second fastest. Surprisingly, the two step data.table approaches are magnitudes slower than the one step approach.\nTo make sure that all solutions return the same result this can be checked using\nall.equal(malan, d.b)\nall.equal(malan, as.data.frame(a.gore))\nall.equal(malan, as.data.frame(dt1))\nall.equal(malan, as.data.frame(dt2))\n\nwhich return TRUE in all cases.\n\n"
}