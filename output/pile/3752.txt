{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "3752",
    "text": "Q:\n\nFinding new memory address? C++\n\n(I tested the address because I was getting errors and I found out the address changed before it was deleted, by the time the delete is called the titlePTR has already changed its address and it is giving me an error saying \"BLOCK TYPE IS VALID\" I heard this is when you try to delete a pointer that wasn't made by new (So that made me think about the address)\nBtw I know I don't have to make a dynamic array but I am reading a book and it is saying to practice saving memory for times where your program doesn't need to run the code. I posted on a few other places and people always nag about \"Don't use new blah blah blah\"\nHere is what is says when it trys to delete titlePTR or bodyPTR:\nhttp://postimg.org/image/gt0f8kufn/\nif (test == \"MapleStory\")\n{\n    wchar_t *titlePTR = new wchar_t[30]; <-- Example Address: 051\n    cout << titlePTR;\n    wchar_t *bodyPTR = new wchar_t[20];\n    titlePTR = L\"MapleStory\";\n    bodyPTR = L\"Launching MapleStory...\";\n    MessageBox(NULL, bodyPTR, titlePTR, MB_OK | MB_ICONINFORMATION);\n    ShellExecute(NULL, L\"open\", L\"GameLauncher.exe\", NULL, L\"C:\\\\Nexon\\\\MapleStory\", 1);\n    cout << endl << titlePTR; <-- Example Address: 0601 \n    delete[] titlePTR;\n    delete[] bodyPTR;\n}\n\nA:\n\nwchar_t *titlePTR = new wchar_t[30];   // (1)\ntitlePTR = L\"MapleStory\";              // (2)\ndelete[] titlePTR;                     // (3)\n\nThis allocates memory and stores the address of the memory in the variable (1). Then you overwrite it with a new address (2). And then you delete the new address (3), instead of the allocated memory. \nSo your problem is that the assignment in step (2) doesn't use the buffer you prepared but creates a new buffer.\nTo fix, just do:\nconst wchar_t *titlePTR = L\"MapleStory\";\n\nAnd don't delete of course, since you didn't allocate any memory using new.\n\n"
}