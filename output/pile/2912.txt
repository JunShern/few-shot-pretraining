{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2912",
    "text": "Q:\n\nStackExchange clone: where should I add my indexes?\n\nI'm creating an open source stack exchange clone and the following is my schema. What should I add indexes on for it to be optimal?\nHere is the schema in Rails format (SQL format below as well):\n  create_table \"comments\", force: true do |t|\n    t.integer  \"id\"\n    t.integer  \"post_id\",                null: false\n    t.integer  \"user_id\",                null: false\n    t.text     \"body\",                   null: false\n    t.integer  \"score\",      default: 0, null: false\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n  end\n\n  create_table \"post_types\", force: true do |t|\n    t.integer  \"id\"\n    t.string \"name\", null: false\n  end\n\n  create_table \"posts\", force: true do |t|\n    t.integer  \"id\"\n    t.integer  \"post_type_id\",       limit: 2,               null: false\n    t.integer  \"accepted_answer_id\"\n    t.integer  \"parent_id\"\n    t.integer  \"user_id\",                                    null: false\n    t.text     \"title\",              limit: 255,             null: false\n    t.text     \"body\",                                       null: false\n    t.integer  \"score\",                          default: 0, null: false\n    t.integer  \"views\",                          default: 1, null: false\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n  end\n\n  create_table \"posts_tags\", force: true do |t|\n    t.integer  \"id\"\n    t.integer \"post_id\", null: false\n    t.integer \"tag_id\",  null: false\n  end\n\n  create_table \"tag_synonyms\", force: true do |t|\n    t.integer  \"id\"\n    t.string \"source_tag\", null: false\n    t.string \"synonym\",    null: false\n  end\n\n  create_table \"tags\", force: true do |t|\n    t.integer  \"id\"\n    t.string \"name\", null: false\n  end\n\n  create_table \"users\", force: true do |t|\n    t.integer  \"id\"\n    t.string   \"first_name\",   limit: 50\n    t.string   \"last_name\",    limit: 50\n    t.string   \"display_name\", limit: 100,             null: false\n    t.string   \"email\",        limit: 100,             null: false\n    t.string   \"password\",                             null: false\n    t.string   \"salt\",                                 null: false\n    t.string   \"about_me\"\n    t.string   \"website_url\"\n    t.string   \"location\",     limit: 100\n    t.integer  \"karma\",                    default: 0, null: false\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n  end\n\n  create_table \"vote_types\", force: true do |t|\n    t.integer  \"id\"\n    t.string \"name\", null: false\n  end\n\n  create_table \"votes\", force: true do |t|\n    t.integer  \"id\"\n    t.integer  \"post_id\",      null: false\n    t.integer  \"vote_type_id\", null: false\n    t.integer  \"user_id\",      null: false\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n  end\n\nHere is the raw structure in SQL as well:\nCREATE TABLE `comments` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `post_id` int(11) NOT NULL,\n  `user_id` int(11) NOT NULL,\n  `body` text NOT NULL,\n  `score` int(11) NOT NULL DEFAULT '0',\n  `created_at` datetime DEFAULT NULL,\n  `updated_at` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `post_types` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `post_type_id` smallint(6) NOT NULL,\n  `accepted_answer_id` int(11) DEFAULT NULL,\n  `parent_id` int(11) DEFAULT NULL,\n  `user_id` int(11) NOT NULL,\n  `title` tinytext NOT NULL,\n  `body` text NOT NULL,\n  `score` int(11) NOT NULL DEFAULT '0',\n  `views` int(11) NOT NULL DEFAULT '1',\n  `created_at` datetime DEFAULT NULL,\n  `updated_at` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `posts_tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `post_id` int(11) NOT NULL,\n  `tag_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `tag_synonyms` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `source_tag` varchar(255) NOT NULL,\n  `synonym` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `first_name` varchar(50) DEFAULT NULL,\n  `last_name` varchar(50) DEFAULT NULL,\n  `display_name` varchar(100) NOT NULL,\n  `email` varchar(100) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  `salt` varchar(255) NOT NULL,\n  `about_me` varchar(255) DEFAULT NULL,\n  `website_url` varchar(255) DEFAULT NULL,\n  `location` varchar(100) DEFAULT NULL,\n  `karma` int(11) NOT NULL DEFAULT '0',\n  `created_at` datetime DEFAULT NULL,\n  `updated_at` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `vote_types` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n);\n\nCREATE TABLE `votes` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `post_id` int(11) NOT NULL,\n  `vote_type_id` int(11) NOT NULL,\n  `user_id` int(11) NOT NULL,\n  `created_at` datetime DEFAULT NULL,\n  `updated_at` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n);\n\nA:\n\nLet's go though a few things here... (now that you actually show the database structure instead of only the Rails 'view', we can see what's happening).....\n\"Relational Databases\" are about \"Relationships\". Relationships are expressed by having queries 'join' two or more tables. The Joins require matching columns on both tables. For example, the post_id on the comment table matches the id on the posts table.\nIf you have some comments and want to find the details of the posts they are on, then you will want to select from the posts table where the comment_id is a certain (set of) values.\nWhen you select on a column, you often (normally) want that column to be indexed.\nSo, for each of your 'primary key' columns you will automatically also have an index. You need to index the 'other' side of the relationship as well.\nComments table\ncreated_at should not be nullable. Nullable columns typically have a small impact on performance. All comments are created, and thus should all have a date, and there is no need for it to be null.\nIf you do queries that select the comments on a particular post, then you need an index on the post_id.\nI suspect you may also have occasional queries for all the posts for a given user, which means you will probably want another index on the user_id\npost_types\nNo problems here.\nPosts\nYou will want indexes on the following:\n\nif you want to select the post for a given parent, parent_id\nif you want to select posts for a given user, then user_id\nif you want to select posts for a given type, then post_type_id\nyou will also want to index the title, since this may make searches easier.\nlook in to full-text indexing for the body.\n\nShould created_date be nullable?\nPost-Tags\nyou will want two indexes here, and for performance reasons, you will probably want them duplicated. Explaining why is beyond this answer, but look for 'index coverage':\n\nindex on both tag_id and post_id\nindex on both post_id and tag_id\n\nTag Synonyms\nsource_tag should be source_id and should be an integer. Also with an index.\nsynonym should be synonym_id and should be an integer. It should also have an index.\nTags\nFine\nUsers\nRecommend an index on:\n\ndisplay_name - so people can find themselves easily (and hopefully you have enough users for it to be needed).\n\n(Are you sure you don't mind the users having no name)\nShould created_date be nullable?\nVote_Types\nfine\nVotes\nvote_type_id, post_id and user_id should each have their own index.\nShould created_date be nullable?\nConclusion\nNow you have some suggestions on what indexes you should start with, the next step is monitoring where your actual performance is poor, and targeting those areas for additional optimization. To do that, you need to actually be running your application, and finding out what your actual queries look like, and running those queries to see what the actual execution plans are, and where those plans look like they need help by adding an index.\n\n - you do not have any primary keys on your database. Primary keys are part of the database's referential integrity, and ensure that you and your programs do the 'right thing'. Additionally, primary keys are implemented as an index, so they will ensure that primary-key-related access to your table is fast.\n - you do not have a post_id column on your post table????? Really? This makes no sense.... unless parent_id is supposed to be the unique identifier.....\n - similarly, you do not have a user_id on the users table. What gives?\nSo, you have no keys, and as a result, you are missing what are normally the most critical indices. Set up each table to have a key and you will be most of the way there.\nMost databases now contain tools that will recommend indexes for you based on queries that you often run.\n\n"
}