{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "1540",
    "text": "Q:\n\nWhat's the simplest way to extend a numpy array in 2 dimensions?\n\nI have a 2d array that looks like this:\nXX\nxx\n\nWhat's the most efficient way to add an extra row and column:\nxxy\nxxy\nyyy\n\nFor bonus points, I'd like to also be able to knock out single rows and columns, so for example in the matrix below I'd like to be able to knock out all of the a's leaving only the x's - specifically I'm trying to delete the nth row and the nth column at the same time - and I want to be able to do this as quickly as possible:\nxxaxx\nxxaxx\naaaaa\nxxaxx\nxxaxx\n\nA:\n\nThe shortest in terms of lines of code i can think of is for the first question.\n>>> import numpy as np\n>>> p = np.array([[1,2],[3,4]])\n\n>>> p = np.append(p, [[5,6]], 0)\n>>> p = np.append(p, [[7],[8],[9]],1)\n\n>>> p\narray([[1, 2, 7],\n   [3, 4, 8],\n   [5, 6, 9]])\n\nAnd the for the second question\n    p = np.array(range(20))\n>>> p.shape = (4,5)\n>>> p\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14],\n       [15, 16, 17, 18, 19]])\n>>> n = 2\n>>> p = np.append(p[:n],p[n+1:],0)\n>>> p = np.append(p[...,:n],p[...,n+1:],1)\n>>> p\narray([[ 0,  1,  3,  4],\n       [ 5,  6,  8,  9],\n       [15, 16, 18, 19]])\n\nA:\n\nA useful alternative answer to the first question, using the examples from tomeedee\u2019s answer, would be to use numpy\u2019s vstack and column_stack methods:\nGiven a matrix p,\n>>> import numpy as np\n>>> p = np.array([ [1,2] , [3,4] ])\n\nan augmented matrix can be generated by:\n>>> p = np.vstack( [ p , [5 , 6] ] )\n>>> p = np.column_stack( [ p , [ 7 , 8 , 9 ] ] )\n>>> p\narray([[1, 2, 7],\n       [3, 4, 8],\n       [5, 6, 9]])\n\nThese methods may be convenient in practice than np.append() as they allow 1D arrays to be appended to a matrix without any modification, in contrast to the following scenario:\n>>> p = np.array([ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] )\n>>> p = np.append( p , [ 7 , 8 , 9 ] , 1 )\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\", line 3234, in append\n    return concatenate((arr, values), axis=axis)\nValueError: arrays must have same number of dimensions\n\nIn answer to the second question, a nice way to remove rows and columns is to use logical array indexing as follows:\nGiven a matrix p,\n>>> p = np.arange( 20 ).reshape( ( 4 , 5 ) )\n\nsuppose we want to remove row 1 and column 2:\n>>> r , c = 1 , 2\n>>> p = p [ np.arange( p.shape[0] ) != r , : ] \n>>> p = p [ : , np.arange( p.shape[1] ) != c ]\n>>> p\narray([[ 0,  1,  3,  4],\n       [10, 11, 13, 14],\n       [15, 16, 18, 19]])\n\nNote - for reformed Matlab users - if you wanted to do these in a one-liner you need to index twice:\n>>> p = np.arange( 20 ).reshape( ( 4 , 5 ) )    \n>>> p = p [ np.arange( p.shape[0] ) != r , : ] [ : , np.arange( p.shape[1] ) != c ]\n\nThis technique can also be extended to remove sets of rows and columns, so if we wanted to remove rows 0 & 2 and columns 1, 2 & 3 we could use numpy's setdiff1d function to generate the desired logical index:\n>>> p = np.arange( 20 ).reshape( ( 4 , 5 ) )\n>>> r = [ 0 , 2 ]\n>>> c = [ 1 , 2 , 3 ]\n>>> p = p [ np.setdiff1d( np.arange( p.shape[0] ), r ) , : ] \n>>> p = p [ : , np.setdiff1d( np.arange( p.shape[1] ) , c ) ]\n>>> p\narray([[ 5,  9],\n       [15, 19]])\n\nA:\n\nAnother elegant solution to the first question may be the insert command:\np = np.array([[1,2],[3,4]])\np = np.insert(p, 2, values=0, axis=1) # insert values before column 2\n\nLeads to:\narray([[1, 2, 0],\n       [3, 4, 0]])\n\ninsert may be slower than append but allows you to fill the whole row/column with one value easily.\nAs for the second question, delete has been suggested before:\np = np.delete(p, 2, axis=1)\n\nWhich restores the original array again:\narray([[1, 2],\n       [3, 4]])\n\n"
}