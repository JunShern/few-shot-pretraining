{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 5 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9664",
    "text": "/*=========================================================================\n *\n *  Copyright NumFOCUS\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0.txt\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *=========================================================================*/\n\n#include \"itkHessianRecursiveGaussianImageFilter.h\"\n\n// This test creates an image varying as a 1D Gaussian in the X direction\n// for different values of sigma, and checks the scale-space response of\n// the xx component of the Hessian at the center of the Gaussian.\n// If NormalizeAcrossScale works correctly, the filter should yield the\n// same Hxx across different scales.\n\nint\nitkHessianRecursiveGaussianFilterScaleSpaceTest(int, char *[])\n{\n  constexpr unsigned int Dimension = 3;\n  using PixelType = double;\n  using ImageType = itk::Image<PixelType, Dimension>;\n  using IndexType = itk::Index<Dimension>;\n  using SizeType = itk::Size<Dimension>;\n  using RegionType = itk::ImageRegion<Dimension>;\n  using PointType = ImageType::PointType;\n  using SpacingType = ImageType::SpacingType;\n\n  ImageType::Pointer inputImage = ImageType::New();\n\n  SizeType size;\n  size.Fill(21);\n  size[0] = 401;\n\n  IndexType start;\n  start.Fill(0);\n\n  RegionType region;\n  region.SetIndex(start);\n  region.SetSize(size);\n\n  PointType origin;\n  origin.Fill(-1.25);\n  origin[0] = -20.0;\n\n  SpacingType spacing;\n  spacing.Fill(0.1);\n\n  inputImage->SetOrigin(origin);\n  inputImage->SetSpacing(spacing);\n\n  inputImage->SetLargestPossibleRegion(region);\n  inputImage->SetBufferedRegion(region);\n  inputImage->SetRequestedRegion(region);\n  inputImage->Allocate();\n\n  using IteratorType = itk::ImageRegionIteratorWithIndex<ImageType>;\n\n  constexpr unsigned int numberOfScales = 4;\n  double                 scales[numberOfScales];\n  scales[0] = 1.0;\n  scales[1] = 2.0;\n  scales[2] = 3.0;\n  scales[3] = 5.0;\n\n  // changing the size of the object with the the size of the\n  // gaussian should produce the same results\n  for (double objectSize : scales)\n  {\n    IteratorType it(inputImage, inputImage->GetRequestedRegion());\n\n    PointType point;\n    // Fill the image with a 1D Gaussian along X with sigma equal to the current scale\n    // The Gaussian is not normalized, since it should have the same peak value across\n    // scales, only sigma should change\n    while (!it.IsAtEnd())\n    {\n      inputImage->TransformIndexToPhysicalPoint(it.GetIndex(), point);\n      double value = std::exp(-point[0] * point[0] / (2.0 * objectSize * objectSize));\n      it.Set(value);\n      ++it;\n    }\n\n    // Compute the hessian using NormalizeAcrossScale true\n    using FilterType = itk::HessianRecursiveGaussianImageFilter<ImageType>;\n\n    using HessianImageType = FilterType::OutputImageType;\n\n    FilterType::Pointer filter = FilterType::New();\n    filter->SetInput(inputImage);\n    filter->SetSigma(objectSize);\n    filter->SetNormalizeAcrossScale(true);\n    filter->Update();\n\n    HessianImageType::Pointer outputImage = filter->GetOutput();\n\n    // Get the value at the center of the image, the location of the peak of the Gaussian\n    PointType center;\n    center.Fill(0.0);\n\n    IndexType centerIndex;\n\n    outputImage->TransformPhysicalPointToIndex(center, centerIndex);\n\n    // Irrespective of the scale, the Hxx component should be the same\n    double centerHxx = outputImage->GetPixel(centerIndex)[0];\n\n    if (centerHxx > -0.3546 || centerHxx < -0.3547)\n    {\n      std::cout << \"center Hessian: \" << outputImage->GetPixel(centerIndex) << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n\n\n  // maintaining the size of the object and gaussian, in physical\n  // size, should maintain the value, while the size of the image changes.\n  for (double scale : scales)\n  {\n    IteratorType it(inputImage, inputImage->GetRequestedRegion());\n\n    PointType point;\n    double    objectSize = 5.0;\n\n    spacing.Fill(scale / 5.0);\n\n    inputImage->SetSpacing(spacing);\n\n    // Fill the image with a 1D Gaussian along X with sigma equal to\n    // the object size.\n    // The Gaussian is not normalized, since it should have the same peak value across\n    // scales, only sigma should change\n    while (!it.IsAtEnd())\n    {\n      inputImage->TransformIndexToPhysicalPoint(it.GetIndex(), point);\n      double value = std::exp(-point[0] * point[0] / (2.0 * objectSize * objectSize));\n      it.Set(value);\n      ++it;\n    }\n\n    // Compute the hessian using NormalizeAcrossScale true\n    using FilterType = itk::HessianRecursiveGaussianImageFilter<ImageType>;\n\n    using HessianImageType = FilterType::OutputImageType;\n\n    FilterType::Pointer filter = FilterType::New();\n    filter->SetInput(inputImage);\n    filter->SetSigma(objectSize);\n    filter->SetNormalizeAcrossScale(true);\n    filter->Update();\n\n    HessianImageType::Pointer outputImage = filter->GetOutput();\n\n    // Get the value at the center of the image, the location of the peak of the Gaussian\n    PointType center;\n    center.Fill(0.0);\n\n    IndexType centerIndex;\n\n    outputImage->TransformPhysicalPointToIndex(center, centerIndex);\n\n    // Irrespective of the scale, the Hxx component should be the same\n    double centerHxx = outputImage->GetPixel(centerIndex)[0];\n\n    if (centerHxx > -0.354 || centerHxx < -0.355)\n    {\n      std::cout << \"center Hessian: \" << outputImage->GetPixel(centerIndex) << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n\n\n  return EXIT_SUCCESS;\n}\n"
}