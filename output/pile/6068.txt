{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "6068",
    "text": "Q:\n\nSleeping for an exact duration\n\nMy understanding of the Sleep function is that it follows \"at least semantics\" i.e. sleep(5) will guarantee that the thread sleeps for 5 seconds, but it may remain blocked for more than 5 seconds depending on other factors. Is there a way to sleep for exactly a specified time period (without busy waiting).\n\nA:\n\nAs others have said, you really need to use a real-time OS to try and achieve this.  Precise software timing is quite tricky.\nHowever... although not perfect, you can get a LOT better results than \"normal\" by simply boosting the priority of the process that needs better timing.  In Windows you can achieve this with the SetPriorityClass function.  If you set the priority to the highest level (REALTIME_PRIORITY_CLASS: 0x00000100) you'll get much better timing results.  Again - this will not be perfect like you are asking for, though.\nThis is also likely possible on other platforms than Windows, but I've never had reason to do it so haven't tested it.\nEDIT:  As per the comment by Andy T, if your app is multi-threaded you also need to watch out for the priority assigned to the threads.  For Windows this is documented here.\n\nSome background...\nA while back I used SetPriorityClass to boost the priority on an application where I was doing real-time analysis of high-speed video and I could NOT miss a frame.  Frames were arriving to the pc at a very regular (driven by external framegrabber HW) frequency of 300 frames per second (fps), which fired a HW interrupt on every frame which I then serviced.  Since timing was very important, I collected a lot of stats on the interrupt timing (using QueryPerformanceCounter stuff) to see how bad the situation really was, and was appalled at the resulting distributions.  I don't have the stats handy, but basically Windows was servicing the interrupt whenever it felt like it when run at normal priority.  The histograms were very messy, with the stdev being wider than my ~3ms period.  Frequently I would have gigantic gaps of 200 ms or greater in the interrupt servicing (recall that the interrupt fired roughly every 3 ms)!!  ie: HW interrupts are FAR from exact!  You're stuck with what the OS decides to do for you.\nHowever - when I discovered the REALTIME_PRIORITY_CLASS setting and benchmarked with that priority, it was significantly better and the service interval distribution was extremely tight.  I could run 10 minutes of 300 fps and not miss a single frame.  Measured interrupt servicing periods were pretty much exactly 1/300 s with a tight distribution.\nAlso - try and minimize the other things the OS is doing to help improve the odds of your timing working better in the app where it matters.  eg: no background video transcoding or disk de-fragging or anything while your trying to get precision timing with other code!!\nIn summary:\n\nIf you really need this, go with a real time OS\nIf you can't use a real-time OS (impossible or impractical), boosting your process priority will likely improve your timing by a lot, as it did for me\nHW interrupts won't do it... the OS still needs to decide to service them!\nMake sure that you don't have a lot of other processes running that are competing for OS attention\nIf timing is really important to you, do some testing.  Although getting code to run exactly when you want it to is not very easy, measuring this deviation is quite easy.  The high performance counters in PCs (what you get with QueryPerformanceCounter) are extremely good.\n\nSince it may be helpful (although a bit off topic), here's a small class I wrote a long time ago for using the high performance counters on a Windows machine.  It may be useful for your testing:\nCHiResTimer.h\n#pragma once\n#include \"stdafx.h\"\n#include <windows.h>\n\nclass CHiResTimer\n{\nprivate:\n    LARGE_INTEGER frequency;\n    LARGE_INTEGER startCounts;\n    double ConvertCountsToSeconds(LONGLONG Counts);\npublic:\n    CHiResTimer(); // constructor\n    void ResetTimer(void);\n    double GetElapsedTime_s(void);\n};\n\nCHiResTimer.cpp\n#include \"stdafx.h\"\n#include \"CHiResTimer.h\"\n\ndouble CHiResTimer::ConvertCountsToSeconds(LONGLONG Counts)\n{\n    return ((double)Counts / (double)frequency.QuadPart) ;\n}\n\nCHiResTimer::CHiResTimer()\n{\n    QueryPerformanceFrequency(&frequency);\n    QueryPerformanceCounter(&startCounts); // starts the timer right away\n}\n\nvoid CHiResTimer::ResetTimer()\n{\n    QueryPerformanceCounter(&startCounts); // reset the reference counter\n}\n\ndouble CHiResTimer::GetElapsedTime_s()\n{\n    LARGE_INTEGER countsNow;\n    QueryPerformanceCounter(&countsNow);\n    return ConvertCountsToSeconds(countsNow.QuadPart - startCounts.QuadPart);\n}\n\nA:\n\nNo.\nThe reason it's \"at least semantics\" is because that after those 5 seconds some other thread may be busy.\nEvery thread gets a time slice from the Operating System. The Operating System controls the order in which the threads are run.\nWhen you put a thread to sleep, the OS puts the thread in a waiting list, and when the timer is over the operating system \"Wakes\" the thread.\nThis means that the thread is added back to the active threads list, but it isn't guaranteed that t will be added in first place. (What if 100 threads need to be awaken in that specific second ? Who will go first ?)\n\nA:\n\nWhile standard Linux is not a realtime operating system, the kernel developers pay close attention to how long a high priority process would remain starved while kernel locks are held. Thus, a stock Linux kernel is usually good enough for many soft-realtime applications.\nYou can schedule your process as a realtime task with the sched_setscheduler(2) call, using either SCHED_FIFO or SCHED_RR. The two have slight differences in semantics, but it may be enough to know that a SCHED_RR task will eventually relinquish the processor to another task of the same priority due to time slices, while a SCHED_FIFO task will only relinquish the CPU to another task of the same priority due to blocking I/O or an explicit call to sched_yield(2).\nBe careful when using realtime scheduled tasks; as they always take priority over standard tasks, you can easily find yourself coding an infinite loop that never relinquishes the CPU and blocks admins from using ssh to kill the process. So it might not hurt to run an sshd at a higher realtime priority, at least until you're sure you've fixed the worst bugs.\nThere are variants of Linux available that have been worked on to provide hard-realtime guarantees. RTLinux has commercial support; Xenomai and RTAI are competing implementations of realtime extensions for Linux, but I know nothing else about them.\n\n"
}