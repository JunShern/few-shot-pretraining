{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 14 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "737",
    "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cassandra.io.util;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\n\nimport org.apache.cassandra.utils.ByteBufferUtil;\n\n/*\n * This file has been modified from Apache Harmony's ByteArrayOutputStream\n * implementation. The synchronized methods of the original have been\n * replaced by non-synchronized methods. This makes certain operations\n * much FASTer, but also *not thread-safe*.\n *\n * This file remains formatted the same as the Apache Harmony original to\n * make patching easier if any bug fixes are made to the Harmony version.\n */\n\n/**\n * A specialized {@link OutputStream} for class for writing content to an\n * (internal) byte array. As bytes are written to this stream, the byte array\n * may be expanded to hold more bytes. When the writing is considered to be\n * finished, a copy of the byte array can be requested from the class.\n *\n * @see ByteArrayOutputStream\n */\npublic class FastByteArrayOutputStream extends OutputStream {\n    /**\n     * The byte array containing the bytes written.\n     */\n    protected byte[] buf;\n\n    /**\n     * The number of bytes written.\n     */\n    protected int count;\n\n    /**\n     * Constructs a new ByteArrayOutputStream with a default size of 32 bytes.\n     * If more than 32 bytes are written to this instance, the underlying byte\n     * array will expand.\n     */\n    public FastByteArrayOutputStream() {\n        buf = new byte[32];\n    }\n\n    /**\n     * Constructs a new {@code ByteArrayOutputStream} with a default size of\n     * {@code size} bytes. If more than {@code size} bytes are written to this\n     * instance, the underlying byte array will expand.\n     *\n     * @param size\n     *            initial size for the underlying byte array, must be\n     *            non-negative.\n     * @throws IllegalArgumentException\n     *             if {@code size} < 0.\n     */\n    public FastByteArrayOutputStream(int size) {\n        if (size >= 0) {\n            buf = new byte[size];\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * Closes this stream. This releases system resources used for this stream.\n     *\n     * @throws IOException\n     *             if an error occurs while attempting to close this stream.\n     */\n    @Override\n    public void close() throws IOException {\n        /**\n         * Although the spec claims \"A closed stream cannot perform output\n         * operations and cannot be reopened.\", this implementation must do\n         * nothing.\n         */\n        super.close();\n    }\n\n    private void expand(int i) {\n        /* Can the buffer handle @i more bytes, if not expand it */\n        if (count + i <= buf.length) {\n            return;\n        }\n\n        long expectedExtent = (count + i) * 2L; //long to deal with possible int overflow\n        int newSize = (int) Math.min(Integer.MAX_VALUE - 8, expectedExtent); // MAX_ARRAY_SIZE\n        byte[] newbuf = new byte[newSize];\n        System.arraycopy(buf, 0, newbuf, 0, count);\n        buf = newbuf;\n    }\n\n    /**\n     * Resets this stream to the beginning of the underlying byte array. All\n     * subsequent writes will overwrite any bytes previously stored in this\n     * stream.\n     */\n    public void reset() {\n        count = 0;\n    }\n\n    /**\n     * Returns the total number of bytes written to this stream so far.\n     *\n     * @return the number of bytes written to this stream.\n     */\n    public int size() {\n        return count;\n    }\n\n    /**\n     * Returns the contents of this ByteArrayOutputStream as a byte array. Any\n     * changes made to the receiver after returning will not be reflected in the\n     * byte array returned to the caller.\n     *\n     * @return this stream's current contents as a byte array.\n     */\n    public byte[] toByteArray() {\n        byte[] newArray = new byte[count];\n        System.arraycopy(buf, 0, newArray, 0, count);\n        return newArray;\n    }\n\n    /**\n     * Returns the contents of this ByteArrayOutputStream as a string. Any\n     * changes made to the receiver after returning will not be reflected in the\n     * string returned to the caller.\n     *\n     * @return this stream's current contents as a string.\n     */\n\n    @Override\n    public String toString() {\n        return new String(buf, 0, count);\n    }\n\n    /**\n     * Returns the contents of this ByteArrayOutputStream as a string. Each byte\n     * {@code b} in this stream is converted to a character {@code c} using the\n     * following function:\n     * {@code c == (char)(((hibyte & 0xff) << 8) | (b & 0xff))}. This method is\n     * deprecated and either {@link #toString()} or {@link #toString(String)}\n     * should be used.\n     *\n     * @param hibyte\n     *            the high byte of each resulting Unicode character.\n     * @return this stream's current contents as a string with the high byte set\n     *         to {@code hibyte}.\n     * @deprecated Use {@link #toString()}.\n     */\n    @Deprecated\n    public String toString(int hibyte) {\n        char[] newBuf = new char[size()];\n        for (int i = 0; i < newBuf.length; i++) {\n            newBuf[i] = (char) (((hibyte & 0xff) << 8) | (buf[i] & 0xff));\n        }\n        return new String(newBuf);\n    }\n\n    /**\n     * Returns the contents of this ByteArrayOutputStream as a string converted\n     * according to the encoding declared in {@code enc}.\n     *\n     * @param enc\n     *            a string representing the encoding to use when translating\n     *            this stream to a string.\n     * @return this stream's current contents as an encoded string.\n     * @throws UnsupportedEncodingException\n     *             if the provided encoding is not supported.\n     */\n    public String toString(String enc) throws UnsupportedEncodingException {\n        return new String(buf, 0, count, enc);\n    }\n\n    /**\n     * Writes {@code count} bytes from the byte array {@code buffer} starting at\n     * offset {@code index} to this stream.\n     *\n     * @param buffer\n     *            the buffer to be written.\n     * @param offset\n     *            the initial position in {@code buffer} to retrieve bytes.\n     * @param len\n     *            the number of bytes of {@code buffer} to write.\n     * @throws NullPointerException\n     *             if {@code buffer} is {@code null}.\n     * @throws IndexOutOfBoundsException\n     *             if {@code offset < 0} or {@code len < 0}, or if\n     *             {@code offset + len} is greater than the length of\n     *             {@code buffer}.\n     */\n    @Override\n    public void write(byte[] buffer, int offset, int len) {\n        // avoid int overflow\n        if (offset < 0 || offset > buffer.length || len < 0\n                || len > buffer.length - offset\n                || this.count + len < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (len == 0) {\n            return;\n        }\n\n        /* Expand if necessary */\n        expand(len);\n        System.arraycopy(buffer, offset, buf, this.count, len);\n        this.count += len;\n    }\n\n    public void write(ByteBuffer buffer)\n    {\n        int len = buffer.remaining();\n        expand(len);\n        ByteBufferUtil.arrayCopy(buffer, buffer.position(), buf, this.count, len);\n        this.count += len;\n    }\n\n    /**\n     * Writes the specified byte {@code oneByte} to the OutputStream. Only the\n     * low order byte of {@code oneByte} is written.\n     *\n     * @param oneByte\n     *            the byte to be written.\n     */\n    @Override\n    public void write(int oneByte) {\n        if (count == buf.length) {\n            expand(1);\n        }\n        buf[count++] = (byte) oneByte;\n    }\n\n    /**\n     * Takes the contents of this stream and writes it to the output stream\n     * {@code out}.\n     *\n     * @param out\n     *            an OutputStream on which to write the contents of this stream.\n     * @throws IOException\n     *             if an error occurs while writing to {@code out}.\n     */\n    public void writeTo(OutputStream out) throws IOException {\n        out.write(buf, 0, count);\n    }\n}\n"
}