{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "1294",
    "text": "Q:\n\nWhat is proper way to stream media with Spring MVC\n\nI have a controller method that simply streams bytes for media (images, css, js, etc.) to the client. I first tried something like this:\n@RequestMapping(value=\"/path/to/media/**\", method=RequestMethod.GET)\n@ResponseBody\npublic byte[] getMedia(HttpServletRequest request) throws IOException\n{\n    //logic for getting path to media on server\n\n    return Files.readAllBytes(Paths.get(serverPathToMedia));\n}\n\nI originally tested this in Firefox, and it all seemed to work fine. However, I then tried it in Chrome, and then found that none of the images work. So, I then changed it to something like this:\n@RequestMapping(value=\"/path/to/media/**\", method=RequestMethod.GET)\npublic ResponseEntity<byte[]> getMedia(HttpServletRequest request) throws IOException\n{\n    //logic for getting path to media on server\n\n    byte[] bytes = Files.readAllBytes(Paths.get(serverPathToMedia));\n    //logic for setting some header values like Content-Type and Content-Length\n    return new ResponseEntity<byte[]>(bytes, headers, HttpStatus.OK);\n}\n\nThis gave the same results as before. I saw in the developer tools that my response headers were coming down as expected, but still no image bytes\nNext I tried something like this:\n@RequestMapping(value=\"/path/to/media/**\", method=RequestMethod.GET)\npublic void getMedia(HttpServletRequest request, HttpServletResponse response) throws IOException\n{\n    //logic for getting path to media on server\n\n    byte[] bytes = Files.readAllBytes(Paths.get(serverPathToMedia));\n    response.getOutputStream().write(bytes);\n}\n\nWithout even setting any response headers, this works in Firefox and Chrome. Now, while I can just do it this last way since it works, this doesn't seem like the correct Spring MVC way. I want to know why the first two things I tried didn't work, as they seem more correct. Also, is there something I didn't try that would actually be the right way to do this?\n\nA:\n\nYour last approach is pretty much the way to go about it. The only change that I can suggest is to not keep the entire content file to be streamed in memory, instead to stream out the content with buffering - IOUtils from Apache commons can do this for you.\n\n"
}