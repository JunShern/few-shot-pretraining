{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains [\" * top of that the exposed restrictions are too simple for today's hardware, and (0.193)\"]."
        }
    ],
    "doc_id": "9718",
    "text": "/*\n * Copyright (c) 2016 Intel Corporation\n *\n * Permission to use, copy, modify, distribute, and sell this software and its\n * documentation for any purpose is hereby granted without fee, provided that\n * the above copyright notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting documentation, and\n * that the name of the copyright holders not be used in advertising or\n * publicity pertaining to distribution of the software without specific,\n * written prior permission.  The copyright holders make no representations\n * about the suitability of this software for any purpose.  It is provided \"as\n * is\" without express or implied warranty.\n *\n * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n * OF THIS SOFTWARE.\n */\n\n#include <linux/export.h>\n#include <drm/drmP.h>\n#include <drm/drm_encoder.h>\n\n#include \"drm_crtc_internal.h\"\n\n/**\n * DOC: overview\n *\n * Encoders represent the connecting element between the CRTC (as the overall\n * pixel pipeline, represented by &struct drm_crtc) and the connectors (as the\n * generic sink entity, represented by &struct drm_connector). An encoder takes\n * pixel data from a CRTC and converts it to a format suitable for any attached\n * connector. Encoders are objects exposed to userspace, originally to allow\n * userspace to infer cloning and connector/CRTC restrictions. Unfortunately\n * almost all drivers get this wrong, making the uabi pretty much useless. On\n * top of that the exposed restrictions are too simple for today's hardware, and\n * the recommended way to infer restrictions is by using the\n * DRM_MODE_ATOMIC_TEST_ONLY flag for the atomic IOCTL.\n *\n * Otherwise encoders aren't used in the uapi at all (any modeset request from\n * userspace directly connects a connector with a CRTC), drivers are therefore\n * free to use them however they wish. Modeset helper libraries make strong use\n * of encoders to facilitate code sharing. But for more complex settings it is\n * usually better to move shared code into a separate &drm_bridge. Compared to\n * encoders, bridges also have the benefit of being purely an internal\n * abstraction since they are not exposed to userspace at all.\n *\n * Encoders are initialized with drm_encoder_init() and cleaned up using\n * drm_encoder_cleanup().\n */\nstatic const struct drm_prop_enum_list drm_encoder_enum_list[] = {\n\t{ DRM_MODE_ENCODER_NONE, \"None\" },\n\t{ DRM_MODE_ENCODER_DAC, \"DAC\" },\n\t{ DRM_MODE_ENCODER_TMDS, \"TMDS\" },\n\t{ DRM_MODE_ENCODER_LVDS, \"LVDS\" },\n\t{ DRM_MODE_ENCODER_TVDAC, \"TV\" },\n\t{ DRM_MODE_ENCODER_VIRTUAL, \"Virtual\" },\n\t{ DRM_MODE_ENCODER_DSI, \"DSI\" },\n\t{ DRM_MODE_ENCODER_DPMST, \"DP MST\" },\n\t{ DRM_MODE_ENCODER_DPI, \"DPI\" },\n};\n\nint drm_encoder_register_all(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tif (encoder->funcs->late_register)\n\t\t\tret = encoder->funcs->late_register(encoder);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid drm_encoder_unregister_all(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\n\tdrm_for_each_encoder(encoder, dev) {\n\t\tif (encoder->funcs->early_unregister)\n\t\t\tencoder->funcs->early_unregister(encoder);\n\t}\n}\n\n/**\n * drm_encoder_init - Init a preallocated encoder\n * @dev: drm device\n * @encoder: the encoder to init\n * @funcs: callbacks for this encoder\n * @encoder_type: user visible type of the encoder\n * @name: printf style format string for the encoder name, or NULL for default name\n *\n * Initialises a preallocated encoder. Encoder should be subclassed as part of\n * driver encoder objects. At driver unload time drm_encoder_cleanup() should be\n * called from the driver's &drm_encoder_funcs.destroy hook.\n *\n * Returns:\n * Zero on success, error code on failure.\n */\nint drm_encoder_init(struct drm_device *dev,\n\t\t     struct drm_encoder *encoder,\n\t\t     const struct drm_encoder_funcs *funcs,\n\t\t     int encoder_type, const char *name, ...)\n{\n\tint ret;\n\n\tret = drm_mode_object_add(dev, &encoder->base, DRM_MODE_OBJECT_ENCODER);\n\tif (ret)\n\t\treturn ret;\n\n\tencoder->dev = dev;\n\tencoder->encoder_type = encoder_type;\n\tencoder->funcs = funcs;\n\tif (name) {\n\t\tva_list ap;\n\n\t\tva_start(ap, name);\n\t\tencoder->name = kvasprintf(GFP_KERNEL, name, ap);\n\t\tva_end(ap);\n\t} else {\n\t\tencoder->name = kasprintf(GFP_KERNEL, \"%s-%d\",\n\t\t\t\t\t  drm_encoder_enum_list[encoder_type].name,\n\t\t\t\t\t  encoder->base.id);\n\t}\n\tif (!encoder->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tlist_add_tail(&encoder->head, &dev->mode_config.encoder_list);\n\tencoder->index = dev->mode_config.num_encoder++;\n\nout_put:\n\tif (ret)\n\t\tdrm_mode_object_unregister(dev, &encoder->base);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_encoder_init);\n\n/**\n * drm_encoder_cleanup - cleans up an initialised encoder\n * @encoder: encoder to cleanup\n *\n * Cleans up the encoder but doesn't free the object.\n */\nvoid drm_encoder_cleanup(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\n\t/* Note that the encoder_list is considered to be static; should we\n\t * remove the drm_encoder at runtime we would have to decrement all\n\t * the indices on the drm_encoder after us in the encoder_list.\n\t */\n\n\tif (encoder->bridge) {\n\t\tstruct drm_bridge *bridge = encoder->bridge;\n\t\tstruct drm_bridge *next;\n\n\t\twhile (bridge) {\n\t\t\tnext = bridge->next;\n\t\t\tdrm_bridge_detach(bridge);\n\t\t\tbridge = next;\n\t\t}\n\t}\n\n\tdrm_mode_object_unregister(dev, &encoder->base);\n\tkfree(encoder->name);\n\tlist_del(&encoder->head);\n\tdev->mode_config.num_encoder--;\n\n\tmemset(encoder, 0, sizeof(*encoder));\n}\nEXPORT_SYMBOL(drm_encoder_cleanup);\n\nstatic struct drm_crtc *drm_encoder_get_crtc(struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_device *dev = encoder->dev;\n\tbool uses_atomic = false;\n\tstruct drm_connector_list_iter conn_iter;\n\n\t/* For atomic drivers only state objects are synchronously updated and\n\t * protected by modeset locks, so check those first. */\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (!connector->state)\n\t\t\tcontinue;\n\n\t\tuses_atomic = true;\n\n\t\tif (connector->state->best_encoder != encoder)\n\t\t\tcontinue;\n\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\treturn connector->state->crtc;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t/* Don't return stale data (e.g. pending async disable). */\n\tif (uses_atomic)\n\t\treturn NULL;\n\n\treturn encoder->crtc;\n}\n\nint drm_mode_getencoder(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_mode_get_encoder *enc_resp = data;\n\tstruct drm_encoder *encoder;\n\tstruct drm_crtc *crtc;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tencoder = drm_encoder_find(dev, file_priv, enc_resp->encoder_id);\n\tif (!encoder)\n\t\treturn -ENOENT;\n\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tcrtc = drm_encoder_get_crtc(encoder);\n\tif (crtc && drm_lease_held(file_priv, crtc->base.id))\n\t\tenc_resp->crtc_id = crtc->base.id;\n\telse\n\t\tenc_resp->crtc_id = 0;\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n\n\tenc_resp->encoder_type = encoder->encoder_type;\n\tenc_resp->encoder_id = encoder->base.id;\n\tenc_resp->possible_crtcs = drm_lease_filter_crtcs(file_priv,\n\t\t\t\t\t\t\t  encoder->possible_crtcs);\n\tenc_resp->possible_clones = encoder->possible_clones;\n\n\treturn 0;\n}\n"
}