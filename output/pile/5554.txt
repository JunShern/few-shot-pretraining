{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "5554",
    "text": "Q:\n\nProper way to use @Transactional on a service\n\nI have a service, which uses multiple DAOs to do a unit of work like following. The DAOs fetch the data/save by creating a session and commit. In that case, why do  i need to have transactional on the service when the dao is managing the session by itself? If something goes wrong in the second DAO, the data in the first DAO is already commited, how do I get around this situation?\n@Transactional\npublic boolean testService(SomeObject obj){\n\n     userDao.save(obj.getUser()); // this dao gets the session from sessino factory and commits there itself.\n     addressDao.save(obj.getAddress()); // something fails here, and the above line has already commited the data, so the data is not Atomic.\n\n     return true;\n}\n\nA:\n\nUsually you don't put @Transactional in your DAO layer but in your service layer.\nSo I suggest you remove @Transactional from you DAOs and keep the one in your service.\nIn that case, if something goes wrong in any of your DAO everything will be rollback.\nBut It's up to you where you want the transaction to start and to finish.\n\n"
}