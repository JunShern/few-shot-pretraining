{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains For example."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": true,
            "reason": "Text contains ['Here are a couple functions that will give you a nicer syntax and prevent these types of problems: (0.179)']."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['Here are two functions which copy the contents of a REALSQLDatabase to an In-Memory database and also the reverse going back out to disk, no matter what the schema is: (0.189)', 'These functions could be modified to take an array of table names if you want to only copy over specific tables. (0.199)', 'Here are a couple functions that will give you a nicer syntax and prevent these types of problems: (0.151)']."
        }
    ],
    "doc_id": "7969",
    "text": "21. Using null values with your databases. SQL databases have a concept of a NULL value which indicates that there is not a value in that column. NULL is different than an empty string '' or a 0, since these are both actual values.\n\nOne thing to remember about nulls is that two nulls are not alike since they do not actually contain a value. This means that null does not equal null. It is almost like each null value is a separate instance of a class, they may look the same but they don't compare.\n\nA common mistake is to treat nulls like any other value in SQL:\n\nselect * from people where pet = null\n\nThis will not return any results, even if there are null values in the pet column, because of the note above. The null value contained in the pet column is not the same as the literal null value in the SQL. In order to check to see if the value is a null value, then you have to use the IS NULL operator. Going back to the class reference, this is like using the ISA operator on a class in REALbasic:\n\nselect * from people where pet is null\n\nTo get values where the value is not a null value then you can use the opposite:\n\nselect * from people where pet is not null\n\nNow, you have your data in a RecordSet class, but you need to check to see if the value is null or assign to it. The DatabaseField.Value (you get a DatabaseField from RecordSet.IdxField or RecordSet.Field) property returns a variant that holds the value in the field. The Variant class has an IsNull property which allows you to determine if the value is null or set the value to null.\n\nWhen inserting a record with the DatabaseRecord class, if you want to insert a null value, then you can just leave that value out of the DatabaseRecord and the engine will use the default value for that column, which is null unless otherwise specified in the schema.\n\n22. I've seen a number of people looking to move data from a physicaly database to an in-memory database, or the reverse. Here are two functions which copy the contents of a REALSQLDatabase to an In-Memory database and also the reverse going back out to disk, no matter what the schema is:\n\nFunction CopyToDisk(extends memdb as realSQLDatabase, file as folderItem) Asboolean// Copy the contents of an in-memory database to disk\n\nThese functions could be modified to take an array of table names if you want to only copy over specific tables. These functions do not transfer over indexes, triggers, etc, but that would not be difficult to add. You can get the sql command for those in the same manner that the table sql is retrieved.\n\n23. REALbasic and REAL Server both use the SQLite database engine. Often times people want to know which specific version of the SQLite engine is included with certain releases. To find this out connect to your database and run the following SQL command:\n\n24. Tip 10 shows a very basic way to add data into a SQL command with the ReplaceAll function, however this can be problematic. If the string being placed into the SQL command has a similar placeholder (?2) then you could end up with corrupt data in your SQL command.\n\nHere are a couple functions that will give you a nicer syntax and prevent these types of problems:\n\nProtectedFunction BindSQLData(sql asstring, values() asstring) Asstring// Bind data into a SQL command in place identified by a question mark placeholder '?'. The// placeholder can either be enclosed in quotes or not.// The data can either be provided as a single array or multiple parameters to the function.// A value of chr(0) will be set to null in the SQL command.\n\n// Now loop through all the chunks and add in the data.dim i, dataIdx asintegerfor i = 0to ubound( chunks )// Get the next chunk of datadim chunk asstring = chunks(i)dim nextChar asstring = left( chunk, 1 )\n\n// Get the data value to bind in this position.dim value asstringif i > 0then// Skip the first chunk since there isn't a value preceeding the statement value = \"null\"// Default to null if there is no data.\n\nif dataIdx <= ubound( values ) then// Make sure we have data for this chunk value = values( dataIdx )\n\n// Add the new data to the sql command result = result + value + chunknext\n\nreturn resultEndFunction\n\nTo uses these functions you simply write your SQL command with a question mark in places where the data will be placed, then you call the BindSQLData function with either an array of values or a param array. For example:"
}