{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 6 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['    may perform better for some inputs (in particular when the number of (0.176)']."
        }
    ],
    "doc_id": "3759",
    "text": "\"\"\"Imported from the recipes section of the itertools documentation.\n\nAll functions taken from the recipes section of the itertools library docs\n[1]_.\nSome backward-compatible usability improvements have been made.\n\n.. [1] http://docs.python.org/library/itertools.html#recipes\n\n\"\"\"\nfrom collections import deque\nfrom itertools import (\n    chain, combinations, count, cycle, groupby, islice, repeat, starmap, tee\n)\nimport operator\nfrom random import randrange, sample, choice\n\nfrom six import PY2\nfrom six.moves import filter, filterfalse, map, range, zip, zip_longest\n\n__all__ = [\n    'accumulate',\n    'all_equal',\n    'consume',\n    'dotproduct',\n    'first_true',\n    'flatten',\n    'grouper',\n    'iter_except',\n    'ncycles',\n    'nth',\n    'nth_combination',\n    'padnone',\n    'pairwise',\n    'partition',\n    'powerset',\n    'prepend',\n    'quantify',\n    'random_combination_with_replacement',\n    'random_combination',\n    'random_permutation',\n    'random_product',\n    'repeatfunc',\n    'roundrobin',\n    'tabulate',\n    'tail',\n    'take',\n    'unique_everseen',\n    'unique_justseen',\n]\n\n\ndef accumulate(iterable, func=operator.add):\n    \"\"\"\n    Return an iterator whose items are the accumulated results of a function\n    (specified by the optional *func* argument) that takes two arguments.\n    By default, returns accumulated sums with :func:`operator.add`.\n\n        >>> list(accumulate([1, 2, 3, 4, 5]))  # Running sum\n        [1, 3, 6, 10, 15]\n        >>> list(accumulate([1, 2, 3], func=operator.mul))  # Running product\n        [1, 2, 6]\n        >>> list(accumulate([0, 1, -1, 2, 3, 2], func=max))  # Running maximum\n        [0, 1, 1, 2, 3, 3]\n\n    This function is available in the ``itertools`` module for Python 3.2 and\n    greater.\n\n    \"\"\"\n    it = iter(iterable)\n    try:\n        total = next(it)\n    except StopIteration:\n        return\n    else:\n        yield total\n\n    for element in it:\n        total = func(total, element)\n        yield total\n\n\ndef take(n, iterable):\n    \"\"\"Return first *n* items of the iterable as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n        >>> take(5, range(3))\n        [0, 1, 2]\n\n    Effectively a short replacement for ``next`` based iterator consumption\n    when you want more than one item, but less than the whole iterator.\n\n    \"\"\"\n    return list(islice(iterable, n))\n\n\ndef tabulate(function, start=0):\n    \"\"\"Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    \"\"\"\n    return map(function, count(start))\n\n\ndef tail(n, iterable):\n    \"\"\"Return an iterator over the last *n* items of *iterable*.\n\n        >>> t = tail(3, 'ABCDEFG')\n        >>> list(t)\n        ['E', 'F', 'G']\n\n    \"\"\"\n    return iter(deque(iterable, maxlen=n))\n\n\ndef consume(iterator, n=None):\n    \"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    \"\"\"\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)\n\n\ndef nth(iterable, n, default=None):\n    \"\"\"Returns the nth item or a default value.\n\n        >>> l = range(10)\n        >>> nth(l, 3)\n        3\n        >>> nth(l, 20, \"zebra\")\n        'zebra'\n\n    \"\"\"\n    return next(islice(iterable, n, None), default)\n\n\ndef all_equal(iterable):\n    \"\"\"\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    \"\"\"\n    g = groupby(iterable)\n    return next(g, True) and not next(g, False)\n\n\ndef quantify(iterable, pred=bool):\n    \"\"\"Return the how many times the predicate is true.\n\n        >>> quantify([True, False, True])\n        2\n\n    \"\"\"\n    return sum(map(pred, iterable))\n\n\ndef padnone(iterable):\n    \"\"\"Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, padnone(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    \"\"\"\n    return chain(iterable, repeat(None))\n\n\ndef ncycles(iterable, n):\n    \"\"\"Returns the sequence elements *n* times\n\n        >>> list(ncycles([\"a\", \"b\"], 3))\n        ['a', 'b', 'a', 'b', 'a', 'b']\n\n    \"\"\"\n    return chain.from_iterable(repeat(tuple(iterable), n))\n\n\ndef dotproduct(vec1, vec2):\n    \"\"\"Returns the dot product of the two iterables.\n\n        >>> dotproduct([10, 10], [20, 20])\n        400\n\n    \"\"\"\n    return sum(map(operator.mul, vec1, vec2))\n\n\ndef flatten(listOfLists):\n    \"\"\"Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    \"\"\"\n    return chain.from_iterable(listOfLists)\n\n\ndef repeatfunc(func, times=None, *args):\n    \"\"\"Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    \"\"\"\n    if times is None:\n        return starmap(func, repeat(args))\n    return starmap(func, repeat(args, times))\n\n\ndef pairwise(iterable):\n    \"\"\"Returns an iterator of paired items, overlapping, from the original\n\n        >>> take(4, pairwise(count()))\n        [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n    \"\"\"\n    a, b = tee(iterable)\n    next(b, None)\n    return zip(a, b)\n\n\ndef grouper(n, iterable, fillvalue=None):\n    \"\"\"Collect data into fixed-length chunks or blocks.\n\n        >>> list(grouper(3, 'ABCDEFG', 'x'))\n        [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    \"\"\"\n    args = [iter(iterable)] * n\n    return zip_longest(fillvalue=fillvalue, *args)\n\n\ndef roundrobin(*iterables):\n    \"\"\"Yields an item from each iterable, alternating between them.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    \"\"\"\n    # Recipe credited to George Sakkis\n    pending = len(iterables)\n    if PY2:\n        nexts = cycle(iter(it).next for it in iterables)\n    else:\n        nexts = cycle(iter(it).__next__ for it in iterables)\n    while pending:\n        try:\n            for next in nexts:\n                yield next()\n        except StopIteration:\n            pending -= 1\n            nexts = cycle(islice(nexts, pending))\n\n\ndef partition(pred, iterable):\n    \"\"\"\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    \"\"\"\n    # partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9\n    t1, t2 = tee(iterable)\n    return filterfalse(pred, t1), filter(pred, t2)\n\n\ndef powerset(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output. Use :func:`unique_everseen` on the input to avoid generating\n    duplicates:\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n        >>> from more_itertools import unique_everseen\n        >>> list(powerset(unique_everseen(seq)))\n        [(), (1,), (0,), (1, 0)]\n\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    if key is None:\n        for element in iterable:\n            try:\n                if element not in seenset:\n                    seenset_add(element)\n                    yield element\n            except TypeError:\n                if element not in seenlist:\n                    seenlist_add(element)\n                    yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            try:\n                if k not in seenset:\n                    seenset_add(k)\n                    yield element\n            except TypeError:\n                if k not in seenlist:\n                    seenlist_add(k)\n                    yield element\n\n\ndef unique_justseen(iterable, key=None):\n    \"\"\"Yields elements in order, ignoring serial duplicates\n\n        >>> list(unique_justseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D', 'A', 'B']\n        >>> list(unique_justseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'A', 'D']\n\n    \"\"\"\n    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))\n\n\ndef iter_except(func, exception, first=None):\n    \"\"\"Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    \"\"\"\n    try:\n        if first is not None:\n            yield first()\n        while 1:\n            yield func()\n    except exception:\n        pass\n\n\ndef first_true(iterable, default=None, pred=None):\n    \"\"\"\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    \"\"\"\n    return next(filter(pred, iterable), default)\n\n\ndef random_product(*args, **kwds):\n    \"\"\"Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, **kwarg)``.\n\n    \"\"\"\n    pools = [tuple(pool) for pool in args] * kwds.get('repeat', 1)\n    return tuple(choice(pool) for pool in pools)\n\n\ndef random_permutation(iterable, r=None):\n    \"\"\"Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    r = len(pool) if r is None else r\n    return tuple(sample(pool, r))\n\n\ndef random_combination(iterable, r):\n    \"\"\"Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(sample(range(n), r))\n    return tuple(pool[i] for i in indices)\n\n\ndef random_combination_with_replacement(iterable, r):\n    \"\"\"Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(randrange(n) for i in range(r))\n    return tuple(pool[i] for i in indices)\n\n\ndef nth_combination(iterable, r, index):\n    \"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)\n\n\ndef prepend(value, iterator):\n    \"\"\"Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`.\n\n    \"\"\"\n    return chain([value], iterator)\n"
}