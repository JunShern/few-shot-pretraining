{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4579",
    "text": "Q:\n\nNHibernate QueryOver with SelectList\n\nI have multiple queries against one table. As not all columns/properties are needed I specify the columns with the help of select list. Take the following method as example. This method is working\npublic IEnumerable<ResultDto> GetEntityAsDto(eStatusBinderProduktion fromState, eStatusBinderProduktion toState)\n{\n    EntityClass entityAlias = null;\n    ResultDto resultAlias = null;\n\n    var query = Session.QueryOver<EntityClass>(() => entityAlias)\n      .Where(() => entityAlias.ProduktionStatus >= (byte)fromState)\n      .And(() => entityAlias.ProduktionStatus <= (byte)toState);\n\n    query.SelectList(list => list\n         .Select(() => entityAlias.PrimaryID).WithAlias(() => resultAlias.PrimaryID)\n         .Select(() => entityAlias.SecondaryID).WithAlias(() => resultAlias.SecondaryID)\n         );\n\n    return query.TransformUsing(Transformers.AliasToBean<ResultDto>())\n          .List<ResultDto>();\n}\n\nAs I need to define the SelectList in multiple methods, I tried to to move the SelectList into a separate method. \nThe following code is not working, NHibernate throws the exception \n\nNHibernate.QueryException: 'could not resolve property: entity.PrimaryID of:  MyProjectNamespace.DAL.Interfaces.Entities.EntityClass'\n  \"\n\npublic IEnumerable<ResultDto> GetEntityAsDto(eStatusBinderProduktion fromState, eStatusBinderProduktion toState)\n{\n    EntityClass entityAlias = null;\n    ResultDto resultAlias = null;\n\n    var query = Session.QueryOver<EntityClass>(() => entityAlias)\n      .Where(() => entityAlias.ProduktionStatus >= (byte)fromState)\n      .And(() => entityAlias.ProduktionStatus <= (byte)toState);\n\n    MapPropertiesOfEntityToResult(entityAlias, resultAlias, query);\n\n    return query.TransformUsing(Transformers.AliasToBean<ResultDto>())\n          .List<ResultDto>();\n}\n\nprivate void MapPropertiesOfEntityToResult(EntityClass entity, ResultDto resultAlias, IQueryOver<EntityClass, EntityClass> query)\n{\n  query.SelectList(list => list\n   .Select(() => entity.PrimaryID).WithAlias(() => resultAlias.PrimaryID)\n   .Select(() => entity.SecondaryID).WithAlias(() => resultAlias.SecondaryID)\n    );\n}\n\nAdditional information:\n- The mappings are correct \n- table is filled with test data\n\nA:\n\nWe do not need alias for filling SelectList. We can profit from the Type parameters coming with IQueryOver<TRoot,TSubType>: \n//private void MapPropertiesOfEntityToResult(EntityClass entity\n//   , ResultDto resultAlias, IQueryOver<EntityClass, EntityClass> query)\nprivate void MapPropertiesOfEntityToResult( // no need for entity\n      ResultDto resultAlias, IQueryOver<EntityClass, EntityClass> query)\n{\n  query.SelectList(list => list\n   //.Select(() => entity.PrimaryID).WithAlias(() => resultAlias.PrimaryID)\n   //.Select(() => entity.SecondaryID).WithAlias(() => resultAlias.SecondaryID)\n   .Select(entity => entity.PrimaryID).WithAlias(() => resultAlias.PrimaryID)\n   .Select(entity => entity.SecondaryID).WithAlias(() => resultAlias.SecondaryID)\n    );\n}\n\nThe entity is now a parameter of the passed Function and its type is coming from IQueryOver definition\n\n"
}