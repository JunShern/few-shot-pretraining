{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": true,
            "reason": "Text contains GRE."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2881",
    "text": "// Copyright (c) Microsoft Corporation.  All Rights Reserved.  See License.txt in the project root for license information.\n\n%{\n\n#nowarn \"1182\"  // the generated code often has unused variable \"parseState\"\n\nopen Internal.Utilities\nopen Internal.Utilities.Text\n\nopen FSharp.Compiler.AbstractIL \nopen FSharp.Compiler.AbstractIL.Internal \nopen FSharp.Compiler.AbstractIL.Internal.AsciiConstants \nopen FSharp.Compiler.AbstractIL.Diagnostics \nopen FSharp.Compiler.AbstractIL.Extensions.ILX.Types \nopen FSharp.Compiler.AbstractIL.IL \nopen FSharp.Compiler.AbstractIL.Internal.Library \n\n  \nlet pfailwith s = \n    stderr.WriteLine (\"*** error: \"+s); \n    raise Parsing.RecoverableParseError \n\ntype ResolvedAtMethodSpecScope<'T> = \n    ResolvedAtMethodSpecScope of (ILGenericParameterDefs -> 'T)\n\nlet noMethodSpecScope x = ResolvedAtMethodSpecScope (fun _cgparams -> x)\nlet resolveMethodSpecScope (ResolvedAtMethodSpecScope f) x = f x\nlet resolveMethodSpecScopeThen (ResolvedAtMethodSpecScope f) g = \n  ResolvedAtMethodSpecScope (fun x -> resolveMethodSpecScope (g(f x)) x)\n\nlet resolveCurrentMethodSpecScope obj = \n    resolveMethodSpecScope obj mkILEmptyGenericParams\n\n\nlet findSystemRuntimeAssemblyRef() = \n  match parseILGlobals.primaryAssemblyScopeRef with\n  | ILScopeRef.Assembly aref -> aref\n  | _ -> pfailwith \"systemRuntimeScopeRef not set to valid assembly reference in parseILGlobals\"\n\nlet findAssemblyRef nm = \n  if nm = \"mscorlib\" then findSystemRuntimeAssemblyRef() \n  else\n  pfailwith (\"Undefined assembly ref '\" + nm + \"'\") \n\n%} \n\n/*-----------------------------------------------------------------------\n * The YACC Grammar\n *----------------------------------------------------------------------*/\n\n%token <int64> VAL_INT64     /* 342534523534534      0x34FA434644554 */\n%token <int32> VAL_INT32_ELIPSES     /* 342534523534534... */\n%token <double> VAL_FLOAT64        /* -334234 24E-34 */\n%token <Int32Instr> INSTR_I \n%token <Int32Int32Instr> INSTR_I32_I32\n%token <Int64Instr> INSTR_I8 \n%token <DoubleInstr> INSTR_R \n%token <NoArgInstr> INSTR_NONE \n%token <StringInstr> INSTR_STRING \n%token <TokenInstr> INSTR_TOK \n%token <TypeInstr> INSTR_TYPE \n%token <IntTypeInstr> INSTR_INT_TYPE \n%token <ValueTypeInstr> INSTR_VALUETYPE \n%token <int>     VAL_HEXBYTE    /* 05 1A FA */\n%token <string>  VAL_ID                 /* testing343 */\n%token <string>  VAL_DOTTEDNAME                 /* testing343.abd */\n%token <string>  VAL_QSTRING    /* \"Hello World\\n\" */\n%token <string>  VAL_SQSTRING   /* 'Hello World\\n' */\n%token AMP  \n%token BANG  \n%token BOOL  \n%token BYTEARRAY\n%token CHAR  \n%token CLASS \n%token COMMA  \n%token DCOLON\n%token DEFAULT  \n%token DOT  \n%token ELIPSES\n%token EOF  \n%token EXPLICIT  \n%token FIELD   \n%token FLOAT32  \n%token FLOAT64  \n%token GREATER  \n%token INSTANCE  \n%token INT  \n%token INT16  \n%token INT32  \n%token INT64  \n%token INT8  \n%token LBRACK  \n%token LESS  \n%token LPAREN  \n%token METHOD   \n%token NATIVE  \n%token OBJECT\n%token PLUS\n%token RBRACK\n%token RPAREN   \n%token SLASH\n%token STAR  \n%token STRING  \n%token UINT  \n%token UINT16  \n%token UINT32  \n%token UINT64  \n%token UINT8  \n%token UNMANAGED  \n%token UNSIGNED  \n%token VALUE  \n%token VALUETYPE\n%token VARARG  \n%token VOID  \n\n%type <string> name1 \n%type <ILType ResolvedAtMethodSpecScope> typ\n%type <ILInstr array> ilInstrs\n%type <ILType> ilType\n%start ilInstrs ilType\n\n/**************************************************************************/\n%%      \n\n/* ENTRYPOINT */\nilType: typ EOF\n       { resolveMethodSpecScope $1 [] }\n\n/* ENTRYPOINT */\nilInstrs: instrs2 EOF\n       { Array.ofList $1 }\n\n\ncompQstring: \n     VAL_QSTRING { $1 }\n   | compQstring PLUS VAL_QSTRING { $1 + $3 }\n\nmethodName:  name1 { $1 }\n\ninstrs2: \n   | instr instrs2 \n        { $1 :: $2  } \n   | { [] }\n\ninstr: \n     INSTR_NONE                                         \n        {  ($1 ()) }\n   | INSTR_I int32                                      \n        {  ($1 $2) }\n   | INSTR_I32_I32 int32 int32                                  \n        {  ($1 ($2,$3)) }\n   | INSTR_I8 int64                                     \n        {  ($1 $2) }\n   | INSTR_R float64                                    \n        {  ($1 (ILConst.R8 $2)) }\n   | INSTR_R int64\n        {  ($1 (ILConst.R8 (float $2))) }\n   | INSTR_TYPE typSpec                                 \n        { $1 (resolveCurrentMethodSpecScope $2) }\n   | INSTR_INT_TYPE int32 typSpec                               \n        { $1 ( $2,resolveCurrentMethodSpecScope $3) }\n   | INSTR_VALUETYPE typSpec                            \n        { $1 (resolveCurrentMethodSpecScope $2) }\n   | INSTR_TOK typSpec                          \n        {  ($1 (ILToken.ILType (resolveCurrentMethodSpecScope $2)))  }\n \n/*-----------------------------------------------\n * Type names\n *---------------------------------------------*/\nname1: \n   | id\n        { $1 }\n   | VAL_DOTTEDNAME     \n        { $1 }\n   | name1 DOT id       \n        { $1 + \".\" + $3 }\n\nclassName:\n     LBRACK name1 RBRACK slashedName\n        { let (enc,nm) = $4 \n          let aref = findAssemblyRef $2 \n          ILScopeRef.Assembly aref, enc, nm }\n   | slashedName\n        { let enc, nm = $1 in (ILScopeRef.Local, enc, nm) }\n\nslashedName: \n     name1 \n        { ([],$1) } \n   | name1 SLASH slashedName\n        { let (enc,nm) = $3 in ($1 :: enc, nm)  } \n\ntypeNameInst:\n     className opt_actual_tyargs \n        { let (a,b,c) = $1 \n          resolveMethodSpecScopeThen $2 (fun inst -> \n          noMethodSpecScope ( (mkILTySpec ( (mkILNestedTyRef (a,b,c)), inst)))) }\n\n\ntypeName:\n     className \n        { let (a,b,c) = $1 \n          noMethodSpecScope ( (mkILTySpec ( (mkILNestedTyRef (a,b,c)), []))) }\n\n\ntypSpec: \n     typeName   \n        { resolveMethodSpecScopeThen $1 (fun tref -> \n          noMethodSpecScope (mkILBoxedType tref))  }\n   | typ                \n        { $1 }\n   | LPAREN typ RPAREN  \n        { $2 }\n\n\ncallConv: \n     INSTANCE callKind \n        { Callconv (ILThisConvention.Instance,$2) }\n   | EXPLICIT callKind \n        { Callconv (ILThisConvention.InstanceExplicit,$2) }\n   | callKind \n        { Callconv (ILThisConvention.Static,$1) }\n\ncallKind: \n     /* EMPTY */  \n      { ILArgConvention.Default }\n   | DEFAULT          \n      { ILArgConvention.Default }\n   | VARARG\n      { ILArgConvention.VarArg }\n                \n/*-----------------------------------------------\n * The full algebra of types, typically producing results \n * awaiting further info about how to fix up type\n * variable numbers etc.\n *---------------------------------------------*/\n\ntyp: STRING\n       { noMethodSpecScope parseILGlobals.typ_String } \n   | OBJECT\n       { noMethodSpecScope parseILGlobals.typ_Object } \n   | CLASS typeNameInst\n       { resolveMethodSpecScopeThen $2 (fun tspec -> \n          noMethodSpecScope (mkILBoxedType tspec)) } \n   | VALUE CLASS typeNameInst\n       { resolveMethodSpecScopeThen $3 (fun tspec -> \n         noMethodSpecScope (ILType.Value tspec)) } \n   | VALUETYPE typeNameInst\n       { resolveMethodSpecScopeThen $2 (fun tspec -> \n         noMethodSpecScope (ILType.Value tspec)) } \n   | typ LBRACK RBRACK  \n       { resolveMethodSpecScopeThen $1 (fun ty -> noMethodSpecScope (mkILArr1DTy ty)) } \n   | typ LBRACK bounds1 RBRACK \n       { resolveMethodSpecScopeThen $1 (fun ty -> noMethodSpecScope (mkILArrTy (ty,ILArrayShape $3))) }\n   | typ AMP\n       { resolveMethodSpecScopeThen $1 (fun ty -> noMethodSpecScope (ILType.Byref ty)) }\n   | typ STAR\n       { resolveMethodSpecScopeThen $1 (fun ty -> noMethodSpecScope (ILType.Ptr ty)) }\n   | CHAR\n       { noMethodSpecScope parseILGlobals.typ_Char }\n   | VOID\n       { noMethodSpecScope ILType.Void }\n   | BOOL\n       { noMethodSpecScope parseILGlobals.typ_Bool }\n   | INT8\n       { noMethodSpecScope parseILGlobals.typ_SByte }\n   | INT16              \n       { noMethodSpecScope parseILGlobals.typ_Int16 }\n   | INT32              \n       { noMethodSpecScope parseILGlobals.typ_Int32 }\n   | INT64              \n       { noMethodSpecScope parseILGlobals.typ_Int64 }\n   | FLOAT32            \n       { noMethodSpecScope parseILGlobals.typ_Single }\n   | FLOAT64            \n       { noMethodSpecScope parseILGlobals.typ_Double }\n   | UNSIGNED INT8      \n       { noMethodSpecScope parseILGlobals.typ_Byte }\n   | UNSIGNED INT16     \n       { noMethodSpecScope parseILGlobals.typ_UInt16 }\n   | UNSIGNED INT32     \n       { noMethodSpecScope parseILGlobals.typ_UInt32 }\n   | UNSIGNED INT64     \n       { noMethodSpecScope parseILGlobals.typ_UInt64 }\n   | UINT8      \n       { noMethodSpecScope parseILGlobals.typ_Byte }\n   | UINT16     \n       { noMethodSpecScope parseILGlobals.typ_UInt16 }\n   | UINT32     \n       { noMethodSpecScope parseILGlobals.typ_UInt32 }\n   | UINT64     \n       { noMethodSpecScope parseILGlobals.typ_UInt64 }\n   | NATIVE INT         \n       { noMethodSpecScope parseILGlobals.typ_IntPtr }\n   | NATIVE UNSIGNED INT  \n       { noMethodSpecScope parseILGlobals.typ_UIntPtr }\n   | NATIVE UINT  \n       { noMethodSpecScope parseILGlobals.typ_UIntPtr }\n\n   | BANG int32\n       { noMethodSpecScope (ILType.TypeVar (uint16 ( $2)))  }\n\n\nbounds1:  \n     bound \n       { [$1] }\n   | bounds1 COMMA bound\n       { $1 @ [$3] }\n   \nbound: \n     /*EMPTY*/          \n       { (None, None) } \n   | int32\n       { (None, Some $1) } \n   | int32 ELIPSES int32\n       { (Some $1, Some ($3 - $1 + 1)) }       \n   | int32 ELIPSES\n       { (Some $1, None) } \n/* We need to be able to parse all of */\n/* ldc.r8     0. */\n/* float64(-657435.)     */\n/* and int32[0...,0...] */\n/* The problem is telling an integer-followed-by-ellipses from a floating-point-nubmer-followed-by-dots */\n   | VAL_INT32_ELIPSES int32\n       { (Some $1, Some ($2 - $1 + 1)) }       \n   | VAL_INT32_ELIPSES\n       { (Some $1, None) } \n                                \nid: \n     VAL_ID\n       { $1 }\n   | VAL_SQSTRING\n       { $1 }\n\nint32: \n     VAL_INT64\n       { int32 $1 }\n\nint64: \n     VAL_INT64\n       { $1 }\n\nfloat64: \n     VAL_FLOAT64\n       { $1 }\n   | FLOAT64 LPAREN int64 RPAREN\n       { System.BitConverter.Int64BitsToDouble $3 }\n\nopt_actual_tyargs: \n      /* EMPTY */ \n        { noMethodSpecScope [] }\n   | actual_tyargs \n        { resolveMethodSpecScopeThen $1 (fun res -> \n          noMethodSpecScope  res) }\n\nactual_tyargs:\n     LESS actualTypSpecs GREATER \n        { $2 } \n\nactualTypSpecs: \n     typSpec\n        { resolveMethodSpecScopeThen $1 (fun res -> \n          noMethodSpecScope [ res]) }\n   | actualTypSpecs COMMA typSpec\n        { resolveMethodSpecScopeThen $1 (fun x -> \n          resolveMethodSpecScopeThen $3 (fun y -> \n          noMethodSpecScope (x @ [ y]))) }\n\n"
}