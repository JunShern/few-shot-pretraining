{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 33 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7756",
    "text": "<?php\n/**\n * Zend Framework\n *\n * LICENSE\n *\n * This source file is subject to the new BSD license that is bundled\n * with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * http://framework.zend.com/license/new-bsd\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@zend.com so we can send you a copy immediately.\n *\n * @category   Zend\n * @package    Zend_Soap\n * @copyright  Copyright (c) 2005-2015 Zend Technologies USA Inc. (http://www.zend.com)\n * @license    http://framework.zend.com/license/new-bsd     New BSD License\n * @version    $Id$\n */\n\n/**\n * @see Zend_Soap_Wsdl_Strategy_Interface\n */\n#require_once \"Zend/Soap/Wsdl/Strategy/Interface.php\";\n\n/**\n * @see Zend_Soap_Wsdl_Strategy_Abstract\n */\n#require_once \"Zend/Soap/Wsdl/Strategy/Abstract.php\";\n\n/** @see Zend_Xml_Security */\n#require_once \"Zend/Xml/Security.php\";\n\n/**\n * Zend_Soap_Wsdl\n *\n * @category   Zend\n * @package    Zend_Soap\n */\nclass Zend_Soap_Wsdl\n{\n    /**\n     * @var object DomDocument Instance\n     */\n    private $_dom;\n\n    /**\n     * @var object WSDL Root XML_Tree_Node\n     */\n    private $_wsdl;\n\n    /**\n     * @var string URI where the WSDL will be available\n     */\n    private $_uri;\n\n    /**\n     * @var DOMElement\n     */\n    private $_schema = null;\n\n    /**\n     * Types defined on schema\n     *\n     * @var array\n     */\n    private $_includedTypes = array();\n\n    /**\n     * Strategy for detection of complex types\n     */\n    protected $_strategy = null;\n\n\n    /**\n     * Constructor\n     *\n     * @param string  $name Name of the Web Service being Described\n     * @param string  $uri URI where the WSDL will be available\n     * @param boolean|string|Zend_Soap_Wsdl_Strategy_Interface $strategy\n     */\n    public function __construct($name, $uri, $strategy = true)\n    {\n        if ($uri instanceof Zend_Uri_Http) {\n            $uri = $uri->getUri();\n        }\n        $this->_uri = $uri;\n\n        /**\n         * @todo change DomDocument object creation from cparsing to construxting using API\n         * It also should authomatically escape $name and $uri values if necessary\n         */\n        $wsdl = \"<?xml version='1.0' ?>\n                <definitions name='$name' targetNamespace='$uri'\n                    xmlns='http://schemas.xmlsoap.org/wsdl/'\n                    xmlns:tns='$uri'\n                    xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/'\n                    xmlns:xsd='http://www.w3.org/2001/XMLSchema'\n                    xmlns:soap-enc='http://schemas.xmlsoap.org/soap/encoding/'\n                    xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/'></definitions>\";\n        $this->_dom = new DOMDocument();\n        if (!$this->_dom = Zend_Xml_Security::scan($wsdl, $this->_dom)) {\n            #require_once 'Zend/Server/Exception.php';\n            throw new Zend_Server_Exception('Unable to create DomDocument');\n        } \n        $this->_wsdl = $this->_dom->documentElement;\n\n        $this->setComplexTypeStrategy($strategy);\n    }\n\n    /**\n     * Set a new uri for this WSDL\n     *\n     * @param  string|Zend_Uri_Http $uri\n     * @return Zend_Server_Wsdl\n     */\n    public function setUri($uri)\n    {\n        if ($uri instanceof Zend_Uri_Http) {\n            $uri = $uri->getUri();\n        }\n        $oldUri = $this->_uri;\n        $this->_uri = $uri;\n\n        if($this->_dom !== null) {\n            // @todo: This is the worst hack ever, but its needed due to design and non BC issues of WSDL generation\n            $xml = $this->_dom->saveXML();\n            $xml = str_replace($oldUri, $uri, $xml);\n            $this->_dom = new DOMDocument();\n            $this->_dom = Zend_Xml_Security::scan($xml, $this->_dom);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Set a strategy for complex type detection and handling\n     *\n     * @todo Boolean is for backwards compability with extractComplexType object var. Remove it in later versions.\n     * @param boolean|string|Zend_Soap_Wsdl_Strategy_Interface $strategy\n     * @return Zend_Soap_Wsdl\n     */\n    public function setComplexTypeStrategy($strategy)\n    {\n        if($strategy === true) {\n            #require_once \"Zend/Soap/Wsdl/Strategy/DefaultComplexType.php\";\n            $strategy = new Zend_Soap_Wsdl_Strategy_DefaultComplexType();\n        } else if($strategy === false) {\n            #require_once \"Zend/Soap/Wsdl/Strategy/AnyType.php\";\n            $strategy = new Zend_Soap_Wsdl_Strategy_AnyType();\n        } else if(is_string($strategy)) {\n            if(class_exists($strategy)) {\n                $strategy = new $strategy();\n            } else {\n                #require_once \"Zend/Soap/Wsdl/Exception.php\";\n                throw new Zend_Soap_Wsdl_Exception(\n                    sprintf(\"Strategy with name '%s does not exist.\", $strategy\n                ));\n            }\n        }\n\n        if(!($strategy instanceof Zend_Soap_Wsdl_Strategy_Interface)) {\n            #require_once \"Zend/Soap/Wsdl/Exception.php\";\n            throw new Zend_Soap_Wsdl_Exception(\"Set a strategy that is not of type 'Zend_Soap_Wsdl_Strategy_Interface'\");\n        }\n        $this->_strategy = $strategy;\n        return $this;\n    }\n\n    /**\n     * Get the current complex type strategy\n     *\n     * @return Zend_Soap_Wsdl_Strategy_Interface\n     */\n    public function getComplexTypeStrategy()\n    {\n        return $this->_strategy;\n    }\n\n    /**\n     * Add a {@link http://www.w3.org/TR/wsdl#_messages message} element to the WSDL\n     *\n     * @param string $name Name for the {@link http://www.w3.org/TR/wsdl#_messages message}\n     * @param array $parts An array of {@link http://www.w3.org/TR/wsdl#_message parts}\n     *                     The array is constructed like: 'name of part' => 'part xml schema data type'\n     *                     or 'name of part' => array('type' => 'part xml schema type')\n     *                     or 'name of part' => array('element' => 'part xml element name')\n     * @return object The new message's XML_Tree_Node for use in {@link function addDocumentation}\n     */\n    public function addMessage($name, $parts)\n    {\n        $message = $this->_dom->createElement('message');\n\n        $message->setAttribute('name', $name);\n\n        if (sizeof($parts) > 0) {\n            foreach ($parts as $name => $type) {\n                $part = $this->_dom->createElement('part');\n                $part->setAttribute('name', $name);\n                if (is_array($type)) {\n                    foreach ($type as $key => $value) {\n                        $part->setAttribute($key, $value);\n                    }\n                } else {\n                    $part->setAttribute('type', $type);\n                }\n                $message->appendChild($part);\n            }\n        }\n\n        $this->_wsdl->appendChild($message);\n\n        return $message;\n    }\n\n    /**\n     * Add a {@link http://www.w3.org/TR/wsdl#_porttypes portType} element to the WSDL\n     *\n     * @param string $name portType element's name\n     * @return object The new portType's XML_Tree_Node for use in {@link function addPortOperation} and {@link function addDocumentation}\n     */\n    public function addPortType($name)\n    {\n        $portType = $this->_dom->createElement('portType');\n        $portType->setAttribute('name', $name);\n        $this->_wsdl->appendChild($portType);\n\n        return $portType;\n    }\n\n    /**\n     * Add an {@link http://www.w3.org/TR/wsdl#_request-response operation} element to a portType element\n     *\n     * @param object $portType a portType XML_Tree_Node, from {@link function addPortType}\n     * @param string $name Operation name\n     * @param string $input Input Message\n     * @param string $output Output Message\n     * @param string $fault Fault Message\n     * @return object The new operation's XML_Tree_Node for use in {@link function addDocumentation}\n     */\n    public function addPortOperation($portType, $name, $input = false, $output = false, $fault = false)\n    {\n        $operation = $this->_dom->createElement('operation');\n        $operation->setAttribute('name', $name);\n\n        if (is_string($input) && (strlen(trim($input)) >= 1)) {\n            $node = $this->_dom->createElement('input');\n            $node->setAttribute('message', $input);\n            $operation->appendChild($node);\n        }\n        if (is_string($output) && (strlen(trim($output)) >= 1)) {\n            $node= $this->_dom->createElement('output');\n            $node->setAttribute('message', $output);\n            $operation->appendChild($node);\n        }\n        if (is_string($fault) && (strlen(trim($fault)) >= 1)) {\n            $node = $this->_dom->createElement('fault');\n            $node->setAttribute('message', $fault);\n            $operation->appendChild($node);\n        }\n\n        $portType->appendChild($operation);\n\n        return $operation;\n    }\n\n    /**\n     * Add a {@link http://www.w3.org/TR/wsdl#_bindings binding} element to WSDL\n     *\n     * @param string $name Name of the Binding\n     * @param string $type name of the portType to bind\n     * @return object The new binding's XML_Tree_Node for use with {@link function addBindingOperation} and {@link function addDocumentation}\n     */\n    public function addBinding($name, $portType)\n    {\n        $binding = $this->_dom->createElement('binding');\n        $binding->setAttribute('name', $name);\n        $binding->setAttribute('type', $portType);\n\n        $this->_wsdl->appendChild($binding);\n\n        return $binding;\n    }\n\n    /**\n     * Add an operation to a binding element\n     *\n     * @param object $binding A binding XML_Tree_Node returned by {@link function addBinding}\n     * @param array $input An array of attributes for the input element, allowed keys are: 'use', 'namespace', 'encodingStyle'. {@link http://www.w3.org/TR/wsdl#_soap:body More Information}\n     * @param array $output An array of attributes for the output element, allowed keys are: 'use', 'namespace', 'encodingStyle'. {@link http://www.w3.org/TR/wsdl#_soap:body More Information}\n     * @param array $fault An array of attributes for the fault element, allowed keys are: 'name', 'use', 'namespace', 'encodingStyle'. {@link http://www.w3.org/TR/wsdl#_soap:body More Information}\n     * @return object The new Operation's XML_Tree_Node for use with {@link function addSoapOperation} and {@link function addDocumentation}\n     */\n    public function addBindingOperation($binding, $name, $input = false, $output = false, $fault = false)\n    {\n        $operation = $this->_dom->createElement('operation');\n        $operation->setAttribute('name', $name);\n\n        if (is_array($input)) {\n            $node = $this->_dom->createElement('input');\n            $soap_node = $this->_dom->createElement('soap:body');\n            foreach ($input as $name => $value) {\n                $soap_node->setAttribute($name, $value);\n            }\n            $node->appendChild($soap_node);\n            $operation->appendChild($node);\n        }\n\n        if (is_array($output)) {\n            $node = $this->_dom->createElement('output');\n            $soap_node = $this->_dom->createElement('soap:body');\n            foreach ($output as $name => $value) {\n                $soap_node->setAttribute($name, $value);\n            }\n            $node->appendChild($soap_node);\n            $operation->appendChild($node);\n        }\n\n        if (is_array($fault)) {\n            $node = $this->_dom->createElement('fault');\n            /**\n             * Note. Do we really need name attribute to be also set at wsdl:fault node???\n             * W3C standard doesn't mention it (http://www.w3.org/TR/wsdl#_soap:fault)\n             * But some real world WSDLs use it, so it may be required for compatibility reasons.\n             */\n            if (isset($fault['name'])) {\n                $node->setAttribute('name', $fault['name']);\n            }\n\n            $soap_node = $this->_dom->createElement('soap:fault');\n            foreach ($fault as $name => $value) {\n                $soap_node->setAttribute($name, $value);\n            }\n            $node->appendChild($soap_node);\n            $operation->appendChild($node);\n        }\n\n        $binding->appendChild($operation);\n\n        return $operation;\n    }\n\n    /**\n     * Add a {@link http://www.w3.org/TR/wsdl#_soap:binding SOAP binding} element to a Binding element\n     *\n     * @param object $binding A binding XML_Tree_Node returned by {@link function addBinding}\n     * @param string $style binding style, possible values are \"rpc\" (the default) and \"document\"\n     * @param string $transport Transport method (defaults to HTTP)\n     * @return boolean\n     */\n    public function addSoapBinding($binding, $style = 'document', $transport = 'http://schemas.xmlsoap.org/soap/http')\n    {\n        $soap_binding = $this->_dom->createElement('soap:binding');\n        $soap_binding->setAttribute('style', $style);\n        $soap_binding->setAttribute('transport', $transport);\n\n        $binding->appendChild($soap_binding);\n\n        return $soap_binding;\n    }\n\n    /**\n     * Add a {@link http://www.w3.org/TR/wsdl#_soap:operation SOAP operation} to an operation element\n     *\n     * @param object $operation An operation XML_Tree_Node returned by {@link function addBindingOperation}\n     * @param string $soap_action SOAP Action\n     * @return boolean\n     */\n    public function addSoapOperation($binding, $soap_action)\n    {\n        if ($soap_action instanceof Zend_Uri_Http) {\n            $soap_action = $soap_action->getUri();\n        }\n        $soap_operation = $this->_dom->createElement('soap:operation');\n        $soap_operation->setAttribute('soapAction', $soap_action);\n\n        $binding->insertBefore($soap_operation, $binding->firstChild);\n\n        return $soap_operation;\n    }\n\n    /**\n     * Add a {@link http://www.w3.org/TR/wsdl#_services service} element to the WSDL\n     *\n     * @param string $name Service Name\n     * @param string $port_name Name of the port for the service\n     * @param string $binding Binding for the port\n     * @param string $location SOAP Address for the service\n     * @return object The new service's XML_Tree_Node for use with {@link function addDocumentation}\n     */\n    public function addService($name, $port_name, $binding, $location)\n    {\n        if ($location instanceof Zend_Uri_Http) {\n            $location = $location->getUri();\n        }\n        $service = $this->_dom->createElement('service');\n        $service->setAttribute('name', $name);\n\n        $port = $this->_dom->createElement('port');\n        $port->setAttribute('name', $port_name);\n        $port->setAttribute('binding', $binding);\n\n        $soap_address = $this->_dom->createElement('soap:address');\n        $soap_address->setAttribute('location', $location);\n\n        $port->appendChild($soap_address);\n        $service->appendChild($port);\n\n        $this->_wsdl->appendChild($service);\n\n        return $service;\n    }\n\n    /**\n     * Add a documentation element to any element in the WSDL.\n     *\n     * Note that the WSDL {@link http://www.w3.org/TR/wsdl#_documentation specification} uses 'document',\n     * but the WSDL {@link http://schemas.xmlsoap.org/wsdl/ schema} uses 'documentation' instead.\n     * The {@link http://www.ws-i.org/Profiles/BasicProfile-1.1-2004-08-24.html#WSDL_documentation_Element WS-I Basic Profile 1.1} recommends using 'documentation'.\n     *\n     * @param object $input_node An XML_Tree_Node returned by another method to add the documentation to\n     * @param string $documentation Human readable documentation for the node\n     * @return DOMElement The documentation element\n     */\n    public function addDocumentation($input_node, $documentation)\n    {\n        if ($input_node === $this) {\n            $node = $this->_dom->documentElement;\n        } else {\n            $node = $input_node;\n        }\n\n        $doc = $this->_dom->createElement('documentation');\n        $doc_cdata = $this->_dom->createTextNode(str_replace(array(\"\\r\\n\", \"\\r\"), \"\\n\", $documentation));\n        $doc->appendChild($doc_cdata);\n\n        if($node->hasChildNodes()) {\n            $node->insertBefore($doc, $node->firstChild);\n        } else {\n            $node->appendChild($doc);\n        }\n\n        return $doc;\n    }\n\n    /**\n     * Add WSDL Types element\n     *\n     * @param object $types A DomDocument|DomNode|DomElement|DomDocumentFragment with all the XML Schema types defined in it\n     */\n    public function addTypes($types)\n    {\n        if ($types instanceof DomDocument) {\n            $dom = $this->_dom->importNode($types->documentElement);\n            $this->_wsdl->appendChild($types->documentElement);\n        } elseif ($types instanceof DomNode || $types instanceof DomElement || $types instanceof DomDocumentFragment ) {\n            $dom = $this->_dom->importNode($types);\n            $this->_wsdl->appendChild($dom);\n        }\n    }\n\n    /**\n     * Add a complex type name that is part of this WSDL and can be used in signatures.\n     *\n     * @param string $type\n     * @return Zend_Soap_Wsdl\n     */\n    public function addType($type)\n    {\n        if(!in_array($type, $this->_includedTypes)) {\n            $this->_includedTypes[] = $type;\n        }\n        return $this;\n    }\n\n    /**\n     * Return an array of all currently included complex types\n     *\n     * @return array\n     */\n    public function getTypes()\n    {\n        return $this->_includedTypes;\n    }\n\n    /**\n     * Return the Schema node of the WSDL\n     *\n     * @return DOMElement\n     */\n    public function getSchema()\n    {\n        if($this->_schema == null) {\n            $this->addSchemaTypeSection();\n        }\n\n        return $this->_schema;\n    }\n\n    /**\n     * Return the WSDL as XML\n     *\n     * @return string WSDL as XML\n     */\n    public function toXML()\n    {\n           return $this->_dom->saveXML();\n    }\n\n    /**\n     * Return DOM Document\n     *\n     * @return object DomDocum ent\n     */\n    public function toDomDocument()\n    {\n        return $this->_dom;\n    }\n\n    /**\n     * Echo the WSDL as XML\n     *\n     * @return boolean\n     */\n    public function dump($filename = false)\n    {\n        if (!$filename) {\n            echo $this->toXML();\n            return true;\n        } else {\n            return file_put_contents($filename, $this->toXML());\n        }\n    }\n\n    /**\n     * Returns an XSD Type for the given PHP type\n     *\n     * @param string $type PHP Type to get the XSD type for\n     * @return string\n     */\n    public function getType($type)\n    {\n        switch (strtolower($type)) {\n            case 'string':\n            case 'str':\n                return 'xsd:string';\n            case 'long':\n                return 'xsd:long';\n            case 'int':\n            case 'integer':\n                return 'xsd:int';\n            case 'float':\n                return 'xsd:float';\n            case 'double':\n                return 'xsd:double';\n            case 'boolean':\n            case 'bool':\n                return 'xsd:boolean';\n            case 'array':\n                return 'soap-enc:Array';\n            case 'object':\n                return 'xsd:struct';\n            case 'mixed':\n                return 'xsd:anyType';\n            case 'void':\n                return '';\n            default:\n                // delegate retrieval of complex type to current strategy\n                return $this->addComplexType($type);\n            }\n    }\n\n    /**\n     * This function makes sure a complex types section and schema additions are set.\n     *\n     * @return Zend_Soap_Wsdl\n     */\n    public function addSchemaTypeSection()\n    {\n        if ($this->_schema === null) {\n            $this->_schema = $this->_dom->createElement('xsd:schema');\n            $this->_schema->setAttribute('targetNamespace', $this->_uri);\n            $types = $this->_dom->createElement('types');\n            $types->appendChild($this->_schema);\n            $this->_wsdl->appendChild($types);\n        }\n        return $this;\n    }\n\n    /**\n     * Add a {@link http://www.w3.org/TR/wsdl#_types types} data type definition\n     *\n     * @param string $type Name of the class to be specified\n     * @return string XSD Type for the given PHP type\n     */\n    public function addComplexType($type)\n    {\n        if (in_array($type, $this->getTypes())) {\n            return \"tns:$type\";\n        }\n        $this->addSchemaTypeSection();\n\n        $strategy = $this->getComplexTypeStrategy();\n        $strategy->setContext($this);\n        // delegates the detection of a complex type to the current strategy\n        return $strategy->addComplexType($type);\n    }\n\n    /**\n     * Parse an xsd:element represented as an array into a DOMElement.\n     *\n     * @param array $element an xsd:element represented as an array\n     * @return DOMElement parsed element\n     */\n    private function _parseElement($element)\n    {\n        if (!is_array($element)) {\n            #require_once \"Zend/Soap/Wsdl/Exception.php\";\n            throw new Zend_Soap_Wsdl_Exception(\"The 'element' parameter needs to be an associative array.\");\n        }\n\n        $elementXml = $this->_dom->createElement('xsd:element');\n        foreach ($element as $key => $value) {\n            if (in_array($key, array('sequence', 'all', 'choice'))) {\n                if (is_array($value)) {\n                    $complexType = $this->_dom->createElement('xsd:complexType');\n                    if (count($value) > 0) {\n                        $container = $this->_dom->createElement('xsd:' . $key);\n                        foreach ($value as $subelement) {\n                            $subelementXml = $this->_parseElement($subelement);\n                            $container->appendChild($subelementXml);\n                        }\n                        $complexType->appendChild($container);\n                    }\n                    $elementXml->appendChild($complexType);\n                }\n            } else {\n                $elementXml->setAttribute($key, $value);\n            }\n        }\n        return $elementXml;\n    }\n\n    /**\n     * Add an xsd:element represented as an array to the schema.\n     *\n     * Array keys represent attribute names and values their respective value.\n     * The 'sequence', 'all' and 'choice' keys must have an array of elements as their value,\n     * to add them to a nested complexType.\n     *\n     * Example: array( 'name' => 'MyElement',\n     *                 'sequence' => array( array('name' => 'myString', 'type' => 'string'),\n     *                                      array('name' => 'myInteger', 'type' => 'int') ) );\n     * Resulting XML: <xsd:element name=\"MyElement\"><xsd:complexType><xsd:sequence>\n     *                  <xsd:element name=\"myString\" type=\"string\"/>\n     *                  <xsd:element name=\"myInteger\" type=\"int\"/>\n     *                </xsd:sequence></xsd:complexType></xsd:element>\n     *\n     * @param array $element an xsd:element represented as an array\n     * @return string xsd:element for the given element array\n     */\n    public function addElement($element)\n    {\n        $schema = $this->getSchema();\n        $elementXml = $this->_parseElement($element);\n        $schema->appendChild($elementXml);\n        return 'tns:' . $element['name'];\n    }\n}\n"
}