{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "5519",
    "text": "Q:\n\nWhich is a better implementation of a stack data structure (based on an array)?\n\nThis is a version I made:\n#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_STACK_SIZE 255\n\ntypedef struct\n{\n    int array[MAX_STACK_SIZE];\n    unsigned int count;\n    unsigned int max;\n} Stack;\n\nvoid initialize(Stack*);\nvoid push(Stack*, int value);\nint* pop(Stack*);\nbool isEmpty(Stack*);\nbool isFull(Stack*);\n\nint main()\n{\n    Stack s1;\n    initialize(&s1);\n    for(int i = 0; i < 7; i++)\n    {\n        push(&s1, i);\n    }\n    pop(&s1);\n    push(&s1, 88);\n    push(&s1, 6);\n    int *top;\n    while((top = pop(&s1)) != NULL)\n    {\n        printf(\"Popping %d from the top of the stack.\\n\", *top);\n    }\n    return 0;\n}\n\nvoid initialize(Stack *p)\n{\n    p->count = 0;\n    p->max = MAX_STACK_SIZE;\n}\n\nvoid push(Stack *p, int value)\n{\n    if(!isFull(p))\n    {\n        p->array[p->count] = value;\n        p->count++;\n    }\n}\n\nint* pop(Stack *p)\n{\n    if (!isEmpty(p))\n    {\n        p->count--;\n        return p->array + p->count;\n    }\n    return NULL;\n}\n\nbool isEmpty(Stack *p)\n{\n    return p->count == 0;\n}\n\nbool isFull(Stack *p)\n{\n    return p->count == p->max;\n}\n\nThis is a version of how it was done from the source I'm learning from:\n#include <stdio.h>\n\n#define MAX_STACK_SIZE 255\n#define true 1\n#define false 0\n#define bool unsigned short int\n\nstruct stack\n{\n    int *topOfStack;\n    int *pointer;\n    int count;\n    int max;\n    int theStack[MAX_STACK_SIZE];\n};\n\nvoid initStack(struct stack *stackStruct)\n{\n    stackStruct->topOfStack = stackStruct->theStack;\n    stackStruct->pointer = stackStruct->theStack;\n    stackStruct->max = MAX_STACK_SIZE;\n    stackStruct->count = 0;\n}\nbool pushStack(struct stack *stackStruct, int inputValue)\n{\n    if(stackStruct->count < stackStruct->max)\n    {\n        *stackStruct->pointer = inputValue;\n        stackStruct->count++;\n        stackStruct->pointer++;\n        return true;\n    }\n    else\n        return false;\n}\nint* popStack(struct stack *stackStruct)\n{\n    if(stackStruct->count > 0)\n    {\n        stackStruct->pointer--;\n        stackStruct->count--;\n        return stackStruct->pointer;\n    }\n    return NULL;\n}\n\nI think there's not so much of a difference between theb, but I just wanted to be sure.  In their version, they've used 2 additional pointers in their Stack struct and I removed them because I thought it was not necessary because we could use the array address + count to get the pointer address in their example.  I think they used it for convenience reasons.  More differences are that I included <stdbool.h> instead of using macros (not really important).\nOn top of that, I've implemented isEmpty() and isFull() methods just for convenience, but don't take it into account when comparing the two implementations since I'm sure they could do the same.  I just chose to show the 2 main functions that could be used on a stack.\nOther than that, since it's an array-based implementation of a stack, I think it was possible to not include the max field in the struct since we define in a macro the stack maximum size, but I added it as well to my implementation for the heck of it.\nIs there any differences between our implementations? Since I chose to do my own implementation I just want to make sure I that I did implemented it correctly and efficiently.\n\nA:\n\npush() and pop() have an asymmetry that should be reconciled.  push() does not indicate any thing special when the stack is full and a push is attempted.  It silently does not do the push.  Yet when an pop of an emty stack occurs, a NULL is returned (versus a pointer to int) allowing the calling routine to take evasive action.  A symmetric solution would both do something special - or not - on full/empty.\nA function to inspect the top of stack, without popping, could be added.  This IMO would be useful.  Additional routines to report current stack depth or stack space left are something to consider.\nUsing unsigned int is OK, especially if the fixed array size is known to always be less than UINT_MAX.  I favor size_t for array indexing as it has better portability for large arrays.\nA way to deal with popping or inspecting an empty stack is, as part of initialize(), to pass an int as the bottom-of-stack.  This value does not actually ever get \"popped off\".\nThe names of the functions are too generic (\"initialize\") and could well collide with other code.  Suggest something like Stack_initialize(), and Stack_push().\nThe OO part of me wants to see a copy and destructor function too.  The destructor could simple do count = max = 0;\n\n"
}