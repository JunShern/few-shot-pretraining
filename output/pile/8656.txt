{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": true,
            "reason": "Text contains SAT."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "8656",
    "text": "# -*- coding: utf-8 -*-\n#\n#  SelfTest/PublicKey/test_RSA.py: Self-test for the RSA primitive\n#\n# Written in 2008 by Dwayne C. Litzenberger <dlitz@dlitz.net>\n#\n# ===================================================================\n# The contents of this file are dedicated to the public domain.  To\n# the extent that dedication to the public domain is not available,\n# everyone is granted a worldwide, perpetual, royalty-free,\n# non-exclusive license to exercise all rights associated with the\n# contents of this file for any purpose whatsoever.\n# No rights are reserved.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n# ===================================================================\n\n\"\"\"Self-test suite for Crypto.PublicKey.RSA\"\"\"\n\n__revision__ = \"$Id$\"\n\nimport sys\nimport os\nif sys.version_info[0] == 2 and sys.version_info[1] == 1:\n    from Crypto.Util.py21compat import *\nfrom Crypto.Util.py3compat import *\n\nimport unittest\nfrom Crypto.SelfTest.st_common import list_test_cases, a2b_hex, b2a_hex\n\nclass RSATest(unittest.TestCase):\n    # Test vectors from \"RSA-OAEP and RSA-PSS test vectors (.zip file)\"\n    #   ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip\n    # See RSADSI's PKCS#1 page at\n    #   http://www.rsa.com/rsalabs/node.asp?id=2125\n\n    # from oaep-int.txt\n\n    # TODO: PyCrypto treats the message as starting *after* the leading \"00\"\n    # TODO: That behaviour should probably be changed in the future.\n    plaintext = \"\"\"\n           eb 7a 19 ac e9 e3 00 63 50 e3 29 50 4b 45 e2\n        ca 82 31 0b 26 dc d8 7d 5c 68 f1 ee a8 f5 52 67\n        c3 1b 2e 8b b4 25 1f 84 d7 e0 b2 c0 46 26 f5 af\n        f9 3e dc fb 25 c9 c2 b3 ff 8a e1 0e 83 9a 2d db\n        4c dc fe 4f f4 77 28 b4 a1 b7 c1 36 2b aa d2 9a\n        b4 8d 28 69 d5 02 41 21 43 58 11 59 1b e3 92 f9\n        82 fb 3e 87 d0 95 ae b4 04 48 db 97 2f 3a c1 4f\n        7b c2 75 19 52 81 ce 32 d2 f1 b7 6d 4d 35 3e 2d\n    \"\"\"\n\n    ciphertext = \"\"\"\n        12 53 e0 4d c0 a5 39 7b b4 4a 7a b8 7e 9b f2 a0\n        39 a3 3d 1e 99 6f c8 2a 94 cc d3 00 74 c9 5d f7\n        63 72 20 17 06 9e 52 68 da 5d 1c 0b 4f 87 2c f6\n        53 c1 1d f8 23 14 a6 79 68 df ea e2 8d ef 04 bb\n        6d 84 b1 c3 1d 65 4a 19 70 e5 78 3b d6 eb 96 a0\n        24 c2 ca 2f 4a 90 fe 9f 2e f5 c9 c1 40 e5 bb 48\n        da 95 36 ad 87 00 c8 4f c9 13 0a de a7 4e 55 8d\n        51 a7 4d df 85 d8 b5 0d e9 68 38 d6 06 3e 09 55\n    \"\"\"\n\n    modulus = \"\"\"\n        bb f8 2f 09 06 82 ce 9c 23 38 ac 2b 9d a8 71 f7\n        36 8d 07 ee d4 10 43 a4 40 d6 b6 f0 74 54 f5 1f\n        b8 df ba af 03 5c 02 ab 61 ea 48 ce eb 6f cd 48\n        76 ed 52 0d 60 e1 ec 46 19 71 9d 8a 5b 8b 80 7f\n        af b8 e0 a3 df c7 37 72 3e e6 b4 b7 d9 3a 25 84\n        ee 6a 64 9d 06 09 53 74 88 34 b2 45 45 98 39 4e\n        e0 aa b1 2d 7b 61 a5 1f 52 7a 9a 41 f6 c1 68 7f\n        e2 53 72 98 ca 2a 8f 59 46 f8 e5 fd 09 1d bd cb\n    \"\"\"\n\n    e = 0x11L    # public exponent\n\n    prime_factor = \"\"\"\n        c9 7f b1 f0 27 f4 53 f6 34 12 33 ea aa d1 d9 35\n        3f 6c 42 d0 88 66 b1 d0 5a 0f 20 35 02 8b 9d 86\n        98 40 b4 16 66 b4 2e 92 ea 0d a3 b4 32 04 b5 cf\n        ce 33 52 52 4d 04 16 a5 a4 41 e7 00 af 46 15 03\n    \"\"\"\n\n    def setUp(self):\n        global RSA, Random, bytes_to_long\n        from Crypto.PublicKey import RSA\n        from Crypto import Random\n        from Crypto.Util.number import bytes_to_long, inverse\n        self.n = bytes_to_long(a2b_hex(self.modulus))\n        self.p = bytes_to_long(a2b_hex(self.prime_factor))\n\n        # Compute q, d, and u from n, e, and p\n        self.q = divmod(self.n, self.p)[0]\n        self.d = inverse(self.e, (self.p-1)*(self.q-1))\n        self.u = inverse(self.p, self.q)    # u = e**-1 (mod q)\n\n        self.rsa = RSA\n\n    def test_generate_1arg(self):\n        \"\"\"RSA (default implementation) generated key (1 argument)\"\"\"\n        rsaObj = self.rsa.generate(1024)\n        self._check_private_key(rsaObj)\n        self._exercise_primitive(rsaObj)\n        pub = rsaObj.publickey()\n        self._check_public_key(pub)\n        self._exercise_public_primitive(rsaObj)\n\n    def test_generate_2arg(self):\n        \"\"\"RSA (default implementation) generated key (2 arguments)\"\"\"\n        rsaObj = self.rsa.generate(1024, Random.new().read)\n        self._check_private_key(rsaObj)\n        self._exercise_primitive(rsaObj)\n        pub = rsaObj.publickey()\n        self._check_public_key(pub)\n        self._exercise_public_primitive(rsaObj)\n\n    def test_generate_3args(self):\n        rsaObj = self.rsa.generate(1024, Random.new().read,e=65537)\n        self._check_private_key(rsaObj)\n        self._exercise_primitive(rsaObj)\n        pub = rsaObj.publickey()\n        self._check_public_key(pub)\n        self._exercise_public_primitive(rsaObj)\n        self.assertEqual(65537,rsaObj.e)\n\n    def test_construct_2tuple(self):\n        \"\"\"RSA (default implementation) constructed key (2-tuple)\"\"\"\n        pub = self.rsa.construct((self.n, self.e))\n        self._check_public_key(pub)\n        self._check_encryption(pub)\n        self._check_verification(pub)\n\n    def test_construct_3tuple(self):\n        \"\"\"RSA (default implementation) constructed key (3-tuple)\"\"\"\n        rsaObj = self.rsa.construct((self.n, self.e, self.d))\n        self._check_encryption(rsaObj)\n        self._check_decryption(rsaObj)\n        self._check_signing(rsaObj)\n        self._check_verification(rsaObj)\n\n    def test_construct_4tuple(self):\n        \"\"\"RSA (default implementation) constructed key (4-tuple)\"\"\"\n        rsaObj = self.rsa.construct((self.n, self.e, self.d, self.p))\n        self._check_encryption(rsaObj)\n        self._check_decryption(rsaObj)\n        self._check_signing(rsaObj)\n        self._check_verification(rsaObj)\n\n    def test_construct_5tuple(self):\n        \"\"\"RSA (default implementation) constructed key (5-tuple)\"\"\"\n        rsaObj = self.rsa.construct((self.n, self.e, self.d, self.p, self.q))\n        self._check_private_key(rsaObj)\n        self._check_encryption(rsaObj)\n        self._check_decryption(rsaObj)\n        self._check_signing(rsaObj)\n        self._check_verification(rsaObj)\n\n    def test_construct_6tuple(self):\n        \"\"\"RSA (default implementation) constructed key (6-tuple)\"\"\"\n        rsaObj = self.rsa.construct((self.n, self.e, self.d, self.p, self.q, self.u))\n        self._check_private_key(rsaObj)\n        self._check_encryption(rsaObj)\n        self._check_decryption(rsaObj)\n        self._check_signing(rsaObj)\n        self._check_verification(rsaObj)\n\n    def test_factoring(self):\n        rsaObj = self.rsa.construct([self.n, self.e, self.d])\n        self.failUnless(rsaObj.p==self.p or rsaObj.p==self.q)\n        self.failUnless(rsaObj.q==self.p or rsaObj.q==self.q)\n        self.failUnless(rsaObj.q*rsaObj.p == self.n)\n\n        self.assertRaises(ValueError, self.rsa.construct, [self.n, self.e, self.n-1])\n\n    def _check_private_key(self, rsaObj):\n        # Check capabilities\n        self.assertEqual(1, rsaObj.has_private())\n        self.assertEqual(1, rsaObj.can_sign())\n        self.assertEqual(1, rsaObj.can_encrypt())\n        self.assertEqual(1, rsaObj.can_blind())\n\n        # Check rsaObj.[nedpqu] -> rsaObj.key.[nedpqu] mapping\n        self.assertEqual(rsaObj.n, rsaObj.key.n)\n        self.assertEqual(rsaObj.e, rsaObj.key.e)\n        self.assertEqual(rsaObj.d, rsaObj.key.d)\n        self.assertEqual(rsaObj.p, rsaObj.key.p)\n        self.assertEqual(rsaObj.q, rsaObj.key.q)\n        self.assertEqual(rsaObj.u, rsaObj.key.u)\n\n        # Sanity check key data\n        self.assertEqual(rsaObj.n, rsaObj.p * rsaObj.q)     # n = pq\n        self.assertEqual(1, rsaObj.d * rsaObj.e % ((rsaObj.p-1) * (rsaObj.q-1))) # ed = 1 (mod (p-1)(q-1))\n        self.assertEqual(1, rsaObj.p * rsaObj.u % rsaObj.q) # pu = 1 (mod q)\n        self.assertEqual(1, rsaObj.p > 1)   # p > 1\n        self.assertEqual(1, rsaObj.q > 1)   # q > 1\n        self.assertEqual(1, rsaObj.e > 1)   # e > 1\n        self.assertEqual(1, rsaObj.d > 1)   # d > 1\n\n    def _check_public_key(self, rsaObj):\n        ciphertext = a2b_hex(self.ciphertext)\n\n        # Check capabilities\n        self.assertEqual(0, rsaObj.has_private())\n        self.assertEqual(1, rsaObj.can_sign())\n        self.assertEqual(1, rsaObj.can_encrypt())\n        self.assertEqual(1, rsaObj.can_blind())\n\n        # Check rsaObj.[ne] -> rsaObj.key.[ne] mapping\n        self.assertEqual(rsaObj.n, rsaObj.key.n)\n        self.assertEqual(rsaObj.e, rsaObj.key.e)\n\n        # Check that private parameters are all missing\n        self.assertEqual(0, hasattr(rsaObj, 'd'))\n        self.assertEqual(0, hasattr(rsaObj, 'p'))\n        self.assertEqual(0, hasattr(rsaObj, 'q'))\n        self.assertEqual(0, hasattr(rsaObj, 'u'))\n        self.assertEqual(0, hasattr(rsaObj.key, 'd'))\n        self.assertEqual(0, hasattr(rsaObj.key, 'p'))\n        self.assertEqual(0, hasattr(rsaObj.key, 'q'))\n        self.assertEqual(0, hasattr(rsaObj.key, 'u'))\n\n        # Sanity check key data\n        self.assertEqual(1, rsaObj.e > 1)   # e > 1\n\n        # Public keys should not be able to sign or decrypt\n        self.assertRaises(TypeError, rsaObj.sign, ciphertext, b(\"\"))\n        self.assertRaises(TypeError, rsaObj.decrypt, ciphertext)\n\n        # Check __eq__ and __ne__\n        self.assertEqual(rsaObj.publickey() == rsaObj.publickey(),True) # assert_\n        self.assertEqual(rsaObj.publickey() != rsaObj.publickey(),False) # failIf\n\n    def _exercise_primitive(self, rsaObj):\n        # Since we're using a randomly-generated key, we can't check the test\n        # vector, but we can make sure encryption and decryption are inverse\n        # operations.\n        ciphertext = a2b_hex(self.ciphertext)\n\n        # Test decryption\n        plaintext = rsaObj.decrypt((ciphertext,))\n\n        # Test encryption (2 arguments)\n        (new_ciphertext2,) = rsaObj.encrypt(plaintext, b(\"\"))\n        self.assertEqual(b2a_hex(ciphertext), b2a_hex(new_ciphertext2))\n\n        # Test blinded decryption\n        blinding_factor = Random.new().read(len(ciphertext)-1)\n        blinded_ctext = rsaObj.blind(ciphertext, blinding_factor)\n        blinded_ptext = rsaObj.decrypt((blinded_ctext,))\n        unblinded_plaintext = rsaObj.unblind(blinded_ptext, blinding_factor)\n        self.assertEqual(b2a_hex(plaintext), b2a_hex(unblinded_plaintext))\n\n        # Test signing (2 arguments)\n        signature2 = rsaObj.sign(ciphertext, b(\"\"))\n        self.assertEqual((bytes_to_long(plaintext),), signature2)\n\n        # Test verification\n        self.assertEqual(1, rsaObj.verify(ciphertext, (bytes_to_long(plaintext),)))\n\n    def _exercise_public_primitive(self, rsaObj):\n        plaintext = a2b_hex(self.plaintext)\n\n        # Test encryption (2 arguments)\n        (new_ciphertext2,) = rsaObj.encrypt(plaintext, b(\"\"))\n\n        # Exercise verification\n        rsaObj.verify(new_ciphertext2, (bytes_to_long(plaintext),))\n\n    def _check_encryption(self, rsaObj):\n        plaintext = a2b_hex(self.plaintext)\n        ciphertext = a2b_hex(self.ciphertext)\n\n        # Test encryption (2 arguments)\n        (new_ciphertext2,) = rsaObj.encrypt(plaintext, b(\"\"))\n        self.assertEqual(b2a_hex(ciphertext), b2a_hex(new_ciphertext2))\n\n    def _check_decryption(self, rsaObj):\n        plaintext = a2b_hex(self.plaintext)\n        ciphertext = a2b_hex(self.ciphertext)\n\n        # Test plain decryption\n        new_plaintext = rsaObj.decrypt((ciphertext,))\n        self.assertEqual(b2a_hex(plaintext), b2a_hex(new_plaintext))\n\n        # Test blinded decryption\n        blinding_factor = Random.new().read(len(ciphertext)-1)\n        blinded_ctext = rsaObj.blind(ciphertext, blinding_factor)\n        blinded_ptext = rsaObj.decrypt((blinded_ctext,))\n        unblinded_plaintext = rsaObj.unblind(blinded_ptext, blinding_factor)\n        self.assertEqual(b2a_hex(plaintext), b2a_hex(unblinded_plaintext))\n\n    def _check_verification(self, rsaObj):\n        signature = bytes_to_long(a2b_hex(self.plaintext))\n        message = a2b_hex(self.ciphertext)\n\n        # Test verification\n        t = (signature,)     # rsaObj.verify expects a tuple\n        self.assertEqual(1, rsaObj.verify(message, t))\n\n        # Test verification with overlong tuple (this is a\n        # backward-compatibility hack to support some harmless misuse of the\n        # API)\n        t2 = (signature, '')\n        self.assertEqual(1, rsaObj.verify(message, t2)) # extra garbage at end of tuple\n\n    def _check_signing(self, rsaObj):\n        signature = bytes_to_long(a2b_hex(self.plaintext))\n        message = a2b_hex(self.ciphertext)\n\n        # Test signing (2 argument)\n        self.assertEqual((signature,), rsaObj.sign(message, b(\"\")))\n\nclass RSAFastMathTest(RSATest):\n    def setUp(self):\n        RSATest.setUp(self)\n        self.rsa = RSA.RSAImplementation(use_fast_math=True)\n\n    def test_generate_1arg(self):\n        \"\"\"RSA (_fastmath implementation) generated key (1 argument)\"\"\"\n        RSATest.test_generate_1arg(self)\n\n    def test_generate_2arg(self):\n        \"\"\"RSA (_fastmath implementation) generated key (2 arguments)\"\"\"\n        RSATest.test_generate_2arg(self)\n\n    def test_construct_2tuple(self):\n        \"\"\"RSA (_fastmath implementation) constructed key (2-tuple)\"\"\"\n        RSATest.test_construct_2tuple(self)\n\n    def test_construct_3tuple(self):\n        \"\"\"RSA (_fastmath implementation) constructed key (3-tuple)\"\"\"\n        RSATest.test_construct_3tuple(self)\n\n    def test_construct_4tuple(self):\n        \"\"\"RSA (_fastmath implementation) constructed key (4-tuple)\"\"\"\n        RSATest.test_construct_4tuple(self)\n\n    def test_construct_5tuple(self):\n        \"\"\"RSA (_fastmath implementation) constructed key (5-tuple)\"\"\"\n        RSATest.test_construct_5tuple(self)\n\n    def test_construct_6tuple(self):\n        \"\"\"RSA (_fastmath implementation) constructed key (6-tuple)\"\"\"\n        RSATest.test_construct_6tuple(self)\n\n    def test_factoring(self):\n        RSATest.test_factoring(self)\n\nclass RSASlowMathTest(RSATest):\n    def setUp(self):\n        RSATest.setUp(self)\n        self.rsa = RSA.RSAImplementation(use_fast_math=False)\n\n    def test_generate_1arg(self):\n        \"\"\"RSA (_slowmath implementation) generated key (1 argument)\"\"\"\n        RSATest.test_generate_1arg(self)\n\n    def test_generate_2arg(self):\n        \"\"\"RSA (_slowmath implementation) generated key (2 arguments)\"\"\"\n        RSATest.test_generate_2arg(self)\n\n    def test_construct_2tuple(self):\n        \"\"\"RSA (_slowmath implementation) constructed key (2-tuple)\"\"\"\n        RSATest.test_construct_2tuple(self)\n\n    def test_construct_3tuple(self):\n        \"\"\"RSA (_slowmath implementation) constructed key (3-tuple)\"\"\"\n        RSATest.test_construct_3tuple(self)\n\n    def test_construct_4tuple(self):\n        \"\"\"RSA (_slowmath implementation) constructed key (4-tuple)\"\"\"\n        RSATest.test_construct_4tuple(self)\n\n    def test_construct_5tuple(self):\n        \"\"\"RSA (_slowmath implementation) constructed key (5-tuple)\"\"\"\n        RSATest.test_construct_5tuple(self)\n\n    def test_construct_6tuple(self):\n        \"\"\"RSA (_slowmath implementation) constructed key (6-tuple)\"\"\"\n        RSATest.test_construct_6tuple(self)\n\n    def test_factoring(self):\n        RSATest.test_factoring(self)\n\ndef get_tests(config={}):\n    tests = []\n    tests += list_test_cases(RSATest)\n    try:\n        from Crypto.PublicKey import _fastmath\n        tests += list_test_cases(RSAFastMathTest)\n    except ImportError:\n        from distutils.sysconfig import get_config_var\n        import inspect\n        _fm_path = os.path.normpath(os.path.dirname(os.path.abspath(\n            inspect.getfile(inspect.currentframe())))\n            +\"/../../PublicKey/_fastmath\"+get_config_var(\"SO\"))\n        if os.path.exists(_fm_path):\n            raise ImportError(\"While the _fastmath module exists, importing \"+\n                \"it failed. This may point to the gmp or mpir shared library \"+\n                \"not being in the path. _fastmath was found at \"+_fm_path)\n    if config.get('slow_tests',1):\n        tests += list_test_cases(RSASlowMathTest)\n    return tests\n\nif __name__ == '__main__':\n    suite = lambda: unittest.TestSuite(get_tests())\n    unittest.main(defaultTest='suite')\n\n# vim:set ts=4 sw=4 sts=4 expandtab:\n"
}