{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['In the following picture, the green region is where you generate your random values. (0.194)', 'Actually, taking the length of the list again is a litle bit strange, since you know how large the sample is: (0.177)', 'That way, you can define a version of approximatePi that works for large lists: (0.188)']."
        }
    ],
    "doc_id": "5253",
    "text": "Q:\n\nApproximating \u03c0 via Monte Carlo simulation\n\nInspired by a tweet linked to me by a friend and a Haskell implementation by her for the same problem, I decided to try my hand at approximating the value of \u03c0 using everything in the Haskell standard library I could find for the job. Here\u2019s what I came up with:\nmodule Pi where\n\nimport Data.List (genericLength)\nimport Control.Arrow (Arrow, (<<<), (***), arr)\nimport System.Random (newStdGen, randoms)\n\ntype Point a = (a, a)\n\nchunk2 :: [a] -> [(a, a)]\nchunk2 []      = []\nchunk2 [_]     = error \"list of uneven length\"\nchunk2 (x:y:r) = (x, y) : chunk2 r\n\nboth :: Arrow arr => arr a b -> arr (a, a) (b, b)\nboth f = f *** f\n\nunsplit :: Arrow arr => (a -> b -> c) -> arr (a, b) c\nunsplit = arr . uncurry\n\nrandomFloats :: IO [Float]\nrandomFloats = randoms <$> newStdGen\n\nrandomPoints :: IO [Point Float]\nrandomPoints = chunk2 <$> randomFloats\n\nisInUnitCircle :: (Floating a, Ord a) => Point a -> Bool\nisInUnitCircle (x, y) = x' + y' < 0.25\n  where x' = (x - 0.5) ** 2\n        y' = (y - 0.5) ** 2\n\nlengthRatio :: (Fractional c) => [b] -> [b] -> c\nlengthRatio = curry (unsplit (/) <<< both genericLength)\n\napproximatePi :: [Point Float] -> Float\napproximatePi points = circleRatio * 4.0\n  where circlePoints = filter isInUnitCircle points\n        circleRatio = circlePoints `lengthRatio` points\n\nmain :: IO ()\nmain = do\n  putStrLn \"How many points do you want to generate to approximate \u03c0?\"\n  numPoints <- read <$> getLine\n  points <- take numPoints <$> randomPoints\n  print $ approximatePi points\n\nI\u2019m interested in a general review, but I\u2019m especially curious about my use of arrows: is there a better way to write lengthRatio? Are anything like both and unsplit provided anywhere in the standard library? If not, do any packages help?\n\nA:\n\nAbout those arrows\n\nI\u2019m interested in a general review, but I\u2019m especially curious about my use of arrows: is there a better way to write lengthRatio?\n\nCompare the following two lines. Both do the same, but which one would you rather see if you need to change your code drunk in three months, with only 5% battery left?\nlengthRatio = curry (unsplit (/) <<< both genericLength)\n\nlengthRatio xs ys = genericLength xs / genericLength ys\n\nAlso, which one has which type, and which one is more general? \nArrows are great if you want to abstract functions. But throughout your small script, you're still just working with (->), not any other instance of Arrow. For a small script like this, Arrow is too much. For example the pointwise definition above is actually a character shorter than the pointfree one. Sure, the pointfree one is clever, but it's also very beginner-unfriendly. \nAbout randomness\nrandomPoints introduces a dependency between your point coordinates \\$x\\$ and \\$y\\$, since both draw from the same sequence. This usually leads to points on hyperplanes (see disadvantages of LCG and spectral test). Your friends variant doesn't have this immediate problem:\nrandomTuples :: Int -> IO [(Float, Float)]\nrandomTuples n = do\n  seed1 <- newStdGen\n  seed2 <- newStdGen\n  let xs = randoms seed1 :: [Float] -- two different\n      ys = randoms seed2 :: [Float] -- generators being used\n  return $ take n $ zipWith (,) xs ys\n\nHowever, since newStdGen is merely a split, it's more or less hiding the dependency at another place. Still, it's something to keep in mind, if you don't want to end up with something like this.\nBut how would you check this? Well, you would run tests, over and over. Here's the second design critique on randomPoints, it doesn't take a RandomGen. Truth be told, if I say that Arrow is too much for a small script, then\nrandomPoints :: RandomGen g => g -> [Point Float]\n\nis too much either.\nAlso, if you know you're going to generate Points, a newtype Point a together with\ninstance Random a => Random (Point a) where \n\nis feasible and doesn't introduce a potential error via chunk2. Keep possible problems with Random in mind, though.\nAbout names\nThe function isInUnitCircle lies. It's not testing whether the point \\$(x,y)\\$ lies in the circle with radius \\$r = 1\\$ with center in the origin, e.g.\n$$\n\\sqrt{x^2 + y^2} \\le 1^2 \\Leftrightarrow x^2 + y^2 \\le 1\n$$\nbut in the circle with diameter \\$d = 2r = 1\\$ with center in \\$(0.5, 0.5)\\$. In the following picture, the green region is where you generate your random values. In the left one, you see the regular unit circle, in the right one, you see the circle size you're actually testing (after shifting your values from the green square into the red one):\n\nTherefore, you're not calculating the \"usual\" fourth of a circle, but instead a circle with a fourth of the original size (\\$\\pi(\\frac{1}{2})^2 = \\frac{\\pi}{4}\\$)). Luckily, it doesn't matter for the convergence.\nA real test that checks whether a point is in the unit circle is tremendously easier:\nisInUnitCircle :: (Num a, Ord a) => Point a -> Bool\nisInUnitCircle (x, y) = x ^ 2 + y ^ 2 <= 1\n\nAbout optimization\nLast, but not least, there's an issue with approximatePi, or rather the use of lengthRatio on the same list twice. Actually, taking the length of the list again is a litle bit strange, since you know how large the sample is:\nnumPoints <- read <$> getLine                -- sample size\npoints    <- take numPoints <$> randomPoints\nprint $ approximatePi points                 -- sample size still known (?)\n\nBut let's say that you don't actually know how many points you have. Let's assume that someone wants to check a many points. Suddenly, the memory usage of your program explodes:\n\n$ echo 10000000 | ./CalcPi +RTS -s\nHow many points do you want to generate to approximate \u03c0?\n3.141744\n  33,724,505,920 bytes allocated in the heap\n   5,288,250,096 bytes copied during GC\n   1,319,621,976 bytes maximum residency (17 sample(s))\n       5,554,344 bytes maximum slop\n            2587 MB total memory in use (0 MB lost due to fragmentation)\n\n                                     Tot time (elapsed)  Avg pause  Max pause\n  Gen  0     63626 colls,     0 par    1.606s   3.155s     0.0000s    0.0006s\n  Gen  1        17 colls,     0 par    2.732s   3.373s     0.1984s    1.2720s\n\n  INIT    time    0.000s  (  0.000s elapsed)\n  MUT     time   17.158s  ( 15.542s elapsed)\n  GC      time    4.337s  (  6.528s elapsed)\n  EXIT    time    0.019s  (  0.166s elapsed)\n  Total   time   21.514s  ( 22.236s elapsed)\n\n  %GC     time      20.2%  (29.4% elapsed)\n\n  Alloc rate    1,965,530,983 bytes per MUT second\n\n  Productivity  79.8% of total user, 77.2% of total elapsed\n\nEven though randoms generates a lazy list, approximatePi needs to hold onto it completely due to lengthRatio. A classic space leak. The altnerative version of lengthRatio won't save you from that. Instead, provide a function to check the ratio of filtered elements:\n-- Rational from Data.Ratio\nfilterRatio :: (a -> Bool) -> [a] -> Rational\nfilterRatio p xs = -- exercise\n\nThat way, you can define a version of approximatePi that works for large lists:\napproximatePi :: [Points Float] -> Double\napproximatePi points = circleRatio * 4\n  where \n    circleRatio = fromRational $ filterRatio isInUnitCircle points\n\n$ echo 10000000 | ./GenPIRatio +RTS -s\nHow many points do you want to generate to approximate \u03c0?\n3.1421592\n  24,445,866,792 bytes allocated in the heap\n      15,555,552 bytes copied during GC\n          77,896 bytes maximum residency (2 sample(s))\n          21,224 bytes maximum slop\n               1 MB total memory in use (0 MB lost due to fragmentation)\n\n                                     Tot time (elapsed)  Avg pause  Max pause\n  Gen  0     46874 colls,     0 par    0.012s   0.113s     0.0000s    0.0001s\n  Gen  1         2 colls,     0 par    0.000s   0.000s     0.0001s    0.0001s\n\n  INIT    time    0.000s  (  0.000s elapsed)\n  MUT     time   10.809s  ( 10.746s elapsed)\n  GC      time    0.012s  (  0.113s elapsed)\n  EXIT    time    0.000s  (  0.000s elapsed)\n  Total   time   10.821s  ( 10.859s elapsed)\n\n  %GC     time       0.1%  (1.0% elapsed)\n\n  Alloc rate    2,261,657,279 bytes per MUT second\n\n  Productivity  99.9% of total user, 99.5% of total elapsed\n\nSummary\nFood for thought:\n\nUse the right level of abstraction for your problem. Arrow is an overkill for such a small script, but alright for learning.\nTry to decrease the amount of IO wherever possible, but again, that might be too abstract for a small script.\n\nBad:\n\nDon't lie, give things the right name.\nDon't overcomplicate, keep pointfree to a sane minimum.\nMajor space leak in approximatePi. Read the linked section of RWH and try to define filterRatio or a similar function.\n\nGood:\n\nType signatures! Yay!\nExplicit imports!\nType synonym instead of (a, a) everywhere!\n\nSo beside the slight arrow-overkill, well done.\n\n"
}