{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 5 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "205",
    "text": "/*\n * Driver for audio on multifunction CS5535/6 companion device\n * Copyright (C) Jaya Kumar\n *\n * Based on Jaroslav Kysela and Takashi Iwai's examples.\n * This work was sponsored by CIS(M) Sdn Bhd.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/rawmidi.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n#include <sound/asoundef.h>\n#include \"cs5535audio.h\"\n\n#define DRIVER_NAME \"cs5535audio\"\n\nstatic char *ac97_quirk;\nmodule_param(ac97_quirk, charp, 0444);\nMODULE_PARM_DESC(ac97_quirk, \"AC'97 board specific workarounds.\");\n\nstatic const struct ac97_quirk ac97_quirks[] = {\n#if 0 /* Not yet confirmed if all 5536 boards are HP only */\n\t{\n\t\t.subvendor = PCI_VENDOR_ID_AMD, \n\t\t.subdevice = PCI_DEVICE_ID_AMD_CS5536_AUDIO, \n\t\t.name = \"AMD RDK\",     \n\t\t.type = AC97_TUNE_HP_ONLY\n\t},\n#endif\n\t{}\n};\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" DRIVER_NAME);\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" DRIVER_NAME);\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable \" DRIVER_NAME);\n\nstatic const struct pci_device_id snd_cs5535audio_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_CS5535_AUDIO) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_AUDIO) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, snd_cs5535audio_ids);\n\nstatic void wait_till_cmd_acked(struct cs5535audio *cs5535au, unsigned long timeout)\n{\n\tunsigned int tmp;\n\tdo {\n\t\ttmp = cs_readl(cs5535au, ACC_CODEC_CNTL);\n\t\tif (!(tmp & CMD_NEW))\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (--timeout);\n\tif (!timeout)\n\t\tdev_err(cs5535au->card->dev,\n\t\t\t\"Failure writing to cs5535 codec\\n\");\n}\n\nstatic unsigned short snd_cs5535audio_codec_read(struct cs5535audio *cs5535au,\n\t\t\t\t\t\t unsigned short reg)\n{\n\tunsigned int regdata;\n\tunsigned int timeout;\n\tunsigned int val;\n\n\tregdata = ((unsigned int) reg) << 24;\n\tregdata |= ACC_CODEC_CNTL_RD_CMD;\n\tregdata |= CMD_NEW;\n\n\tcs_writel(cs5535au, ACC_CODEC_CNTL, regdata);\n\twait_till_cmd_acked(cs5535au, 50);\n\n\ttimeout = 50;\n\tdo {\n\t\tval = cs_readl(cs5535au, ACC_CODEC_STATUS);\n\t\tif ((val & STS_NEW) && reg == (val >> 24))\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (--timeout);\n\tif (!timeout)\n\t\tdev_err(cs5535au->card->dev,\n\t\t\t\"Failure reading codec reg 0x%x, Last value=0x%x\\n\",\n\t\t\treg, val);\n\n\treturn (unsigned short) val;\n}\n\nstatic void snd_cs5535audio_codec_write(struct cs5535audio *cs5535au,\n\t\t\t\t\tunsigned short reg, unsigned short val)\n{\n\tunsigned int regdata;\n\n\tregdata = ((unsigned int) reg) << 24;\n\tregdata |= val;\n\tregdata &= CMD_MASK;\n\tregdata |= CMD_NEW;\n\tregdata &= ACC_CODEC_CNTL_WR_CMD;\n\n\tcs_writel(cs5535au, ACC_CODEC_CNTL, regdata);\n\twait_till_cmd_acked(cs5535au, 50);\n}\n\nstatic void snd_cs5535audio_ac97_codec_write(struct snd_ac97 *ac97,\n\t\t\t\t\t     unsigned short reg, unsigned short val)\n{\n\tstruct cs5535audio *cs5535au = ac97->private_data;\n\tsnd_cs5535audio_codec_write(cs5535au, reg, val);\n}\n\nstatic unsigned short snd_cs5535audio_ac97_codec_read(struct snd_ac97 *ac97,\n\t\t\t\t\t\t      unsigned short reg)\n{\n\tstruct cs5535audio *cs5535au = ac97->private_data;\n\treturn snd_cs5535audio_codec_read(cs5535au, reg);\n}\n\nstatic int snd_cs5535audio_mixer(struct cs5535audio *cs5535au)\n{\n\tstruct snd_card *card = cs5535au->card;\n\tstruct snd_ac97_bus *pbus;\n\tstruct snd_ac97_template ac97;\n\tint err;\n\tstatic struct snd_ac97_bus_ops ops = {\n\t\t.write = snd_cs5535audio_ac97_codec_write,\n\t\t.read = snd_cs5535audio_ac97_codec_read,\n\t};\n\n\tif ((err = snd_ac97_bus(card, 0, &ops, NULL, &pbus)) < 0)\n\t\treturn err;\n\n\tmemset(&ac97, 0, sizeof(ac97));\n\tac97.scaps = AC97_SCAP_AUDIO | AC97_SCAP_SKIP_MODEM\n\t\t\t| AC97_SCAP_POWER_SAVE;\n\tac97.private_data = cs5535au;\n\tac97.pci = cs5535au->pci;\n\n\t/* set any OLPC-specific scaps */\n\tolpc_prequirks(card, &ac97);\n\n\tif ((err = snd_ac97_mixer(pbus, &ac97, &cs5535au->ac97)) < 0) {\n\t\tdev_err(card->dev, \"mixer failed\\n\");\n\t\treturn err;\n\t}\n\n\tsnd_ac97_tune_hardware(cs5535au->ac97, ac97_quirks, ac97_quirk);\n\n\terr = olpc_quirks(card, cs5535au->ac97);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"olpc quirks failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void process_bm0_irq(struct cs5535audio *cs5535au)\n{\n\tu8 bm_stat;\n\tspin_lock(&cs5535au->reg_lock);\n\tbm_stat = cs_readb(cs5535au, ACC_BM0_STATUS);\n\tspin_unlock(&cs5535au->reg_lock);\n\tif (bm_stat & EOP) {\n\t\tstruct cs5535audio_dma *dma;\n\t\tdma = cs5535au->playback_substream->runtime->private_data;\n\t\tsnd_pcm_period_elapsed(cs5535au->playback_substream);\n\t} else {\n\t\tdev_err(cs5535au->card->dev,\n\t\t\t\"unexpected bm0 irq src, bm_stat=%x\\n\",\n\t\t\tbm_stat);\n\t}\n}\n\nstatic void process_bm1_irq(struct cs5535audio *cs5535au)\n{\n\tu8 bm_stat;\n\tspin_lock(&cs5535au->reg_lock);\n\tbm_stat = cs_readb(cs5535au, ACC_BM1_STATUS);\n\tspin_unlock(&cs5535au->reg_lock);\n\tif (bm_stat & EOP) {\n\t\tstruct cs5535audio_dma *dma;\n\t\tdma = cs5535au->capture_substream->runtime->private_data;\n\t\tsnd_pcm_period_elapsed(cs5535au->capture_substream);\n\t}\n}\n\nstatic irqreturn_t snd_cs5535audio_interrupt(int irq, void *dev_id)\n{\n\tu16 acc_irq_stat;\n\tunsigned char count;\n\tstruct cs5535audio *cs5535au = dev_id;\n\n\tif (cs5535au == NULL)\n\t\treturn IRQ_NONE;\n\n\tacc_irq_stat = cs_readw(cs5535au, ACC_IRQ_STATUS);\n\n\tif (!acc_irq_stat)\n\t\treturn IRQ_NONE;\n\tfor (count = 0; count < 4; count++) {\n\t\tif (acc_irq_stat & (1 << count)) {\n\t\t\tswitch (count) {\n\t\t\tcase IRQ_STS:\n\t\t\t\tcs_readl(cs5535au, ACC_GPIO_STATUS);\n\t\t\t\tbreak;\n\t\t\tcase WU_IRQ_STS:\n\t\t\t\tcs_readl(cs5535au, ACC_GPIO_STATUS);\n\t\t\t\tbreak;\n\t\t\tcase BM0_IRQ_STS:\n\t\t\t\tprocess_bm0_irq(cs5535au);\n\t\t\t\tbreak;\n\t\t\tcase BM1_IRQ_STS:\n\t\t\t\tprocess_bm1_irq(cs5535au);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(cs5535au->card->dev,\n\t\t\t\t\t\"Unexpected irq src: 0x%x\\n\",\n\t\t\t\t\tacc_irq_stat);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int snd_cs5535audio_free(struct cs5535audio *cs5535au)\n{\n\tsynchronize_irq(cs5535au->irq);\n\tpci_set_power_state(cs5535au->pci, PCI_D3hot);\n\n\tif (cs5535au->irq >= 0)\n\t\tfree_irq(cs5535au->irq, cs5535au);\n\n\tpci_release_regions(cs5535au->pci);\n\tpci_disable_device(cs5535au->pci);\n\tkfree(cs5535au);\n\treturn 0;\n}\n\nstatic int snd_cs5535audio_dev_free(struct snd_device *device)\n{\n\tstruct cs5535audio *cs5535au = device->device_data;\n\treturn snd_cs5535audio_free(cs5535au);\n}\n\nstatic int snd_cs5535audio_create(struct snd_card *card,\n\t\t\t\t  struct pci_dev *pci,\n\t\t\t\t  struct cs5535audio **rcs5535au)\n{\n\tstruct cs5535audio *cs5535au;\n\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free =\tsnd_cs5535audio_dev_free,\n\t};\n\n\t*rcs5535au = NULL;\n\tif ((err = pci_enable_device(pci)) < 0)\n\t\treturn err;\n\n\tif (dma_set_mask(&pci->dev, DMA_BIT_MASK(32)) < 0 ||\n\t    dma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(32)) < 0) {\n\t\tdev_warn(card->dev, \"unable to get 32bit dma\\n\");\n\t\terr = -ENXIO;\n\t\tgoto pcifail;\n\t}\n\n\tcs5535au = kzalloc(sizeof(*cs5535au), GFP_KERNEL);\n\tif (cs5535au == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto pcifail;\n\t}\n\n\tspin_lock_init(&cs5535au->reg_lock);\n\tcs5535au->card = card;\n\tcs5535au->pci = pci;\n\tcs5535au->irq = -1;\n\n\tif ((err = pci_request_regions(pci, \"CS5535 Audio\")) < 0) {\n\t\tkfree(cs5535au);\n\t\tgoto pcifail;\n\t}\n\n\tcs5535au->port = pci_resource_start(pci, 0);\n\n\tif (request_irq(pci->irq, snd_cs5535audio_interrupt,\n\t\t\tIRQF_SHARED, KBUILD_MODNAME, cs5535au)) {\n\t\tdev_err(card->dev, \"unable to grab IRQ %d\\n\", pci->irq);\n\t\terr = -EBUSY;\n\t\tgoto sndfail;\n\t}\n\n\tcs5535au->irq = pci->irq;\n\tpci_set_master(pci);\n\n\tif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\n\t\t\t\t  cs5535au, &ops)) < 0)\n\t\tgoto sndfail;\n\n\t*rcs5535au = cs5535au;\n\treturn 0;\n\nsndfail: /* leave the device alive, just kill the snd */\n\tsnd_cs5535audio_free(cs5535au);\n\treturn err;\n\npcifail:\n\tpci_disable_device(pci);\n\treturn err;\n}\n\nstatic int snd_cs5535audio_probe(struct pci_dev *pci,\n\t\t\t\t const struct pci_device_id *pci_id)\n{\n\tstatic int dev;\n\tstruct snd_card *card;\n\tstruct cs5535audio *cs5535au;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tif ((err = snd_cs5535audio_create(card, pci, &cs5535au)) < 0)\n\t\tgoto probefail_out;\n\n\tcard->private_data = cs5535au;\n\n\tif ((err = snd_cs5535audio_mixer(cs5535au)) < 0)\n\t\tgoto probefail_out;\n\n\tif ((err = snd_cs5535audio_pcm(cs5535au)) < 0)\n\t\tgoto probefail_out;\n\n\tstrcpy(card->driver, DRIVER_NAME);\n\n\tstrcpy(card->shortname, \"CS5535 Audio\");\n\tsprintf(card->longname, \"%s %s at 0x%lx, irq %i\",\n\t\tcard->shortname, card->driver,\n\t\tcs5535au->port, cs5535au->irq);\n\n\tif ((err = snd_card_register(card)) < 0)\n\t\tgoto probefail_out;\n\n\tpci_set_drvdata(pci, card);\n\tdev++;\n\treturn 0;\n\nprobefail_out:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void snd_cs5535audio_remove(struct pci_dev *pci)\n{\n\tolpc_quirks_cleanup();\n\tsnd_card_free(pci_get_drvdata(pci));\n}\n\nstatic struct pci_driver cs5535audio_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = snd_cs5535audio_ids,\n\t.probe = snd_cs5535audio_probe,\n\t.remove = snd_cs5535audio_remove,\n#ifdef CONFIG_PM_SLEEP\n\t.driver = {\n\t\t.pm = &snd_cs5535audio_pm,\n\t},\n#endif\n};\n\nmodule_pci_driver(cs5535audio_driver);\n\nMODULE_AUTHOR(\"Jaya Kumar\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CS5535 Audio\");\nMODULE_SUPPORTED_DEVICE(\"CS5535 Audio\");\n"
}