{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains A:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "6082",
    "text": "(* *********************************************************************)\n(*                                                                     *)\n(*              The Compcert verified compiler                         *)\n(*                                                                     *)\n(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)\n(*                                                                     *)\n(*  Copyright Institut National de Recherche en Informatique et en     *)\n(*  Automatique.  All rights reserved.  This file is distributed       *)\n(*  under the terms of the INRIA Non-Commercial License Agreement.     *)\n(*                                                                     *)\n(* *********************************************************************)\n\n(** Postorder renumbering of RTL control-flow graphs. *)\n\nRequire Import Coqlib Maps Postorder.\nRequire Import AST Linking.\nRequire Import Values Memory Globalenvs Events Smallstep.\nRequire Import Op Registers RTL Renumber.\n\nDefinition match_prog (p tp: RTL.program) :=\n  match_program (fun ctx f tf => tf = transf_fundef f) eq p tp.\n\nLemma transf_program_match:\n  forall p, match_prog p (transf_program p).\nProof.\n  intros. eapply match_transform_program; eauto.\nQed.\n\nSection PRESERVATION.\n\nVariables prog tprog: program.\nHypothesis TRANSL: match_prog prog tprog.\nLet ge := Genv.globalenv prog.\nLet tge := Genv.globalenv tprog.\n\nLemma functions_translated:\n  forall v f,\n  Genv.find_funct ge v = Some f ->\n  Genv.find_funct tge v = Some (transf_fundef f).\nProof (Genv.find_funct_transf TRANSL).\n\nLemma function_ptr_translated:\n  forall v f,\n  Genv.find_funct_ptr ge v = Some f ->\n  Genv.find_funct_ptr tge v = Some (transf_fundef f).\nProof (Genv.find_funct_ptr_transf TRANSL).\n\nLemma symbols_preserved:\n  forall id,\n  Genv.find_symbol tge id = Genv.find_symbol ge id.\nProof (Genv.find_symbol_transf TRANSL).\n\nLemma senv_preserved:\n  Senv.equiv ge tge.\nProof (Genv.senv_transf TRANSL).\n\nLemma sig_preserved:\n  forall f, funsig (transf_fundef f) = funsig f.\nProof.\n  destruct f; reflexivity.\nQed.\n\nLemma find_function_translated:\n  forall ros rs fd,\n  find_function ge ros rs = Some fd ->\n  find_function tge ros rs = Some (transf_fundef fd).\nProof.\n  unfold find_function; intros. destruct ros as [r|id].\n  eapply functions_translated; eauto.\n  rewrite symbols_preserved. destruct (Genv.find_symbol ge id); try congruence.\n  eapply function_ptr_translated; eauto.\nQed.\n\n(** Effect of an injective renaming of nodes on a CFG. *)\n\nSection RENUMBER.\n\nVariable f: PTree.t positive.\n\nHypothesis f_inj: forall x1 x2 y, f!x1 = Some y -> f!x2 = Some y -> x1 = x2.\n\nLemma renum_cfg_nodes:\n  forall c x y i,\n  c!x = Some i -> f!x = Some y -> (renum_cfg f c)!y = Some(renum_instr f i).\nProof.\n  set (P := fun (c c': code) =>\n              forall x y i, c!x = Some i -> f!x = Some y -> c'!y = Some(renum_instr f i)).\n  intros c0. change (P c0 (renum_cfg f c0)). unfold renum_cfg.\n  apply PTree_Properties.fold_rec; unfold P; intros.\n  (* extensionality *)\n  eapply H0; eauto. rewrite H; auto.\n  (* base *)\n  rewrite PTree.gempty in H; congruence.\n  (* induction *)\n  rewrite PTree.gsspec in H2. unfold renum_node. destruct (peq x k).\n  inv H2. rewrite H3. apply PTree.gss.\n  destruct f!k as [y'|] eqn:?.\n  rewrite PTree.gso. eauto. red; intros; subst y'. elim n. eapply f_inj; eauto.\n  eauto.\nQed.\n\nEnd RENUMBER.\n\nDefinition pnum (f: function) := postorder (successors_map f) f.(fn_entrypoint).\n\nDefinition reach (f: function) (pc: node) := reachable (successors_map f) f.(fn_entrypoint) pc.\n\nLemma transf_function_at:\n  forall f pc i,\n  f.(fn_code)!pc = Some i ->\n  reach f pc ->\n  (transf_function f).(fn_code)!(renum_pc (pnum f) pc) = Some(renum_instr (pnum f) i).\nProof.\n  intros.\n  destruct (postorder_correct (successors_map f) f.(fn_entrypoint)) as [A B].\n  fold (pnum f) in *.\n  unfold renum_pc. destruct (pnum f)! pc as [pc'|] eqn:?.\n  simpl. eapply renum_cfg_nodes; eauto.\n  elim (B pc); auto. unfold successors_map. rewrite PTree.gmap1. rewrite H. simpl. congruence.\nQed.\n\nLtac TR_AT :=\n  match goal with\n  | [ A: (fn_code _)!_ = Some _ , B: reach _ _ |- _ ] =>\n        generalize (transf_function_at _ _ _ A B); simpl renum_instr; intros\n  end.\n\nLemma reach_succ:\n  forall f pc i s,\n  f.(fn_code)!pc = Some i -> In s (successors_instr i) ->\n  reach f pc -> reach f s.\nProof.\n  unfold reach; intros. econstructor; eauto.\n  unfold successors_map. rewrite PTree.gmap1. rewrite H. auto.\nQed.\n\nInductive match_frames: RTL.stackframe -> RTL.stackframe -> Prop :=\n  | match_frames_intro: forall res f sp pc rs\n        (REACH: reach f pc),\n      match_frames (Stackframe res f sp pc rs)\n                   (Stackframe res (transf_function f) sp (renum_pc (pnum f) pc) rs).\n\nInductive match_states: RTL.state -> RTL.state -> Prop :=\n  | match_regular_states: forall stk f sp pc rs m stk'\n        (STACKS: list_forall2 match_frames stk stk')\n        (REACH: reach f pc),\n      match_states (State stk f sp pc rs m)\n                   (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m)\n  | match_callstates: forall stk f args m stk'\n        (STACKS: list_forall2 match_frames stk stk'),\n      match_states (Callstate stk f args m)\n                   (Callstate stk' (transf_fundef f) args m)\n  | match_returnstates: forall stk v m stk'\n        (STACKS: list_forall2 match_frames stk stk'),\n      match_states (Returnstate stk v m)\n                   (Returnstate stk' v m).\n\nLemma step_simulation:\n  forall S1 t S2, RTL.step ge S1 t S2 ->\n  forall S1', match_states S1 S1' ->\n  exists S2', RTL.step tge S1' t S2' /\\ match_states S2 S2'.\nProof.\n  induction 1; intros S1' MS; inv MS; try TR_AT.\n(* nop *)\n  econstructor; split. eapply exec_Inop; eauto.\n  constructor; auto. eapply reach_succ; eauto. simpl; auto.\n(* op *)\n  econstructor; split.\n  eapply exec_Iop; eauto.\n  instantiate (1 := v). rewrite <- H0. apply eval_operation_preserved. exact symbols_preserved.\n  constructor; auto. eapply reach_succ; eauto. simpl; auto.\n(* load *)\n  econstructor; split.\n  assert (eval_addressing tge sp addr rs ## args = Some a).\n  rewrite <- H0. apply eval_addressing_preserved. exact symbols_preserved.\n  eapply exec_Iload; eauto.\n  constructor; auto. eapply reach_succ; eauto. simpl; auto.\n(* store *)\n  econstructor; split.\n  assert (eval_addressing tge sp addr rs ## args = Some a).\n  rewrite <- H0. apply eval_addressing_preserved. exact symbols_preserved.\n  eapply exec_Istore; eauto.\n  constructor; auto. eapply reach_succ; eauto. simpl; auto.\n(* call *)\n  econstructor; split.\n  eapply exec_Icall with (fd := transf_fundef fd); eauto.\n    eapply find_function_translated; eauto.\n    apply sig_preserved.\n  constructor. constructor; auto. constructor. eapply reach_succ; eauto. simpl; auto.\n(* tailcall *)\n  econstructor; split.\n  eapply exec_Itailcall with (fd := transf_fundef fd); eauto.\n    eapply find_function_translated; eauto.\n    apply sig_preserved.\n  constructor. auto.\n(* builtin *)\n  econstructor; split.\n  eapply exec_Ibuiltin; eauto.\n    eapply eval_builtin_args_preserved with (ge1 := ge); eauto. exact symbols_preserved.\n    eapply external_call_symbols_preserved; eauto. apply senv_preserved.\n  constructor; auto. eapply reach_succ; eauto. simpl; auto.\n(* cond *)\n  econstructor; split.\n  eapply exec_Icond; eauto.\n  replace (if b then renum_pc (pnum f) ifso else renum_pc (pnum f) ifnot)\n     with (renum_pc (pnum f) (if b then ifso else ifnot)).\n  constructor; auto. eapply reach_succ; eauto. simpl. destruct b; auto.\n  destruct b; auto.\n(* jumptbl *)\n  econstructor; split.\n  eapply exec_Ijumptable; eauto. rewrite list_nth_z_map. rewrite H1. simpl; eauto.\n  constructor; auto. eapply reach_succ; eauto. simpl. eapply list_nth_z_in; eauto.\n(* return *)\n  econstructor; split.\n  eapply exec_Ireturn; eauto.\n  constructor; auto.\n(* internal function *)\n  simpl. econstructor; split.\n  eapply exec_function_internal; eauto.\n  constructor; auto. unfold reach. constructor.\n(* external function *)\n  econstructor; split.\n  eapply exec_function_external; eauto.\n    eapply external_call_symbols_preserved; eauto. apply senv_preserved.\n  constructor; auto.\n(* return *)\n  inv STACKS. inv H1.\n  econstructor; split.\n  eapply exec_return; eauto.\n  constructor; auto.\nQed.\n\nLemma transf_initial_states:\n  forall S1, RTL.initial_state prog S1 ->\n  exists S2, RTL.initial_state tprog S2 /\\ match_states S1 S2.\nProof.\n  intros. inv H. econstructor; split.\n  econstructor.\n    eapply (Genv.init_mem_transf TRANSL); eauto.\n    rewrite symbols_preserved. rewrite (match_program_main TRANSL). eauto.\n    eapply function_ptr_translated; eauto.\n    rewrite <- H3; apply sig_preserved.\n  constructor. constructor.\nQed.\n\nLemma transf_final_states:\n  forall S1 S2 r, match_states S1 S2 -> RTL.final_state S1 r -> RTL.final_state S2 r.\nProof.\n  intros. inv H0. inv H. inv STACKS. constructor.\nQed.\n\nTheorem transf_program_correct:\n  forward_simulation (RTL.semantics prog) (RTL.semantics tprog).\nProof.\n  eapply forward_simulation_step.\n  apply senv_preserved.\n  eexact transf_initial_states.\n  eexact transf_final_states.\n  exact step_simulation.\nQed.\n\nEnd PRESERVATION.\n\n\n\n\n\n\n\n"
}