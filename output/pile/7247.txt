{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 5 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7247",
    "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.brooklyn.util.core.internal.ssh.sshj;\n\nimport static com.google.common.base.Objects.equal;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport net.schmizz.sshj.SSHClient;\nimport net.schmizz.sshj.transport.verification.PromiscuousVerifier;\nimport net.schmizz.sshj.userauth.keyprovider.OpenSSHKeyFile;\nimport net.schmizz.sshj.userauth.password.PasswordUtils;\n\nimport org.apache.brooklyn.util.core.internal.ssh.SshAbstractTool.SshAction;\nimport org.apache.brooklyn.util.groovy.GroovyJavaMethods;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Objects;\nimport com.google.common.net.HostAndPort;\n\n/** based on code from jclouds */\npublic class SshjClientConnection implements SshAction<SSHClient> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SshjClientConnection.class);\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n\n        protected HostAndPort hostAndPort;\n        protected String username;\n        protected String password;\n        protected String privateKeyPassphrase;\n        protected String privateKeyData;\n        protected File privateKeyFile;\n        protected long connectTimeout;\n        protected long sessionTimeout;\n        protected boolean strictHostKeyChecking;\n\n        public Builder hostAndPort(HostAndPort hostAndPort) {\n            this.hostAndPort = hostAndPort;\n            return this;\n        }\n\n        public Builder username(String username) {\n            this.username = username;\n            return this;\n        }\n\n        public Builder password(String val) {\n            this.password = val;\n            return this;\n        }\n\n        /** @deprecated use privateKeyData */\n        public Builder privateKey(String val) {\n            this.privateKeyData = val;\n            return this;\n        }\n\n        public Builder privateKeyPassphrase(String val) {\n            this.privateKeyPassphrase = val;\n            return this;\n        }\n        \n        public Builder privateKeyData(String val) {\n            this.privateKeyData = val;\n            return this;\n        }\n        \n        public Builder privateKeyFile(File val) {\n            this.privateKeyFile = val;\n            return this;\n        }\n        \n        public Builder strictHostKeyChecking(boolean val) {\n            this.strictHostKeyChecking = val;\n            return this;\n        }\n\n        public Builder connectTimeout(long connectTimeout) {\n            this.connectTimeout = connectTimeout;\n            return this;\n        }\n\n        public Builder sessionTimeout(long sessionTimeout) {\n            this.sessionTimeout = sessionTimeout;\n            return this;\n        }\n\n        public SshjClientConnection build() {\n            return new SshjClientConnection(this);\n        }\n\n        protected static Builder fromSSHClientConnection(SshjClientConnection in) {\n            return new Builder().hostAndPort(in.getHostAndPort()).connectTimeout(in.getConnectTimeout()).sessionTimeout(\n                    in.getSessionTimeout()).username(in.username).password(in.password).privateKey(in.privateKeyData).privateKeyFile(in.privateKeyFile);\n        }\n    }\n\n    private final HostAndPort hostAndPort;\n    private final String username;\n    private final String password;\n    private final String privateKeyPassphrase;\n    private final String privateKeyData;\n    private final File privateKeyFile;\n    private final boolean strictHostKeyChecking;\n    private final int connectTimeout;\n    private final int sessionTimeout;\n    \n    SSHClient ssh;\n\n    private SshjClientConnection(Builder builder) {\n        this.hostAndPort = checkNotNull(builder.hostAndPort);\n        this.username = builder.username;\n        this.password = builder.password;\n        this.privateKeyPassphrase = builder.privateKeyPassphrase;\n        this.privateKeyData = builder.privateKeyData;\n        this.privateKeyFile = builder.privateKeyFile;\n        this.strictHostKeyChecking = builder.strictHostKeyChecking;\n        this.connectTimeout = checkInt(\"connectTimeout\", builder.connectTimeout, Integer.MAX_VALUE);\n        this.sessionTimeout = checkInt(\"sessionTimeout\", builder.sessionTimeout, Integer.MAX_VALUE);\n    }\n\n    static Integer checkInt(String context, long value, Integer ifTooLarge) {\n        if (value > Integer.MAX_VALUE) {\n            LOG.warn(\"Value '\"+value+\"' for \"+context+\" too large in SshjClientConnection; using \"+value);\n            return ifTooLarge;\n        }\n        return (int)value;\n    }\n\n    public boolean isConnected() {\n        return ssh != null && ssh.isConnected();\n    }\n\n    public boolean isAuthenticated() {\n        return ssh != null && ssh.isAuthenticated();\n    }\n\n    @Override\n    public void clear() {\n        if (ssh != null && ssh.isConnected()) {\n            try {\n                if (LOG.isTraceEnabled()) LOG.trace(\"Disconnecting SshjClientConnection {} ({})\", this, System.identityHashCode(this));\n                ssh.disconnect();\n            } catch (IOException e) {\n                if (LOG.isDebugEnabled()) LOG.debug(\"<< exception disconnecting from {}: {}\", e, e.getMessage());\n            }\n        }\n        ssh = null;\n    }\n\n    @Override\n    public SSHClient create() throws Exception {\n        if (LOG.isTraceEnabled()) LOG.trace(\"Connecting SshjClientConnection {} ({})\", this, System.identityHashCode(this));\n        ssh = new net.schmizz.sshj.SSHClient();\n        if (!strictHostKeyChecking) {\n            ssh.addHostKeyVerifier(new PromiscuousVerifier());\n        }\n        if (connectTimeout != 0) {\n            ssh.setConnectTimeout(connectTimeout);\n        }\n        if (sessionTimeout != 0) {\n            ssh.setTimeout(sessionTimeout);\n        }\n        ssh.connect(hostAndPort.getHostText(), hostAndPort.getPortOrDefault(22));\n        \n        if (password != null) {\n            ssh.authPassword(username, password);\n        } else if (privateKeyData != null) {\n            OpenSSHKeyFile key = new OpenSSHKeyFile();\n            key.init(privateKeyData, null, \n                    GroovyJavaMethods.truth(privateKeyPassphrase) ? \n                            PasswordUtils.createOneOff(privateKeyPassphrase.toCharArray())\n                            : null);\n            ssh.authPublickey(username, key);\n        } else if (privateKeyFile != null) {\n            OpenSSHKeyFile key = new OpenSSHKeyFile();\n            key.init(privateKeyFile, \n                    GroovyJavaMethods.truth(privateKeyPassphrase) ? \n                            PasswordUtils.createOneOff(privateKeyPassphrase.toCharArray())\n                            : null);\n            ssh.authPublickey(username, key);\n        } else {\n            // Accept defaults (in ~/.ssh)\n            ssh.authPublickey(username);\n        }\n        \n        return ssh;\n    }\n\n    /**\n     * @return host and port, where port if not present defaults to {@code 22}\n     */\n    public HostAndPort getHostAndPort() {\n        return hostAndPort;\n    }\n\n    /**\n     * @return username used in this ssh\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * \n     * @return how long to wait for the initial connection to be made\n     */\n    public int getConnectTimeout() {\n        return connectTimeout;\n    }\n\n    /**\n     * \n     * @return how long to keep the ssh open, or {@code 0} for indefinitely\n     */\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    /**\n     * \n     * @return the current ssh or {@code null} if not connected\n     */\n    public SSHClient getSSHClient() {\n        return ssh;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        SshjClientConnection that = SshjClientConnection.class.cast(o);\n        return equal(this.hostAndPort, that.hostAndPort) && equal(this.username, that.username) \n                && equal(this.password, that.password) && equal(this.privateKeyData, that.privateKeyData)\n                && equal(this.privateKeyFile, that.privateKeyFile) && equal(this.ssh, that.ssh);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(hostAndPort, username, password, privateKeyData, ssh);\n    }\n\n    @Override\n    public String toString() {\n        return Objects.toStringHelper(\"\")\n                .add(\"hostAndPort\", hostAndPort)\n                .add(\"user\", username)\n                .add(\"ssh\", ssh != null ? ssh.hashCode() : null)\n                .add(\"password\", (password != null ? \"xxxxxx\" : null))\n                .add(\"privateKeyFile\", privateKeyFile)\n                .add(\"privateKey\", (privateKeyData != null ? \"xxxxxx\" : null))\n                .add(\"connectTimeout\", connectTimeout)\n                .add(\"sessionTimeout\", sessionTimeout).toString();\n    }\n}\n"
}