{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['most of the constant pool, as well as the code of the methods, will just get copied here. (0.196)']."
        }
    ],
    "doc_id": "3562",
    "text": "Q:\n\nJava bytecode asm - How can I create a clone of a class with only the class name changed?\n\nJava asm - How can I create a clone of a class with only the class name changed ?\nI know that there's a simple way to modify the class name using asm SimpleRemapper, but I just want the outer class name changed without modifying the class names used in the methods. (please see below example)\nBasically if I have a target class\npublic class Target {\n  public Target clone(...) ...\n  public int compare(another: Target) ...\n}\n\nI just wanted to create a clone that looks as:\npublic class ClonedTarget {\n  public Target clone(...) ...\n  public int compare(another: Target) ...\n}\n\n(Note that the return type of clone and arg type of compare hasn't changed. This is intentional for my use case).\n\nA:\n\nCloning a class and changing the name and only the name, i.e. leave every other class reference as-is, is actually very easy with the ASM API.\nClassReader cr = new ClassReader(Target.class.getResourceAsStream(\"Target.class\"));\nClassWriter cw = new ClassWriter(cr, 0);\ncr.accept(new ClassVisitor(Opcodes.ASM5, cw) {\n    @Override\n    public void visit(int version, int access, String name,\n                      String signature, String superName, String[] interfaces) {\n        super.visit(version, access, \"ClonedTarget\", signature, superName, interfaces);\n    }\n}, 0);\nbyte[] code = cw.toByteArray();\n\nWhen chaining a ClassReader with a ClassWriter, the ClassVisitor in the middle only needs to overwrite those methods corresponding to an artifact it wants to change. So, to change the name and nothing else, we only need to override the visit method for the class\u2019 declaration and pass a different name to the super method.\nBy passing the class reader to the class writer\u2019s constructor, we\u2019re even denoting that only little changes will be made, enabling subsequent optimizations of the transform process, i.e. most of the constant pool, as well as the code of the methods, will just get copied here.\n\nIt\u2019s worth considering the implications. On the bytecode level, constructors have the special name <init>, so they keep being constructors in the resulting class, regardless of its name. Trivial constructors calling a superclass constructor may continue to work in the resulting class.\nWhen invoking instance methods on ClonedTarget objects, the this reference has the type ClonedTarget. This fundamental property does not need to be declared and thus, there is no declaration that needs adaptation in this regard.\nHerein lies the problem. The original code assumes that this is of type Target and since nothing has been adapted, the copied code still wrongly assumes that this is of type Target, which can break in various ways.\nConsider:\npublic class Target {\n  public Target clone() { return new Target(); }\n  public int compare(Target t) { return 0;}\n}\n\nThis looks like not being affected by the issue. The generated default constructor just calls super() and will continue to work. The compare method has an unused parameter type left as-is. And the clone() method instantiates Target (unchanged) and returns it, matching the return type Target (unchanged). Seems fine.\nBut what\u2019s not visible here, the clone method overrides the method Object clone() inherited from java.lang.Object and therefore, a bridge method will be generated. This bridge method will have the declaration Object clone() and just delegate to the Target clone() method. The problem is that this delegation is an invocation on this and the assumed type of the invocation target is encoded within the invocation instruction. This will cause a VerifierError.\nGenerally, we can not simply tell apart which invocations are applied on this and which on an unchanged reference, like a parameter or field. It does not even need to have a definite answer. Consider:\npublic void method(Target t, boolean b) {\n    (b? this: t).otherMethod();\n}\n\nImplicitly assuming that this has type Target, it can use this and a Target instance from another source interchangeably. We can not change the this type and keep the parameter type without rewriting the code.\nOther issues arise with visibility. For the renamed class, the verifier will reject unchanged accesses to private members of the original class.\nBesides failing with a VerifyError, problematic code may slip through and cause problems at a later time. Consider:\npublic class Target implements Cloneable {\n    public Target duplicate() {\n        try {\n            return (Target)super.clone();\n        } catch(CloneNotSupportedException ex) {\n            throw new AssertionError();\n        }\n    }\n}\n\nSince this duplicate() does not override a superclass method, there won\u2019t be a bridge method and all unchanged uses of Target are correct from the verifier\u2019s perspective.\nBut the clone() method of Object does not return an instance of Target but of the this\u2019 class, ClonedTarget in the renamed clone. So this will fail with a ClassCastException, only when being executed.\n\nThis doesn\u2019t preclude working use cases for a class with known content. But generally, it\u2019s very fragile.\n\n"
}