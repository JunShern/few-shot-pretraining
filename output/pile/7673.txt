{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7673",
    "text": "Q:\n\nValidation of EditText's does not work\n\nI have a signup screen. It contains a place for the user's full name, email address and password (the user has to confirm their password). \nHowever, it does not work as expected. For the signup button to be enabled the fields have to filled in, in order: top to bottom (this wasn't intended). \nMoreover, the red colour on the confirm password field does not go away and the signup button does not enable unless the characters are shown. The checking to see if there are characters in all the fields seem to be malfunctioning and I am not sure why. The checking works sometimes and doesn't work other times.\nPlease can someone help me optimize this. There are comments in the code to show what each method does.\nThis is the Layout:\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\n    android:orientation=\"vertical\"> \n\n    <EditText\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:inputType=\"textPersonName\"\n        android:hint=\"@string/hintNameField\"\n        android:ems=\"10\"\n        android:id=\"@+id/txtSName\"\n        android:layout_marginTop=\"30dp\"\n        android:layout_marginLeft=\"5dp\"\n        android:layout_marginRight=\"5dp\" />\n\n    <EditText\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:inputType=\"textEmailAddress\"\n        android:hint=\"@string/hintEmailField\"\n        android:ems=\"10\"\n        android:id=\"@+id/txtSEmailAddress\"\n        android:layout_marginTop=\"15dp\"\n        android:layout_marginLeft=\"5dp\"\n        android:layout_marginRight=\"5dp\" />\n\n    <EditText\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:inputType=\"textPassword\"\n        android:ems=\"10\"\n        android:id=\"@+id/txtSPassword\"\n        android:hint=\"@string/hintPasswordField\"\n        android:layout_marginTop=\"15dp\"\n        android:layout_marginLeft=\"5dp\"\n        android:layout_marginRight=\"5dp\"/>\n\n    <EditText\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"wrap_content\"\n        android:inputType=\"textPassword\"\n        android:ems=\"10\"\n        android:id=\"@+id/txtSPasswordConfirm\"\n        android:hint=\"@string/hintPasswordConfirmField\"\n        android:layout_marginTop=\"15dp\"\n        android:layout_marginLeft=\"5dp\"\n        android:layout_marginRight=\"5dp\"\n        />\n\n    <CheckBox\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@string/showPasswordCheckBox\"\n        android:id=\"@+id/showPasswordCheckBox\"\n        android:layout_marginTop=\"10dp\"\n        android:layout_marginLeft=\"5dp\"/>\n\n    <Button\n        android:layout_width=\"200dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@string/btnSignUp\"\n        android:id=\"@+id/btnSignUp\"\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_marginTop=\"10dp\"\n        android:enabled=\"false\"\n        />\n\n</LinearLayout>\n\nThis is the Java class for the layout:\n//this is the full name field\nsnameTxt = (EditText) findViewById(R.id.txtSName);\nsnameTxt.addTextChangedListener(new TextWatcher() {\n    @Override\n    public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n    }\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n\n    }\n\n    @Override\n    public void afterTextChanged(Editable s) {\n\n    }\n});\n\nsnameTxt.setOnLongClickListener(new View.OnLongClickListener() {\n    @Override\n    public boolean onLongClick(View v) {\n        Toast.makeText(getApplicationContext(), \"Please enter your full name\", Toast.LENGTH_SHORT).show();\n        return false;\n    }\n});\n\n//this is the email address field\nsemailTxt = (EditText) findViewById(R.id.txtSEmailAddress);\nsemailTxt.addTextChangedListener(new TextWatcher() {\n    @Override\n    public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\n    }\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n\n    }\n\n    @Override\n    public void afterTextChanged(Editable s) {\n\n    }\n});\n\nsemailTxt.setOnLongClickListener(new View.OnLongClickListener() {\n    @Override\n    public boolean onLongClick(View v) {\n        Toast.makeText(getApplicationContext(), \"Please enter the email address to be associated with your account\", Toast.LENGTH_SHORT).show();\n        return false;\n    }\n});\n\n//this is the password field\nspasswordTxt = (EditText) findViewById(R.id.txtSPassword);\n    spasswordTxt.addTextChangedListener(new TextWatcher() {\n        @Override\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n    }\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        //the code to enable the button. This needs the most optimization\n        if (String.valueOf(spasswordTxt.getText()).trim().length() > 3 && \n            String.valueOf(snameTxt.getText()).trim().length() > 0 && \n            String.valueOf(semailTxt.getText()).trim().length() > 0) {\n            signupBtn.setEnabled(true);\n        } else {\n            signupBtn.setEnabled(false);\n        }\n        if (String.valueOf(spasswordTxt.getText()).trim().length() < 3) {\n            signupBtn.setEnabled(false);\n        }\n        if (String.valueOf(snameTxt.getText()).trim().length() < 1) {\n            signupBtn.setEnabled(false);\n        }\n        if (String.valueOf(semailTxt.getText()).trim().length() < 1) {\n            signupBtn.setEnabled(false);\n        }\n    }\n\n    @Override\n    public void afterTextChanged(Editable s) {\n\n    }\n});\n\nspasswordTxt.setOnLongClickListener(new View.OnLongClickListener() {\n    @Override\n    public boolean onLongClick(View v) {\n        Toast.makeText(getApplicationContext(), \n            \"Please enter a password with a minimum of 4 characters\", Toast.LENGTH_SHORT).show();\n        return false;\n    }\n});\n\nspasswordconfirmTxt = (EditText) findViewById(R.id.txtSPasswordConfirm);\nspasswordconfirmTxt.addTextChangedListener(new TextWatcher() {\n    @Override\n    public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\n    }\n\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n        //if the password and the password confirm fields do not match \n        //then the password confirm field goes red. This also needs optimization\n        if (spasswordconfirmTxt.getText().toString().equals(spasswordTxt.getText().toString())) {\n            spasswordconfirmTxt.getBackground().clearColorFilter();\n        }\n        else {\n            spasswordconfirmTxt.getBackground().setColorFilter(Color.RED, PorterDuff.Mode.SRC_ATOP);\n            signupBtn.setEnabled(false);\n        }\n    }\n\n    @Override\n    public void afterTextChanged(Editable s) {\n\n    }\n});\n\n //this allows the password field characters to be shown\nfinal CheckBox showPasswordCheckBox = (CheckBox) findViewById(R.id.showPasswordCheckBox);\nshowPasswordCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n    @Override\n    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n        if(!isChecked){\n            spasswordTxt.setTransformationMethod(PasswordTransformationMethod.getInstance());\n            spasswordconfirmTxt.setTransformationMethod(PasswordTransformationMethod.getInstance());\n        }\n        else {\n            spasswordTxt.setTransformationMethod(HideReturnsTransformationMethod.getInstance());\n            spasswordconfirmTxt.setTransformationMethod(HideReturnsTransformationMethod.getInstance());\n        }\n    }\n});\n\nA:\n\nI sugget you to use some convenience methods, this would help you to write code which is clearer. For example use this method to check if a field contains a valid strihg:\n/ Checks if a String actually carries information\npublic static boolean isValidString(String string) {\n    if (string == null) {\n        return false;\n    } else {\n        String s = string.trim(); // Remove blank spaces at start and at end\n        if ((s.length() == 0) || (s.equalsIgnoreCase(\"\"))) return false;\n        else return true;\n    }\n}\n\nGoing specifically to your problem, I see that the actual validation of the fields is done in the onTextChanged(...) method of the password field, therefore it's obvious that filling the password field at last would carry out the validation, otherwise if you fill the password for first and then go to the other fields, their onTextChanged(...) simply does nothing, therefore the validation isn't carried out. You should add a method which is called in every single onTextChanged(...) callback!\nFor the red colored field, I am not sure if that's the correct approach to adopt, just try to use some different ways to give visual clues, See my blog post for example.\nHowever I see that you're not doing the check and therefore not enabling properly the submit button when onTextChanged(...) is fired in the confirmation field, I think you forgot something:\n@Override\npublic void onTextChanged(CharSequence s, int start, int before, int count) {\n    //if the password and the password confirm fields do not match \n    //then the password confirm field goes red. This also needs optimization\n    if (spasswordconfirmTxt.getText().toString().equals(spasswordTxt.getText().toString())) {\n        spasswordconfirmTxt.getBackground().clearColorFilter();\n        signupBtn.setEnabled(true); // Enable the button if everything is ok\n    }\n    else {\n        spasswordconfirmTxt.getBackground().setColorFilter(Color.RED, PorterDuff.Mode.SRC_ATOP);\n        signupBtn.setEnabled(false);\n    }\n}\n\nSo bottom line is, create another method from which you check all the fields together, which will also enable the button if all check are ok, and make a call to that method whenever ANY of onTextChanged(...) callbacks is fired!\nCheers!\n\n"
}