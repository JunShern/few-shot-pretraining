{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "646",
    "text": "Q:\n\nc++, object created on the heap vs. local - when returning a pointer\n\nThis is a follow up question from \nSafe in C# not in C++, simple return of pointer / reference,\nIs this:\nperson* NewPerson(void)\n{\n  person p;\n  /* ... */\n  return &p; //return pointer to person.\n}\n\nthe same as?\nperson* NewPerson(void)\n{\n  person* pp = new person;\n\n  return pp; //return pointer to person.\n}\n\nI know that the first one is a bad idea, because it will be a wild pointer.\nIn the second case, will the object be safe on the heap - and like in c#\ngo out of scope when the last reference is gone to it?\n\nA:\n\nYes, the second case is safe.\nBut the caller will need to delete the returned pointer. You could change this to use boost::shared_ptr and it will be destroyed when it is no longer in use:\nboost::shared_ptr<person> NewPerson()\n{\n    boost::shared_ptr<person> pp = boost::make_shared<person>();\n\n    return pp;\n}\n\nIf C++11 then you can use std::shared_ptr or std::unique_ptr.\n\nA:\n\nIt's safe, the object will still be alive after the return.\nBut don't expect the object to be automatically cleaned up for you in C++. Standard C++ does not have garbage collection. You'll need to delete the object yourself, or use some form of smart pointer.\n\n"
}