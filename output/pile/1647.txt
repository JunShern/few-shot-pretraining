{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 11 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "1647",
    "text": "/**\n * @brief A solver factory that allows one to register solvers, similar to\n * layer factory. During runtime, registered solvers could be called by passing\n * a SolverParameter protobuffer to the CreateSolver function:\n *\n *     SolverRegistry<Dtype>::CreateSolver(param);\n *\n * There are two ways to register a solver. Assuming that we have a solver like:\n *\n *   template <typename Dtype>\n *   class MyAwesomeSolver : public Solver<Dtype> {\n *     // your implementations\n *   };\n *\n * and its type is its C++ class name, but without the \"Solver\" at the end\n * (\"MyAwesomeSolver\" -> \"MyAwesome\").\n *\n * If the solver is going to be created simply by its constructor, in your c++\n * file, add the following line:\n *\n *    REGISTER_SOLVER_CLASS(MyAwesome);\n *\n * Or, if the solver is going to be created by another creator function, in the\n * format of:\n *\n *    template <typename Dtype>\n *    Solver<Dtype*> GetMyAwesomeSolver(const SolverParameter& param) {\n *      // your implementation\n *    }\n *\n * then you can register the creator function instead, like\n *\n * REGISTER_SOLVER_CREATOR(MyAwesome, GetMyAwesomeSolver)\n *\n * Note that each solver type should only be registered once.\n */\n\n#ifndef CAFFE_SOLVER_FACTORY_H_\n#define CAFFE_SOLVER_FACTORY_H_\n\n#include <map>\n#include <string>\n#include <vector>\n\n#include \"caffe/common.hpp\"\n#include \"caffe/proto/caffe.pb.h\"\n\nnamespace caffe {\n\ntemplate <typename Dtype>\nclass Solver;\n\ntemplate <typename Dtype>\nclass SolverRegistry {\n public:\n  typedef Solver<Dtype>* (*Creator)(const SolverParameter&);\n  typedef std::map<string, Creator> CreatorRegistry;\n\n  static CreatorRegistry& Registry() {\n    static CreatorRegistry* g_registry_ = new CreatorRegistry();\n    return *g_registry_;\n  }\n\n  // Adds a creator.\n  static void AddCreator(const string& type, Creator creator) {\n    CreatorRegistry& registry = Registry();\n    CHECK_EQ(registry.count(type), 0)\n        << \"Solver type \" << type << \" already registered.\";\n    registry[type] = creator;\n  }\n\n  // Get a solver using a SolverParameter.\n  static Solver<Dtype>* CreateSolver(const SolverParameter& param) {\n    const string& type = param.type();\n    CreatorRegistry& registry = Registry();\n    CHECK_EQ(registry.count(type), 1) << \"Unknown solver type: \" << type\n        << \" (known types: \" << SolverTypeListString() << \")\";\n    return registry[type](param);\n  }\n\n  static vector<string> SolverTypeList() {\n    CreatorRegistry& registry = Registry();\n    vector<string> solver_types;\n    for (typename CreatorRegistry::iterator iter = registry.begin();\n         iter != registry.end(); ++iter) {\n      solver_types.push_back(iter->first);\n    }\n    return solver_types;\n  }\n\n private:\n  // Solver registry should never be instantiated - everything is done with its\n  // static variables.\n  SolverRegistry() {}\n\n  static string SolverTypeListString() {\n    vector<string> solver_types = SolverTypeList();\n    string solver_types_str;\n    for (vector<string>::iterator iter = solver_types.begin();\n         iter != solver_types.end(); ++iter) {\n      if (iter != solver_types.begin()) {\n        solver_types_str += \", \";\n      }\n      solver_types_str += *iter;\n    }\n    return solver_types_str;\n  }\n};\n\n\ntemplate <typename Dtype>\nclass SolverRegisterer {\n public:\n  SolverRegisterer(const string& type,\n      Solver<Dtype>* (*creator)(const SolverParameter&)) {\n    // LOG(INFO) << \"Registering solver type: \" << type;\n    SolverRegistry<Dtype>::AddCreator(type, creator);\n  }\n};\n\n\n#define REGISTER_SOLVER_CREATOR(type, creator)                                 \\\n  static SolverRegisterer<float> g_creator_f_##type(#type, creator<float>);    \\\n  static SolverRegisterer<double> g_creator_d_##type(#type, creator<double>)   \\\n\n#define REGISTER_SOLVER_CLASS(type)                                            \\\n  template <typename Dtype>                                                    \\\n  Solver<Dtype>* Creator_##type##Solver(                                       \\\n      const SolverParameter& param)                                            \\\n  {                                                                            \\\n    return new type##Solver<Dtype>(param);                                     \\\n  }                                                                            \\\n  REGISTER_SOLVER_CREATOR(type, Creator_##type##Solver)\n\n}  // namespace caffe\n\n#endif  // CAFFE_SOLVER_FACTORY_H_\n"
}