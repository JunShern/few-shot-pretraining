{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 5 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7113",
    "text": "/*\n * This file is part of wl1271\n *\n * Copyright (C) 2008-2010 Nokia Corporation\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * version 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <linux/err.h>\n\n#include \"../wlcore/wlcore.h\"\n#include \"../wlcore/debug.h\"\n#include \"../wlcore/io.h\"\n#include \"../wlcore/acx.h\"\n#include \"../wlcore/tx.h\"\n#include \"../wlcore/rx.h\"\n#include \"../wlcore/boot.h\"\n\n#include \"wl12xx.h\"\n#include \"reg.h\"\n#include \"cmd.h\"\n#include \"acx.h\"\n#include \"scan.h\"\n#include \"event.h\"\n#include \"debugfs.h\"\n\nstatic char *fref_param;\nstatic char *tcxo_param;\n\nstatic struct wlcore_conf wl12xx_conf = {\n\t.sg = {\n\t\t.params = {\n\t\t\t[CONF_SG_ACL_BT_MASTER_MIN_BR] = 10,\n\t\t\t[CONF_SG_ACL_BT_MASTER_MAX_BR] = 180,\n\t\t\t[CONF_SG_ACL_BT_SLAVE_MIN_BR] = 10,\n\t\t\t[CONF_SG_ACL_BT_SLAVE_MAX_BR] = 180,\n\t\t\t[CONF_SG_ACL_BT_MASTER_MIN_EDR] = 10,\n\t\t\t[CONF_SG_ACL_BT_MASTER_MAX_EDR] = 80,\n\t\t\t[CONF_SG_ACL_BT_SLAVE_MIN_EDR] = 10,\n\t\t\t[CONF_SG_ACL_BT_SLAVE_MAX_EDR] = 80,\n\t\t\t[CONF_SG_ACL_WLAN_PS_MASTER_BR] = 8,\n\t\t\t[CONF_SG_ACL_WLAN_PS_SLAVE_BR] = 8,\n\t\t\t[CONF_SG_ACL_WLAN_PS_MASTER_EDR] = 20,\n\t\t\t[CONF_SG_ACL_WLAN_PS_SLAVE_EDR] = 20,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_MASTER_MIN_BR] = 20,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_MASTER_MAX_BR] = 35,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_SLAVE_MIN_BR] = 16,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_SLAVE_MAX_BR] = 35,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_MASTER_MIN_EDR] = 32,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_MASTER_MAX_EDR] = 50,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_SLAVE_MIN_EDR] = 28,\n\t\t\t[CONF_SG_ACL_WLAN_ACTIVE_SLAVE_MAX_EDR] = 50,\n\t\t\t[CONF_SG_ACL_ACTIVE_SCAN_WLAN_BR] = 10,\n\t\t\t[CONF_SG_ACL_ACTIVE_SCAN_WLAN_EDR] = 20,\n\t\t\t[CONF_SG_ACL_PASSIVE_SCAN_BT_BR] = 75,\n\t\t\t[CONF_SG_ACL_PASSIVE_SCAN_WLAN_BR] = 15,\n\t\t\t[CONF_SG_ACL_PASSIVE_SCAN_BT_EDR] = 27,\n\t\t\t[CONF_SG_ACL_PASSIVE_SCAN_WLAN_EDR] = 17,\n\t\t\t/* active scan params */\n\t\t\t[CONF_SG_AUTO_SCAN_PROBE_REQ] = 170,\n\t\t\t[CONF_SG_ACTIVE_SCAN_DURATION_FACTOR_HV3] = 50,\n\t\t\t[CONF_SG_ACTIVE_SCAN_DURATION_FACTOR_A2DP] = 100,\n\t\t\t/* passive scan params */\n\t\t\t[CONF_SG_PASSIVE_SCAN_DURATION_FACTOR_A2DP_BR] = 800,\n\t\t\t[CONF_SG_PASSIVE_SCAN_DURATION_FACTOR_A2DP_EDR] = 200,\n\t\t\t[CONF_SG_PASSIVE_SCAN_DURATION_FACTOR_HV3] = 200,\n\t\t\t/* passive scan in dual antenna params */\n\t\t\t[CONF_SG_CONSECUTIVE_HV3_IN_PASSIVE_SCAN] = 0,\n\t\t\t[CONF_SG_BCN_HV3_COLLISION_THRESH_IN_PASSIVE_SCAN] = 0,\n\t\t\t[CONF_SG_TX_RX_PROTECTION_BWIDTH_IN_PASSIVE_SCAN] = 0,\n\t\t\t/* general params */\n\t\t\t[CONF_SG_STA_FORCE_PS_IN_BT_SCO] = 1,\n\t\t\t[CONF_SG_ANTENNA_CONFIGURATION] = 0,\n\t\t\t[CONF_SG_BEACON_MISS_PERCENT] = 60,\n\t\t\t[CONF_SG_DHCP_TIME] = 5000,\n\t\t\t[CONF_SG_RXT] = 1200,\n\t\t\t[CONF_SG_TXT] = 1000,\n\t\t\t[CONF_SG_ADAPTIVE_RXT_TXT] = 1,\n\t\t\t[CONF_SG_GENERAL_USAGE_BIT_MAP] = 3,\n\t\t\t[CONF_SG_HV3_MAX_SERVED] = 6,\n\t\t\t[CONF_SG_PS_POLL_TIMEOUT] = 10,\n\t\t\t[CONF_SG_UPSD_TIMEOUT] = 10,\n\t\t\t[CONF_SG_CONSECUTIVE_CTS_THRESHOLD] = 2,\n\t\t\t[CONF_SG_STA_RX_WINDOW_AFTER_DTIM] = 5,\n\t\t\t[CONF_SG_STA_CONNECTION_PROTECTION_TIME] = 30,\n\t\t\t/* AP params */\n\t\t\t[CONF_AP_BEACON_MISS_TX] = 3,\n\t\t\t[CONF_AP_RX_WINDOW_AFTER_BEACON] = 10,\n\t\t\t[CONF_AP_BEACON_WINDOW_INTERVAL] = 2,\n\t\t\t[CONF_AP_CONNECTION_PROTECTION_TIME] = 0,\n\t\t\t[CONF_AP_BT_ACL_VAL_BT_SERVE_TIME] = 25,\n\t\t\t[CONF_AP_BT_ACL_VAL_WL_SERVE_TIME] = 25,\n\t\t\t/* CTS Diluting params */\n\t\t\t[CONF_SG_CTS_DILUTED_BAD_RX_PACKETS_TH] = 0,\n\t\t\t[CONF_SG_CTS_CHOP_IN_DUAL_ANT_SCO_MASTER] = 0,\n\t\t},\n\t\t.state = CONF_SG_PROTECTIVE,\n\t},\n\t.rx = {\n\t\t.rx_msdu_life_time           = 512000,\n\t\t.packet_detection_threshold  = 0,\n\t\t.ps_poll_timeout             = 15,\n\t\t.upsd_timeout                = 15,\n\t\t.rts_threshold               = IEEE80211_MAX_RTS_THRESHOLD,\n\t\t.rx_cca_threshold            = 0,\n\t\t.irq_blk_threshold           = 0xFFFF,\n\t\t.irq_pkt_threshold           = 0,\n\t\t.irq_timeout                 = 600,\n\t\t.queue_type                  = CONF_RX_QUEUE_TYPE_LOW_PRIORITY,\n\t},\n\t.tx = {\n\t\t.tx_energy_detection         = 0,\n\t\t.sta_rc_conf                 = {\n\t\t\t.enabled_rates       = 0,\n\t\t\t.short_retry_limit   = 10,\n\t\t\t.long_retry_limit    = 10,\n\t\t\t.aflags              = 0,\n\t\t},\n\t\t.ac_conf_count               = 4,\n\t\t.ac_conf                     = {\n\t\t\t[CONF_TX_AC_BE] = {\n\t\t\t\t.ac          = CONF_TX_AC_BE,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = 3,\n\t\t\t\t.tx_op_limit = 0,\n\t\t\t},\n\t\t\t[CONF_TX_AC_BK] = {\n\t\t\t\t.ac          = CONF_TX_AC_BK,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = 7,\n\t\t\t\t.tx_op_limit = 0,\n\t\t\t},\n\t\t\t[CONF_TX_AC_VI] = {\n\t\t\t\t.ac          = CONF_TX_AC_VI,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = CONF_TX_AIFS_PIFS,\n\t\t\t\t.tx_op_limit = 3008,\n\t\t\t},\n\t\t\t[CONF_TX_AC_VO] = {\n\t\t\t\t.ac          = CONF_TX_AC_VO,\n\t\t\t\t.cw_min      = 15,\n\t\t\t\t.cw_max      = 63,\n\t\t\t\t.aifsn       = CONF_TX_AIFS_PIFS,\n\t\t\t\t.tx_op_limit = 1504,\n\t\t\t},\n\t\t},\n\t\t.max_tx_retries = 100,\n\t\t.ap_aging_period = 300,\n\t\t.tid_conf_count = 4,\n\t\t.tid_conf = {\n\t\t\t[CONF_TX_AC_BE] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_BE,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_BE,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t\t[CONF_TX_AC_BK] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_BK,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_BK,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t\t[CONF_TX_AC_VI] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_VI,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_VI,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t\t[CONF_TX_AC_VO] = {\n\t\t\t\t.queue_id    = CONF_TX_AC_VO,\n\t\t\t\t.channel_type = CONF_CHANNEL_TYPE_EDCF,\n\t\t\t\t.tsid        = CONF_TX_AC_VO,\n\t\t\t\t.ps_scheme   = CONF_PS_SCHEME_LEGACY,\n\t\t\t\t.ack_policy  = CONF_ACK_POLICY_LEGACY,\n\t\t\t\t.apsd_conf   = {0, 0},\n\t\t\t},\n\t\t},\n\t\t.frag_threshold              = IEEE80211_MAX_FRAG_THRESHOLD,\n\t\t.tx_compl_timeout            = 700,\n\t\t.tx_compl_threshold          = 4,\n\t\t.basic_rate                  = CONF_HW_BIT_RATE_1MBPS,\n\t\t.basic_rate_5                = CONF_HW_BIT_RATE_6MBPS,\n\t\t.tmpl_short_retry_limit      = 10,\n\t\t.tmpl_long_retry_limit       = 10,\n\t\t.tx_watchdog_timeout         = 5000,\n\t\t.slow_link_thold             = 3,\n\t\t.fast_link_thold             = 10,\n\t},\n\t.conn = {\n\t\t.wake_up_event               = CONF_WAKE_UP_EVENT_DTIM,\n\t\t.listen_interval             = 1,\n\t\t.suspend_wake_up_event       = CONF_WAKE_UP_EVENT_N_DTIM,\n\t\t.suspend_listen_interval     = 3,\n\t\t.bcn_filt_mode               = CONF_BCN_FILT_MODE_ENABLED,\n\t\t.bcn_filt_ie_count           = 3,\n\t\t.bcn_filt_ie = {\n\t\t\t[0] = {\n\t\t\t\t.ie          = WLAN_EID_CHANNEL_SWITCH,\n\t\t\t\t.rule        = CONF_BCN_RULE_PASS_ON_APPEARANCE,\n\t\t\t},\n\t\t\t[1] = {\n\t\t\t\t.ie          = WLAN_EID_HT_OPERATION,\n\t\t\t\t.rule        = CONF_BCN_RULE_PASS_ON_CHANGE,\n\t\t\t},\n\t\t\t[2] = {\n\t\t\t\t.ie\t     = WLAN_EID_ERP_INFO,\n\t\t\t\t.rule\t     = CONF_BCN_RULE_PASS_ON_CHANGE,\n\t\t\t},\n\t\t},\n\t\t.synch_fail_thold            = 12,\n\t\t.bss_lose_timeout            = 400,\n\t\t.beacon_rx_timeout           = 10000,\n\t\t.broadcast_timeout           = 20000,\n\t\t.rx_broadcast_in_ps          = 1,\n\t\t.ps_poll_threshold           = 10,\n\t\t.bet_enable                  = CONF_BET_MODE_ENABLE,\n\t\t.bet_max_consecutive         = 50,\n\t\t.psm_entry_retries           = 8,\n\t\t.psm_exit_retries            = 16,\n\t\t.psm_entry_nullfunc_retries  = 3,\n\t\t.dynamic_ps_timeout          = 1500,\n\t\t.forced_ps                   = false,\n\t\t.keep_alive_interval         = 55000,\n\t\t.max_listen_interval         = 20,\n\t\t.sta_sleep_auth              = WL1271_PSM_ILLEGAL,\n\t\t.suspend_rx_ba_activity      = 0,\n\t},\n\t.itrim = {\n\t\t.enable = false,\n\t\t.timeout = 50000,\n\t},\n\t.pm_config = {\n\t\t.host_clk_settling_time = 5000,\n\t\t.host_fast_wakeup_support = CONF_FAST_WAKEUP_DISABLE,\n\t},\n\t.roam_trigger = {\n\t\t.trigger_pacing               = 1,\n\t\t.avg_weight_rssi_beacon       = 20,\n\t\t.avg_weight_rssi_data         = 10,\n\t\t.avg_weight_snr_beacon        = 20,\n\t\t.avg_weight_snr_data          = 10,\n\t},\n\t.scan = {\n\t\t.min_dwell_time_active        = 7500,\n\t\t.max_dwell_time_active        = 30000,\n\t\t.min_dwell_time_active_long   = 25000,\n\t\t.max_dwell_time_active_long   = 50000,\n\t\t.dwell_time_passive           = 100000,\n\t\t.dwell_time_dfs               = 150000,\n\t\t.num_probe_reqs               = 2,\n\t\t.split_scan_timeout           = 50000,\n\t},\n\t.sched_scan = {\n\t\t/*\n\t\t * Values are in TU/1000 but since sched scan FW command\n\t\t * params are in TUs rounding up may occur.\n\t\t */\n\t\t.base_dwell_time\t\t= 7500,\n\t\t.max_dwell_time_delta\t\t= 22500,\n\t\t/* based on 250bits per probe @1Mbps */\n\t\t.dwell_time_delta_per_probe\t= 2000,\n\t\t/* based on 250bits per probe @6Mbps (plus a bit more) */\n\t\t.dwell_time_delta_per_probe_5\t= 350,\n\t\t.dwell_time_passive\t\t= 100000,\n\t\t.dwell_time_dfs\t\t\t= 150000,\n\t\t.num_probe_reqs\t\t\t= 2,\n\t\t.rssi_threshold\t\t\t= -90,\n\t\t.snr_threshold\t\t\t= 0,\n\t},\n\t.ht = {\n\t\t.rx_ba_win_size = 8,\n\t\t.tx_ba_win_size = 64,\n\t\t.inactivity_timeout = 10000,\n\t\t.tx_ba_tid_bitmap = CONF_TX_BA_ENABLED_TID_BITMAP,\n\t},\n\t/*\n\t * Memory config for wl127x chips is given in the\n\t * wl12xx_default_priv_conf struct. The below configuration is\n\t * for wl128x chips.\n\t */\n\t.mem = {\n\t\t.num_stations                 = 1,\n\t\t.ssid_profiles                = 1,\n\t\t.rx_block_num                 = 40,\n\t\t.tx_min_block_num             = 40,\n\t\t.dynamic_memory               = 1,\n\t\t.min_req_tx_blocks            = 45,\n\t\t.min_req_rx_blocks            = 22,\n\t\t.tx_min                       = 27,\n\t},\n\t.fm_coex = {\n\t\t.enable                       = true,\n\t\t.swallow_period               = 5,\n\t\t.n_divider_fref_set_1         = 0xff,       /* default */\n\t\t.n_divider_fref_set_2         = 12,\n\t\t.m_divider_fref_set_1         = 0xffff,\n\t\t.m_divider_fref_set_2         = 148,\t    /* default */\n\t\t.coex_pll_stabilization_time  = 0xffffffff, /* default */\n\t\t.ldo_stabilization_time       = 0xffff,     /* default */\n\t\t.fm_disturbed_band_margin     = 0xff,       /* default */\n\t\t.swallow_clk_diff             = 0xff,       /* default */\n\t},\n\t.rx_streaming = {\n\t\t.duration                      = 150,\n\t\t.queues                        = 0x1,\n\t\t.interval                      = 20,\n\t\t.always                        = 0,\n\t},\n\t.fwlog = {\n\t\t.mode                         = WL12XX_FWLOG_CONTINUOUS,\n\t\t.mem_blocks                   = 2,\n\t\t.severity                     = 0,\n\t\t.timestamp                    = WL12XX_FWLOG_TIMESTAMP_DISABLED,\n\t\t.output                       = WL12XX_FWLOG_OUTPUT_DBG_PINS,\n\t\t.threshold                    = 0,\n\t},\n\t.rate = {\n\t\t.rate_retry_score = 32000,\n\t\t.per_add = 8192,\n\t\t.per_th1 = 2048,\n\t\t.per_th2 = 4096,\n\t\t.max_per = 8100,\n\t\t.inverse_curiosity_factor = 5,\n\t\t.tx_fail_low_th = 4,\n\t\t.tx_fail_high_th = 10,\n\t\t.per_alpha_shift = 4,\n\t\t.per_add_shift = 13,\n\t\t.per_beta1_shift = 10,\n\t\t.per_beta2_shift = 8,\n\t\t.rate_check_up = 2,\n\t\t.rate_check_down = 12,\n\t\t.rate_retry_policy = {\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00,\n\t\t},\n\t},\n\t.hangover = {\n\t\t.recover_time               = 0,\n\t\t.hangover_period            = 20,\n\t\t.dynamic_mode               = 1,\n\t\t.early_termination_mode     = 1,\n\t\t.max_period                 = 20,\n\t\t.min_period                 = 1,\n\t\t.increase_delta             = 1,\n\t\t.decrease_delta             = 2,\n\t\t.quiet_time                 = 4,\n\t\t.increase_time              = 1,\n\t\t.window_size                = 16,\n\t},\n\t.recovery = {\n\t\t.bug_on_recovery\t    = 0,\n\t\t.no_recovery\t\t    = 0,\n\t},\n};\n\nstatic struct wl12xx_priv_conf wl12xx_default_priv_conf = {\n\t.rf = {\n\t\t.tx_per_channel_power_compensation_2 = {\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t\t.tx_per_channel_power_compensation_5 = {\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t},\n\t},\n\t.mem_wl127x = {\n\t\t.num_stations                 = 1,\n\t\t.ssid_profiles                = 1,\n\t\t.rx_block_num                 = 70,\n\t\t.tx_min_block_num             = 40,\n\t\t.dynamic_memory               = 1,\n\t\t.min_req_tx_blocks            = 100,\n\t\t.min_req_rx_blocks            = 22,\n\t\t.tx_min                       = 27,\n\t},\n\n};\n\n#define WL12XX_TX_HW_BLOCK_SPARE_DEFAULT        1\n#define WL12XX_TX_HW_BLOCK_GEM_SPARE            2\n#define WL12XX_TX_HW_BLOCK_SIZE                 252\n\nstatic const u8 wl12xx_rate_to_idx_2ghz[] = {\n\t/* MCS rates are used only with 11n */\n\t7,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS7_SGI */\n\t7,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS7 */\n\t6,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS6 */\n\t5,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS5 */\n\t4,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS4 */\n\t3,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS3 */\n\t2,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS2 */\n\t1,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS1 */\n\t0,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS0 */\n\n\t11,                            /* WL12XX_CONF_HW_RXTX_RATE_54   */\n\t10,                            /* WL12XX_CONF_HW_RXTX_RATE_48   */\n\t9,                             /* WL12XX_CONF_HW_RXTX_RATE_36   */\n\t8,                             /* WL12XX_CONF_HW_RXTX_RATE_24   */\n\n\t/* TI-specific rate */\n\tCONF_HW_RXTX_RATE_UNSUPPORTED, /* WL12XX_CONF_HW_RXTX_RATE_22   */\n\n\t7,                             /* WL12XX_CONF_HW_RXTX_RATE_18   */\n\t6,                             /* WL12XX_CONF_HW_RXTX_RATE_12   */\n\t3,                             /* WL12XX_CONF_HW_RXTX_RATE_11   */\n\t5,                             /* WL12XX_CONF_HW_RXTX_RATE_9    */\n\t4,                             /* WL12XX_CONF_HW_RXTX_RATE_6    */\n\t2,                             /* WL12XX_CONF_HW_RXTX_RATE_5_5  */\n\t1,                             /* WL12XX_CONF_HW_RXTX_RATE_2    */\n\t0                              /* WL12XX_CONF_HW_RXTX_RATE_1    */\n};\n\nstatic const u8 wl12xx_rate_to_idx_5ghz[] = {\n\t/* MCS rates are used only with 11n */\n\t7,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS7_SGI */\n\t7,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS7 */\n\t6,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS6 */\n\t5,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS5 */\n\t4,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS4 */\n\t3,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS3 */\n\t2,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS2 */\n\t1,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS1 */\n\t0,                             /* WL12XX_CONF_HW_RXTX_RATE_MCS0 */\n\n\t7,                             /* WL12XX_CONF_HW_RXTX_RATE_54   */\n\t6,                             /* WL12XX_CONF_HW_RXTX_RATE_48   */\n\t5,                             /* WL12XX_CONF_HW_RXTX_RATE_36   */\n\t4,                             /* WL12XX_CONF_HW_RXTX_RATE_24   */\n\n\t/* TI-specific rate */\n\tCONF_HW_RXTX_RATE_UNSUPPORTED, /* WL12XX_CONF_HW_RXTX_RATE_22   */\n\n\t3,                             /* WL12XX_CONF_HW_RXTX_RATE_18   */\n\t2,                             /* WL12XX_CONF_HW_RXTX_RATE_12   */\n\tCONF_HW_RXTX_RATE_UNSUPPORTED, /* WL12XX_CONF_HW_RXTX_RATE_11   */\n\t1,                             /* WL12XX_CONF_HW_RXTX_RATE_9    */\n\t0,                             /* WL12XX_CONF_HW_RXTX_RATE_6    */\n\tCONF_HW_RXTX_RATE_UNSUPPORTED, /* WL12XX_CONF_HW_RXTX_RATE_5_5  */\n\tCONF_HW_RXTX_RATE_UNSUPPORTED, /* WL12XX_CONF_HW_RXTX_RATE_2    */\n\tCONF_HW_RXTX_RATE_UNSUPPORTED  /* WL12XX_CONF_HW_RXTX_RATE_1    */\n};\n\nstatic const u8 *wl12xx_band_rate_to_idx[] = {\n\t[NL80211_BAND_2GHZ] = wl12xx_rate_to_idx_2ghz,\n\t[NL80211_BAND_5GHZ] = wl12xx_rate_to_idx_5ghz\n};\n\nenum wl12xx_hw_rates {\n\tWL12XX_CONF_HW_RXTX_RATE_MCS7_SGI = 0,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS7,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS6,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS5,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS4,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS3,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS2,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS1,\n\tWL12XX_CONF_HW_RXTX_RATE_MCS0,\n\tWL12XX_CONF_HW_RXTX_RATE_54,\n\tWL12XX_CONF_HW_RXTX_RATE_48,\n\tWL12XX_CONF_HW_RXTX_RATE_36,\n\tWL12XX_CONF_HW_RXTX_RATE_24,\n\tWL12XX_CONF_HW_RXTX_RATE_22,\n\tWL12XX_CONF_HW_RXTX_RATE_18,\n\tWL12XX_CONF_HW_RXTX_RATE_12,\n\tWL12XX_CONF_HW_RXTX_RATE_11,\n\tWL12XX_CONF_HW_RXTX_RATE_9,\n\tWL12XX_CONF_HW_RXTX_RATE_6,\n\tWL12XX_CONF_HW_RXTX_RATE_5_5,\n\tWL12XX_CONF_HW_RXTX_RATE_2,\n\tWL12XX_CONF_HW_RXTX_RATE_1,\n\tWL12XX_CONF_HW_RXTX_RATE_MAX,\n};\n\nstatic struct wlcore_partition_set wl12xx_ptable[PART_TABLE_LEN] = {\n\t[PART_DOWN] = {\n\t\t.mem = {\n\t\t\t.start = 0x00000000,\n\t\t\t.size  = 0x000177c0\n\t\t},\n\t\t.reg = {\n\t\t\t.start = REGISTERS_BASE,\n\t\t\t.size  = 0x00008800\n\t\t},\n\t\t.mem2 = {\n\t\t\t.start = 0x00000000,\n\t\t\t.size  = 0x00000000\n\t\t},\n\t\t.mem3 = {\n\t\t\t.start = 0x00000000,\n\t\t\t.size  = 0x00000000\n\t\t},\n\t},\n\n\t[PART_BOOT] = { /* in wl12xx we can use a mix of work and down\n\t\t\t * partition here */\n\t\t.mem = {\n\t\t\t.start = 0x00040000,\n\t\t\t.size  = 0x00014fc0\n\t\t},\n\t\t.reg = {\n\t\t\t.start = REGISTERS_BASE,\n\t\t\t.size  = 0x00008800\n\t\t},\n\t\t.mem2 = {\n\t\t\t.start = 0x00000000,\n\t\t\t.size  = 0x00000000\n\t\t},\n\t\t.mem3 = {\n\t\t\t.start = 0x00000000,\n\t\t\t.size  = 0x00000000\n\t\t},\n\t},\n\n\t[PART_WORK] = {\n\t\t.mem = {\n\t\t\t.start = 0x00040000,\n\t\t\t.size  = 0x00014fc0\n\t\t},\n\t\t.reg = {\n\t\t\t.start = REGISTERS_BASE,\n\t\t\t.size  = 0x0000a000\n\t\t},\n\t\t.mem2 = {\n\t\t\t.start = 0x003004f8,\n\t\t\t.size  = 0x00000004\n\t\t},\n\t\t.mem3 = {\n\t\t\t.start = 0x00040404,\n\t\t\t.size  = 0x00000000\n\t\t},\n\t},\n\n\t[PART_DRPW] = {\n\t\t.mem = {\n\t\t\t.start = 0x00040000,\n\t\t\t.size  = 0x00014fc0\n\t\t},\n\t\t.reg = {\n\t\t\t.start = DRPW_BASE,\n\t\t\t.size  = 0x00006000\n\t\t},\n\t\t.mem2 = {\n\t\t\t.start = 0x00000000,\n\t\t\t.size  = 0x00000000\n\t\t},\n\t\t.mem3 = {\n\t\t\t.start = 0x00000000,\n\t\t\t.size  = 0x00000000\n\t\t}\n\t}\n};\n\nstatic const int wl12xx_rtable[REG_TABLE_LEN] = {\n\t[REG_ECPU_CONTROL]\t\t= WL12XX_REG_ECPU_CONTROL,\n\t[REG_INTERRUPT_NO_CLEAR]\t= WL12XX_REG_INTERRUPT_NO_CLEAR,\n\t[REG_INTERRUPT_ACK]\t\t= WL12XX_REG_INTERRUPT_ACK,\n\t[REG_COMMAND_MAILBOX_PTR]\t= WL12XX_REG_COMMAND_MAILBOX_PTR,\n\t[REG_EVENT_MAILBOX_PTR]\t\t= WL12XX_REG_EVENT_MAILBOX_PTR,\n\t[REG_INTERRUPT_TRIG]\t\t= WL12XX_REG_INTERRUPT_TRIG,\n\t[REG_INTERRUPT_MASK]\t\t= WL12XX_REG_INTERRUPT_MASK,\n\t[REG_PC_ON_RECOVERY]\t\t= WL12XX_SCR_PAD4,\n\t[REG_CHIP_ID_B]\t\t\t= WL12XX_CHIP_ID_B,\n\t[REG_CMD_MBOX_ADDRESS]\t\t= WL12XX_CMD_MBOX_ADDRESS,\n\n\t/* data access memory addresses, used with partition translation */\n\t[REG_SLV_MEM_DATA]\t\t= WL1271_SLV_MEM_DATA,\n\t[REG_SLV_REG_DATA]\t\t= WL1271_SLV_REG_DATA,\n\n\t/* raw data access memory addresses */\n\t[REG_RAW_FW_STATUS_ADDR]\t= FW_STATUS_ADDR,\n};\n\n/* TODO: maybe move to a new header file? */\n#define WL127X_FW_NAME_MULTI\t\"ti-connectivity/wl127x-fw-5-mr.bin\"\n#define WL127X_FW_NAME_SINGLE\t\"ti-connectivity/wl127x-fw-5-sr.bin\"\n#define WL127X_PLT_FW_NAME\t\"ti-connectivity/wl127x-fw-5-plt.bin\"\n\n#define WL128X_FW_NAME_MULTI\t\"ti-connectivity/wl128x-fw-5-mr.bin\"\n#define WL128X_FW_NAME_SINGLE\t\"ti-connectivity/wl128x-fw-5-sr.bin\"\n#define WL128X_PLT_FW_NAME\t\"ti-connectivity/wl128x-fw-5-plt.bin\"\n\nstatic int wl127x_prepare_read(struct wl1271 *wl, u32 rx_desc, u32 len)\n{\n\tint ret;\n\n\tif (wl->chip.id != CHIP_ID_128X_PG20) {\n\t\tstruct wl1271_acx_mem_map *wl_mem_map = wl->target_mem_map;\n\t\tstruct wl12xx_priv *priv = wl->priv;\n\n\t\t/*\n\t\t * Choose the block we want to read\n\t\t * For aggregated packets, only the first memory block\n\t\t * should be retrieved. The FW takes care of the rest.\n\t\t */\n\t\tu32 mem_block = rx_desc & RX_MEM_BLOCK_MASK;\n\n\t\tpriv->rx_mem_addr->addr = (mem_block << 8) +\n\t\t\tle32_to_cpu(wl_mem_map->packet_memory_pool_start);\n\n\t\tpriv->rx_mem_addr->addr_extra = priv->rx_mem_addr->addr + 4;\n\n\t\tret = wlcore_write(wl, WL1271_SLV_REG_DATA, priv->rx_mem_addr,\n\t\t\t\t   sizeof(*priv->rx_mem_addr), false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl12xx_identify_chip(struct wl1271 *wl)\n{\n\tint ret = 0;\n\n\tswitch (wl->chip.id) {\n\tcase CHIP_ID_127X_PG10:\n\t\twl1271_warning(\"chip id 0x%x (1271 PG10) support is obsolete\",\n\t\t\t       wl->chip.id);\n\n\t\twl->quirks |= WLCORE_QUIRK_LEGACY_NVS |\n\t\t\t      WLCORE_QUIRK_DUAL_PROBE_TMPL |\n\t\t\t      WLCORE_QUIRK_TKIP_HEADER_SPACE |\n\t\t\t      WLCORE_QUIRK_START_STA_FAILS |\n\t\t\t      WLCORE_QUIRK_AP_ZERO_SESSION_ID;\n\t\twl->sr_fw_name = WL127X_FW_NAME_SINGLE;\n\t\twl->mr_fw_name = WL127X_FW_NAME_MULTI;\n\t\tmemcpy(&wl->conf.mem, &wl12xx_default_priv_conf.mem_wl127x,\n\t\t       sizeof(wl->conf.mem));\n\n\t\t/* read data preparation is only needed by wl127x */\n\t\twl->ops->prepare_read = wl127x_prepare_read;\n\n\t\twlcore_set_min_fw_ver(wl, WL127X_CHIP_VER,\n\t\t\t      WL127X_IFTYPE_SR_VER,  WL127X_MAJOR_SR_VER,\n\t\t\t      WL127X_SUBTYPE_SR_VER, WL127X_MINOR_SR_VER,\n\t\t\t      WL127X_IFTYPE_MR_VER,  WL127X_MAJOR_MR_VER,\n\t\t\t      WL127X_SUBTYPE_MR_VER, WL127X_MINOR_MR_VER);\n\t\tbreak;\n\n\tcase CHIP_ID_127X_PG20:\n\t\twl1271_debug(DEBUG_BOOT, \"chip id 0x%x (1271 PG20)\",\n\t\t\t     wl->chip.id);\n\n\t\twl->quirks |= WLCORE_QUIRK_LEGACY_NVS |\n\t\t\t      WLCORE_QUIRK_DUAL_PROBE_TMPL |\n\t\t\t      WLCORE_QUIRK_TKIP_HEADER_SPACE |\n\t\t\t      WLCORE_QUIRK_START_STA_FAILS |\n\t\t\t      WLCORE_QUIRK_AP_ZERO_SESSION_ID;\n\t\twl->plt_fw_name = WL127X_PLT_FW_NAME;\n\t\twl->sr_fw_name = WL127X_FW_NAME_SINGLE;\n\t\twl->mr_fw_name = WL127X_FW_NAME_MULTI;\n\t\tmemcpy(&wl->conf.mem, &wl12xx_default_priv_conf.mem_wl127x,\n\t\t       sizeof(wl->conf.mem));\n\n\t\t/* read data preparation is only needed by wl127x */\n\t\twl->ops->prepare_read = wl127x_prepare_read;\n\n\t\twlcore_set_min_fw_ver(wl, WL127X_CHIP_VER,\n\t\t\t      WL127X_IFTYPE_SR_VER,  WL127X_MAJOR_SR_VER,\n\t\t\t      WL127X_SUBTYPE_SR_VER, WL127X_MINOR_SR_VER,\n\t\t\t      WL127X_IFTYPE_MR_VER,  WL127X_MAJOR_MR_VER,\n\t\t\t      WL127X_SUBTYPE_MR_VER, WL127X_MINOR_MR_VER);\n\t\tbreak;\n\n\tcase CHIP_ID_128X_PG20:\n\t\twl1271_debug(DEBUG_BOOT, \"chip id 0x%x (1283 PG20)\",\n\t\t\t     wl->chip.id);\n\t\twl->plt_fw_name = WL128X_PLT_FW_NAME;\n\t\twl->sr_fw_name = WL128X_FW_NAME_SINGLE;\n\t\twl->mr_fw_name = WL128X_FW_NAME_MULTI;\n\n\t\t/* wl128x requires TX blocksize alignment */\n\t\twl->quirks |= WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN |\n\t\t\t      WLCORE_QUIRK_DUAL_PROBE_TMPL |\n\t\t\t      WLCORE_QUIRK_TKIP_HEADER_SPACE |\n\t\t\t      WLCORE_QUIRK_START_STA_FAILS |\n\t\t\t      WLCORE_QUIRK_AP_ZERO_SESSION_ID;\n\n\t\twlcore_set_min_fw_ver(wl, WL128X_CHIP_VER,\n\t\t\t      WL128X_IFTYPE_SR_VER,  WL128X_MAJOR_SR_VER,\n\t\t\t      WL128X_SUBTYPE_SR_VER, WL128X_MINOR_SR_VER,\n\t\t\t      WL128X_IFTYPE_MR_VER,  WL128X_MAJOR_MR_VER,\n\t\t\t      WL128X_SUBTYPE_MR_VER, WL128X_MINOR_MR_VER);\n\t\tbreak;\n\tcase CHIP_ID_128X_PG10:\n\tdefault:\n\t\twl1271_warning(\"unsupported chip id: 0x%x\", wl->chip.id);\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\twl->fw_mem_block_size = 256;\n\twl->fwlog_end = 0x2000000;\n\n\t/* common settings */\n\twl->scan_templ_id_2_4 = CMD_TEMPL_APP_PROBE_REQ_2_4_LEGACY;\n\twl->scan_templ_id_5 = CMD_TEMPL_APP_PROBE_REQ_5_LEGACY;\n\twl->sched_scan_templ_id_2_4 = CMD_TEMPL_CFG_PROBE_REQ_2_4;\n\twl->sched_scan_templ_id_5 = CMD_TEMPL_CFG_PROBE_REQ_5;\n\twl->max_channels_5 = WL12XX_MAX_CHANNELS_5GHZ;\n\twl->ba_rx_session_count_max = WL12XX_RX_BA_MAX_SESSIONS;\nout:\n\treturn ret;\n}\n\nstatic int __must_check wl12xx_top_reg_write(struct wl1271 *wl, int addr,\n\t\t\t\t\t     u16 val)\n{\n\tint ret;\n\n\t/* write address >> 1 + 0x30000 to OCP_POR_CTR */\n\taddr = (addr >> 1) + 0x30000;\n\tret = wlcore_write32(wl, WL12XX_OCP_POR_CTR, addr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* write value to OCP_POR_WDATA */\n\tret = wlcore_write32(wl, WL12XX_OCP_DATA_WRITE, val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* write 1 to OCP_CMD */\n\tret = wlcore_write32(wl, WL12XX_OCP_CMD, OCP_CMD_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n\nstatic int __must_check wl12xx_top_reg_read(struct wl1271 *wl, int addr,\n\t\t\t\t\t    u16 *out)\n{\n\tu32 val;\n\tint timeout = OCP_CMD_LOOP;\n\tint ret;\n\n\t/* write address >> 1 + 0x30000 to OCP_POR_CTR */\n\taddr = (addr >> 1) + 0x30000;\n\tret = wlcore_write32(wl, WL12XX_OCP_POR_CTR, addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* write 2 to OCP_CMD */\n\tret = wlcore_write32(wl, WL12XX_OCP_CMD, OCP_CMD_READ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* poll for data ready */\n\tdo {\n\t\tret = wlcore_read32(wl, WL12XX_OCP_DATA_READ, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} while (!(val & OCP_READY_MASK) && --timeout);\n\n\tif (!timeout) {\n\t\twl1271_warning(\"Top register access timed out.\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* check data status and return if OK */\n\tif ((val & OCP_STATUS_MASK) != OCP_STATUS_OK) {\n\t\twl1271_warning(\"Top register access returned error.\");\n\t\treturn -EIO;\n\t}\n\n\tif (out)\n\t\t*out = val & 0xffff;\n\n\treturn 0;\n}\n\nstatic int wl128x_switch_tcxo_to_fref(struct wl1271 *wl)\n{\n\tu16 spare_reg;\n\tint ret;\n\n\t/* Mask bits [2] & [8:4] in the sys_clk_cfg register */\n\tret = wl12xx_top_reg_read(wl, WL_SPARE_REG, &spare_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (spare_reg == 0xFFFF)\n\t\treturn -EFAULT;\n\tspare_reg |= (BIT(3) | BIT(5) | BIT(6));\n\tret = wl12xx_top_reg_write(wl, WL_SPARE_REG, spare_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Enable FREF_CLK_REQ & mux MCS and coex PLLs to FREF */\n\tret = wl12xx_top_reg_write(wl, SYS_CLK_CFG_REG,\n\t\t\t\t   WL_CLK_REQ_TYPE_PG2 | MCS_PLL_CLK_SEL_FREF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Delay execution for 15msec, to let the HW settle */\n\tmdelay(15);\n\n\treturn 0;\n}\n\nstatic bool wl128x_is_tcxo_valid(struct wl1271 *wl)\n{\n\tu16 tcxo_detection;\n\tint ret;\n\n\tret = wl12xx_top_reg_read(wl, TCXO_CLK_DETECT_REG, &tcxo_detection);\n\tif (ret < 0)\n\t\treturn false;\n\n\tif (tcxo_detection & TCXO_DET_FAILED)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool wl128x_is_fref_valid(struct wl1271 *wl)\n{\n\tu16 fref_detection;\n\tint ret;\n\n\tret = wl12xx_top_reg_read(wl, FREF_CLK_DETECT_REG, &fref_detection);\n\tif (ret < 0)\n\t\treturn false;\n\n\tif (fref_detection & FREF_CLK_DETECT_FAIL)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int wl128x_manually_configure_mcs_pll(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl12xx_top_reg_write(wl, MCS_PLL_M_REG, MCS_PLL_M_REG_VAL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_top_reg_write(wl, MCS_PLL_N_REG, MCS_PLL_N_REG_VAL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_top_reg_write(wl, MCS_PLL_CONFIG_REG,\n\t\t\t\t   MCS_PLL_CONFIG_REG_VAL);\n\nout:\n\treturn ret;\n}\n\nstatic int wl128x_configure_mcs_pll(struct wl1271 *wl, int clk)\n{\n\tu16 spare_reg;\n\tu16 pll_config;\n\tu8 input_freq;\n\tstruct wl12xx_priv *priv = wl->priv;\n\tint ret;\n\n\t/* Mask bits [3:1] in the sys_clk_cfg register */\n\tret = wl12xx_top_reg_read(wl, WL_SPARE_REG, &spare_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (spare_reg == 0xFFFF)\n\t\treturn -EFAULT;\n\tspare_reg |= BIT(2);\n\tret = wl12xx_top_reg_write(wl, WL_SPARE_REG, spare_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Handle special cases of the TCXO clock */\n\tif (priv->tcxo_clock == WL12XX_TCXOCLOCK_16_8 ||\n\t    priv->tcxo_clock == WL12XX_TCXOCLOCK_33_6)\n\t\treturn wl128x_manually_configure_mcs_pll(wl);\n\n\t/* Set the input frequency according to the selected clock source */\n\tinput_freq = (clk & 1) + 1;\n\n\tret = wl12xx_top_reg_read(wl, MCS_PLL_CONFIG_REG, &pll_config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pll_config == 0xFFFF)\n\t\treturn -EFAULT;\n\tpll_config |= (input_freq << MCS_SEL_IN_FREQ_SHIFT);\n\tpll_config |= MCS_PLL_ENABLE_HP;\n\tret = wl12xx_top_reg_write(wl, MCS_PLL_CONFIG_REG, pll_config);\n\n\treturn ret;\n}\n\n/*\n * WL128x has two clocks input - TCXO and FREF.\n * TCXO is the main clock of the device, while FREF is used to sync\n * between the GPS and the cellular modem.\n * In cases where TCXO is 32.736MHz or 16.368MHz, the FREF will be used\n * as the WLAN/BT main clock.\n */\nstatic int wl128x_boot_clk(struct wl1271 *wl, int *selected_clock)\n{\n\tstruct wl12xx_priv *priv = wl->priv;\n\tu16 sys_clk_cfg;\n\tint ret;\n\n\t/* For XTAL-only modes, FREF will be used after switching from TCXO */\n\tif (priv->ref_clock == WL12XX_REFCLOCK_26_XTAL ||\n\t    priv->ref_clock == WL12XX_REFCLOCK_38_XTAL) {\n\t\tif (!wl128x_switch_tcxo_to_fref(wl))\n\t\t\treturn -EINVAL;\n\t\tgoto fref_clk;\n\t}\n\n\t/* Query the HW, to determine which clock source we should use */\n\tret = wl12xx_top_reg_read(wl, SYS_CLK_CFG_REG, &sys_clk_cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sys_clk_cfg == 0xFFFF)\n\t\treturn -EINVAL;\n\tif (sys_clk_cfg & PRCM_CM_EN_MUX_WLAN_FREF)\n\t\tgoto fref_clk;\n\n\t/* If TCXO is either 32.736MHz or 16.368MHz, switch to FREF */\n\tif (priv->tcxo_clock == WL12XX_TCXOCLOCK_16_368 ||\n\t    priv->tcxo_clock == WL12XX_TCXOCLOCK_32_736) {\n\t\tif (!wl128x_switch_tcxo_to_fref(wl))\n\t\t\treturn -EINVAL;\n\t\tgoto fref_clk;\n\t}\n\n\t/* TCXO clock is selected */\n\tif (!wl128x_is_tcxo_valid(wl))\n\t\treturn -EINVAL;\n\t*selected_clock = priv->tcxo_clock;\n\tgoto config_mcs_pll;\n\nfref_clk:\n\t/* FREF clock is selected */\n\tif (!wl128x_is_fref_valid(wl))\n\t\treturn -EINVAL;\n\t*selected_clock = priv->ref_clock;\n\nconfig_mcs_pll:\n\treturn wl128x_configure_mcs_pll(wl, *selected_clock);\n}\n\nstatic int wl127x_boot_clk(struct wl1271 *wl)\n{\n\tstruct wl12xx_priv *priv = wl->priv;\n\tu32 pause;\n\tu32 clk;\n\tint ret;\n\n\tif (WL127X_PG_GET_MAJOR(wl->hw_pg_ver) < 3)\n\t\twl->quirks |= WLCORE_QUIRK_END_OF_TRANSACTION;\n\n\tif (priv->ref_clock == CONF_REF_CLK_19_2_E ||\n\t    priv->ref_clock == CONF_REF_CLK_38_4_E ||\n\t    priv->ref_clock == CONF_REF_CLK_38_4_M_XTAL)\n\t\t/* ref clk: 19.2/38.4/38.4-XTAL */\n\t\tclk = 0x3;\n\telse if (priv->ref_clock == CONF_REF_CLK_26_E ||\n\t\t priv->ref_clock == CONF_REF_CLK_26_M_XTAL ||\n\t\t priv->ref_clock == CONF_REF_CLK_52_E)\n\t\t/* ref clk: 26/52 */\n\t\tclk = 0x5;\n\telse\n\t\treturn -EINVAL;\n\n\tif (priv->ref_clock != CONF_REF_CLK_19_2_E) {\n\t\tu16 val;\n\t\t/* Set clock type (open drain) */\n\t\tret = wl12xx_top_reg_read(wl, OCP_REG_CLK_TYPE, &val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tval &= FREF_CLK_TYPE_BITS;\n\t\tret = wl12xx_top_reg_write(wl, OCP_REG_CLK_TYPE, val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/* Set clock pull mode (no pull) */\n\t\tret = wl12xx_top_reg_read(wl, OCP_REG_CLK_PULL, &val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tval |= NO_PULL;\n\t\tret = wl12xx_top_reg_write(wl, OCP_REG_CLK_PULL, val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tu16 val;\n\t\t/* Set clock polarity */\n\t\tret = wl12xx_top_reg_read(wl, OCP_REG_CLK_POLARITY, &val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tval &= FREF_CLK_POLARITY_BITS;\n\t\tval |= CLK_REQ_OUTN_SEL;\n\t\tret = wl12xx_top_reg_write(wl, OCP_REG_CLK_POLARITY, val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = wlcore_write32(wl, WL12XX_PLL_PARAMETERS, clk);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read32(wl, WL12XX_PLL_PARAMETERS, &pause);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_BOOT, \"pause1 0x%x\", pause);\n\n\tpause &= ~(WU_COUNTER_PAUSE_VAL);\n\tpause |= WU_COUNTER_PAUSE_VAL;\n\tret = wlcore_write32(wl, WL12XX_WU_COUNTER_PAUSE, pause);\n\nout:\n\treturn ret;\n}\n\nstatic int wl1271_boot_soft_reset(struct wl1271 *wl)\n{\n\tunsigned long timeout;\n\tu32 boot_data;\n\tint ret = 0;\n\n\t/* perform soft reset */\n\tret = wlcore_write32(wl, WL12XX_SLV_SOFT_RESET, ACX_SLV_SOFT_RESET_BIT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* SOFT_RESET is self clearing */\n\ttimeout = jiffies + usecs_to_jiffies(SOFT_RESET_MAX_TIME);\n\twhile (1) {\n\t\tret = wlcore_read32(wl, WL12XX_SLV_SOFT_RESET, &boot_data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\twl1271_debug(DEBUG_BOOT, \"soft reset bootdata 0x%x\", boot_data);\n\t\tif ((boot_data & ACX_SLV_SOFT_RESET_BIT) == 0)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t/* 1.2 check pWhalBus->uSelfClearTime if the\n\t\t\t * timeout was reached */\n\t\t\twl1271_error(\"soft reset timeout\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tudelay(SOFT_RESET_STALL_TIME);\n\t}\n\n\t/* disable Rx/Tx */\n\tret = wlcore_write32(wl, WL12XX_ENABLE, 0x0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* disable auto calibration on start*/\n\tret = wlcore_write32(wl, WL12XX_SPARE_A2, 0xffff);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_pre_boot(struct wl1271 *wl)\n{\n\tstruct wl12xx_priv *priv = wl->priv;\n\tint ret = 0;\n\tu32 clk;\n\tint selected_clock = -1;\n\n\tif (wl->chip.id == CHIP_ID_128X_PG20) {\n\t\tret = wl128x_boot_clk(wl, &selected_clock);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = wl127x_boot_clk(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Continue the ELP wake up sequence */\n\tret = wlcore_write32(wl, WL12XX_WELP_ARM_COMMAND, WELP_ARM_COMMAND_VAL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tudelay(500);\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_DRPW]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Read-modify-write DRPW_SCRATCH_START register (see next state)\n\t   to be used by DRPw FW. The RTRIM value will be added by the FW\n\t   before taking DRPw out of reset */\n\n\tret = wlcore_read32(wl, WL12XX_DRPW_SCRATCH_START, &clk);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_BOOT, \"clk2 0x%x\", clk);\n\n\tif (wl->chip.id == CHIP_ID_128X_PG20)\n\t\tclk |= ((selected_clock & 0x3) << 1) << 4;\n\telse\n\t\tclk |= (priv->ref_clock << 1) << 4;\n\n\tret = wlcore_write32(wl, WL12XX_DRPW_SCRATCH_START, clk);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_WORK]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Disable interrupts */\n\tret = wlcore_write_reg(wl, REG_INTERRUPT_MASK, WL1271_ACX_INTR_ALL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl1271_boot_soft_reset(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_pre_upload(struct wl1271 *wl)\n{\n\tu32 tmp;\n\tu16 polarity;\n\tint ret;\n\n\t/* write firmware's last address (ie. it's length) to\n\t * ACX_EEPROMLESS_IND_REG */\n\twl1271_debug(DEBUG_BOOT, \"ACX_EEPROMLESS_IND_REG\");\n\n\tret = wlcore_write32(wl, WL12XX_EEPROMLESS_IND, WL12XX_EEPROMLESS_IND);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read_reg(wl, REG_CHIP_ID_B, &tmp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl1271_debug(DEBUG_BOOT, \"chip id 0x%x\", tmp);\n\n\t/* 6. read the EEPROM parameters */\n\tret = wlcore_read32(wl, WL12XX_SCR_PAD2, &tmp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* WL1271: The reference driver skips steps 7 to 10 (jumps directly\n\t * to upload_fw) */\n\n\tif (wl->chip.id == CHIP_ID_128X_PG20) {\n\t\tret = wl12xx_top_reg_write(wl, SDIO_IO_DS, HCI_IO_DS_6MA);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* polarity must be set before the firmware is loaded */\n\tret = wl12xx_top_reg_read(wl, OCP_REG_POLARITY, &polarity);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* We use HIGH polarity, so unset the LOW bit */\n\tpolarity &= ~POLARITY_LOW;\n\tret = wl12xx_top_reg_write(wl, OCP_REG_POLARITY, polarity);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_enable_interrupts(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wlcore_write_reg(wl, REG_INTERRUPT_MASK,\n\t\t\t       WL12XX_ACX_ALL_EVENTS_VECTOR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twlcore_enable_interrupts(wl);\n\tret = wlcore_write_reg(wl, REG_INTERRUPT_MASK,\n\t\t\t       WL1271_ACX_INTR_ALL & ~(WL12XX_INTR_MASK));\n\tif (ret < 0)\n\t\tgoto disable_interrupts;\n\n\tret = wlcore_write32(wl, WL12XX_HI_CFG, HI_CFG_DEF_VAL);\n\tif (ret < 0)\n\t\tgoto disable_interrupts;\n\n\treturn ret;\n\ndisable_interrupts:\n\twlcore_disable_interrupts(wl);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_boot(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl12xx_pre_boot(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_boot_upload_nvs(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_pre_upload(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_boot_upload_firmware(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twl->event_mask = BSS_LOSE_EVENT_ID |\n\t\tREGAINED_BSS_EVENT_ID |\n\t\tSCAN_COMPLETE_EVENT_ID |\n\t\tROLE_STOP_COMPLETE_EVENT_ID |\n\t\tRSSI_SNR_TRIGGER_0_EVENT_ID |\n\t\tPSPOLL_DELIVERY_FAILURE_EVENT_ID |\n\t\tSOFT_GEMINI_SENSE_EVENT_ID |\n\t\tPERIODIC_SCAN_REPORT_EVENT_ID |\n\t\tPERIODIC_SCAN_COMPLETE_EVENT_ID |\n\t\tDUMMY_PACKET_EVENT_ID |\n\t\tPEER_REMOVE_COMPLETE_EVENT_ID |\n\t\tBA_SESSION_RX_CONSTRAINT_EVENT_ID |\n\t\tREMAIN_ON_CHANNEL_COMPLETE_EVENT_ID |\n\t\tINACTIVE_STA_EVENT_ID |\n\t\tCHANNEL_SWITCH_COMPLETE_EVENT_ID;\n\n\twl->ap_event_mask = MAX_TX_RETRY_EVENT_ID;\n\n\tret = wlcore_boot_run_firmware(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl12xx_enable_interrupts(wl);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_trigger_cmd(struct wl1271 *wl, int cmd_box_addr,\n\t\t\t       void *buf, size_t len)\n{\n\tint ret;\n\n\tret = wlcore_write(wl, cmd_box_addr, buf, len, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wlcore_write_reg(wl, REG_INTERRUPT_TRIG, WL12XX_INTR_TRIG_CMD);\n\n\treturn ret;\n}\n\nstatic int wl12xx_ack_event(struct wl1271 *wl)\n{\n\treturn wlcore_write_reg(wl, REG_INTERRUPT_TRIG,\n\t\t\t\tWL12XX_INTR_TRIG_EVENT_ACK);\n}\n\nstatic u32 wl12xx_calc_tx_blocks(struct wl1271 *wl, u32 len, u32 spare_blks)\n{\n\tu32 blk_size = WL12XX_TX_HW_BLOCK_SIZE;\n\tu32 align_len = wlcore_calc_packet_alignment(wl, len);\n\n\treturn (align_len + blk_size - 1) / blk_size + spare_blks;\n}\n\nstatic void\nwl12xx_set_tx_desc_blocks(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc,\n\t\t\t  u32 blks, u32 spare_blks)\n{\n\tif (wl->chip.id == CHIP_ID_128X_PG20) {\n\t\tdesc->wl128x_mem.total_mem_blocks = blks;\n\t} else {\n\t\tdesc->wl127x_mem.extra_blocks = spare_blks;\n\t\tdesc->wl127x_mem.total_mem_blocks = blks;\n\t}\n}\n\nstatic void\nwl12xx_set_tx_desc_data_len(struct wl1271 *wl, struct wl1271_tx_hw_descr *desc,\n\t\t\t    struct sk_buff *skb)\n{\n\tu32 aligned_len = wlcore_calc_packet_alignment(wl, skb->len);\n\n\tif (wl->chip.id == CHIP_ID_128X_PG20) {\n\t\tdesc->wl128x_mem.extra_bytes = aligned_len - skb->len;\n\t\tdesc->length = cpu_to_le16(aligned_len >> 2);\n\n\t\twl1271_debug(DEBUG_TX,\n\t\t\t     \"tx_fill_hdr: hlid: %d len: %d life: %d mem: %d extra: %d\",\n\t\t\t     desc->hlid,\n\t\t\t     le16_to_cpu(desc->length),\n\t\t\t     le16_to_cpu(desc->life_time),\n\t\t\t     desc->wl128x_mem.total_mem_blocks,\n\t\t\t     desc->wl128x_mem.extra_bytes);\n\t} else {\n\t\t/* calculate number of padding bytes */\n\t\tint pad = aligned_len - skb->len;\n\t\tdesc->tx_attr |=\n\t\t\tcpu_to_le16(pad << TX_HW_ATTR_OFST_LAST_WORD_PAD);\n\n\t\t/* Store the aligned length in terms of words */\n\t\tdesc->length = cpu_to_le16(aligned_len >> 2);\n\n\t\twl1271_debug(DEBUG_TX,\n\t\t\t     \"tx_fill_hdr: pad: %d hlid: %d len: %d life: %d mem: %d\",\n\t\t\t     pad, desc->hlid,\n\t\t\t     le16_to_cpu(desc->length),\n\t\t\t     le16_to_cpu(desc->life_time),\n\t\t\t     desc->wl127x_mem.total_mem_blocks);\n\t}\n}\n\nstatic enum wl_rx_buf_align\nwl12xx_get_rx_buf_align(struct wl1271 *wl, u32 rx_desc)\n{\n\tif (rx_desc & RX_BUF_UNALIGNED_PAYLOAD)\n\t\treturn WLCORE_RX_BUF_UNALIGNED;\n\n\treturn WLCORE_RX_BUF_ALIGNED;\n}\n\nstatic u32 wl12xx_get_rx_packet_len(struct wl1271 *wl, void *rx_data,\n\t\t\t\t    u32 data_len)\n{\n\tstruct wl1271_rx_descriptor *desc = rx_data;\n\n\t/* invalid packet */\n\tif (data_len < sizeof(*desc) ||\n\t    data_len < sizeof(*desc) + desc->pad_len)\n\t\treturn 0;\n\n\treturn data_len - sizeof(*desc) - desc->pad_len;\n}\n\nstatic int wl12xx_tx_delayed_compl(struct wl1271 *wl)\n{\n\tif (wl->fw_status->tx_results_counter ==\n\t    (wl->tx_results_count & 0xff))\n\t\treturn 0;\n\n\treturn wlcore_tx_complete(wl);\n}\n\nstatic int wl12xx_hw_init(struct wl1271 *wl)\n{\n\tint ret;\n\n\tif (wl->chip.id == CHIP_ID_128X_PG20) {\n\t\tu32 host_cfg_bitmap = HOST_IF_CFG_RX_FIFO_ENABLE;\n\n\t\tret = wl128x_cmd_general_parms(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If we are in calibrator based auto detect then we got the FEM nr\n\t\t * in wl->fem_manuf. No need to continue further\n\t\t */\n\t\tif (wl->plt_mode == PLT_FEM_DETECT)\n\t\t\tgoto out;\n\n\t\tret = wl128x_cmd_radio_parms(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (wl->quirks & WLCORE_QUIRK_TX_BLOCKSIZE_ALIGN)\n\t\t\t/* Enable SDIO padding */\n\t\t\thost_cfg_bitmap |= HOST_IF_CFG_TX_PAD_TO_SDIO_BLK;\n\n\t\t/* Must be before wl1271_acx_init_mem_config() */\n\t\tret = wl1271_acx_host_if_cfg_bitmap(wl, host_cfg_bitmap);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = wl1271_cmd_general_parms(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If we are in calibrator based auto detect then we got the FEM nr\n\t\t * in wl->fem_manuf. No need to continue further\n\t\t */\n\t\tif (wl->plt_mode == PLT_FEM_DETECT)\n\t\t\tgoto out;\n\n\t\tret = wl1271_cmd_radio_parms(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = wl1271_cmd_ext_radio_parms(wl);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\nout:\n\treturn ret;\n}\n\nstatic void wl12xx_convert_fw_status(struct wl1271 *wl, void *raw_fw_status,\n\t\t\t\t     struct wl_fw_status *fw_status)\n{\n\tstruct wl12xx_fw_status *int_fw_status = raw_fw_status;\n\n\tfw_status->intr = le32_to_cpu(int_fw_status->intr);\n\tfw_status->fw_rx_counter = int_fw_status->fw_rx_counter;\n\tfw_status->drv_rx_counter = int_fw_status->drv_rx_counter;\n\tfw_status->tx_results_counter = int_fw_status->tx_results_counter;\n\tfw_status->rx_pkt_descs = int_fw_status->rx_pkt_descs;\n\n\tfw_status->fw_localtime = le32_to_cpu(int_fw_status->fw_localtime);\n\tfw_status->link_ps_bitmap = le32_to_cpu(int_fw_status->link_ps_bitmap);\n\tfw_status->link_fast_bitmap =\n\t\t\tle32_to_cpu(int_fw_status->link_fast_bitmap);\n\tfw_status->total_released_blks =\n\t\t\tle32_to_cpu(int_fw_status->total_released_blks);\n\tfw_status->tx_total = le32_to_cpu(int_fw_status->tx_total);\n\n\tfw_status->counters.tx_released_pkts =\n\t\t\tint_fw_status->counters.tx_released_pkts;\n\tfw_status->counters.tx_lnk_free_pkts =\n\t\t\tint_fw_status->counters.tx_lnk_free_pkts;\n\tfw_status->counters.tx_voice_released_blks =\n\t\t\tint_fw_status->counters.tx_voice_released_blks;\n\tfw_status->counters.tx_last_rate =\n\t\t\tint_fw_status->counters.tx_last_rate;\n\n\tfw_status->log_start_addr = le32_to_cpu(int_fw_status->log_start_addr);\n}\n\nstatic u32 wl12xx_sta_get_ap_rate_mask(struct wl1271 *wl,\n\t\t\t\t       struct wl12xx_vif *wlvif)\n{\n\treturn wlvif->rate_set;\n}\n\nstatic void wl12xx_conf_init(struct wl1271 *wl)\n{\n\tstruct wl12xx_priv *priv = wl->priv;\n\n\t/* apply driver default configuration */\n\tmemcpy(&wl->conf, &wl12xx_conf, sizeof(wl12xx_conf));\n\n\t/* apply default private configuration */\n\tmemcpy(&priv->conf, &wl12xx_default_priv_conf, sizeof(priv->conf));\n}\n\nstatic bool wl12xx_mac_in_fuse(struct wl1271 *wl)\n{\n\tbool supported = false;\n\tu8 major, minor;\n\n\tif (wl->chip.id == CHIP_ID_128X_PG20) {\n\t\tmajor = WL128X_PG_GET_MAJOR(wl->hw_pg_ver);\n\t\tminor = WL128X_PG_GET_MINOR(wl->hw_pg_ver);\n\n\t\t/* in wl128x we have the MAC address if the PG is >= (2, 1) */\n\t\tif (major > 2 || (major == 2 && minor >= 1))\n\t\t\tsupported = true;\n\t} else {\n\t\tmajor = WL127X_PG_GET_MAJOR(wl->hw_pg_ver);\n\t\tminor = WL127X_PG_GET_MINOR(wl->hw_pg_ver);\n\n\t\t/* in wl127x we have the MAC address if the PG is >= (3, 1) */\n\t\tif (major == 3 && minor >= 1)\n\t\t\tsupported = true;\n\t}\n\n\twl1271_debug(DEBUG_PROBE,\n\t\t     \"PG Ver major = %d minor = %d, MAC %s present\",\n\t\t     major, minor, supported ? \"is\" : \"is not\");\n\n\treturn supported;\n}\n\nstatic int wl12xx_get_fuse_mac(struct wl1271 *wl)\n{\n\tu32 mac1, mac2;\n\tint ret;\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_DRPW]);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read32(wl, WL12XX_REG_FUSE_BD_ADDR_1, &mac1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wlcore_read32(wl, WL12XX_REG_FUSE_BD_ADDR_2, &mac2);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* these are the two parts of the BD_ADDR */\n\twl->fuse_oui_addr = ((mac2 & 0xffff) << 8) +\n\t\t((mac1 & 0xff000000) >> 24);\n\twl->fuse_nic_addr = mac1 & 0xffffff;\n\n\tret = wlcore_set_partition(wl, &wl->ptable[PART_DOWN]);\n\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_get_pg_ver(struct wl1271 *wl, s8 *ver)\n{\n\tu16 die_info;\n\tint ret;\n\n\tif (wl->chip.id == CHIP_ID_128X_PG20)\n\t\tret = wl12xx_top_reg_read(wl, WL128X_REG_FUSE_DATA_2_1,\n\t\t\t\t\t  &die_info);\n\telse\n\t\tret = wl12xx_top_reg_read(wl, WL127X_REG_FUSE_DATA_2_1,\n\t\t\t\t\t  &die_info);\n\n\tif (ret >= 0 && ver)\n\t\t*ver = (s8)((die_info & PG_VER_MASK) >> PG_VER_OFFSET);\n\n\treturn ret;\n}\n\nstatic int wl12xx_get_mac(struct wl1271 *wl)\n{\n\tif (wl12xx_mac_in_fuse(wl))\n\t\treturn wl12xx_get_fuse_mac(wl);\n\n\treturn 0;\n}\n\nstatic void wl12xx_set_tx_desc_csum(struct wl1271 *wl,\n\t\t\t\t    struct wl1271_tx_hw_descr *desc,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tdesc->wl12xx_reserved = 0;\n}\n\nstatic int wl12xx_plt_init(struct wl1271 *wl)\n{\n\tint ret;\n\n\tret = wl->ops->boot(wl);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = wl->ops->hw_init(wl);\n\tif (ret < 0)\n\t\tgoto out_irq_disable;\n\n\t/*\n\t * If we are in calibrator based auto detect then we got the FEM nr\n\t * in wl->fem_manuf. No need to continue further\n\t */\n\tif (wl->plt_mode == PLT_FEM_DETECT)\n\t\tgoto out;\n\n\tret = wl1271_acx_init_mem_config(wl);\n\tif (ret < 0)\n\t\tgoto out_irq_disable;\n\n\tret = wl12xx_acx_mem_cfg(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t/* Enable data path */\n\tret = wl1271_cmd_data_path(wl, 1);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t/* Configure for CAM power saving (ie. always active) */\n\tret = wl1271_acx_sleep_auth(wl, WL1271_PSM_CAM);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\t/* configure PM */\n\tret = wl1271_acx_pm_config(wl);\n\tif (ret < 0)\n\t\tgoto out_free_memmap;\n\n\tgoto out;\n\nout_free_memmap:\n\tkfree(wl->target_mem_map);\n\twl->target_mem_map = NULL;\n\nout_irq_disable:\n\tmutex_unlock(&wl->mutex);\n\t/* Unlocking the mutex in the middle of handling is\n\t   inherently unsafe. In this case we deem it safe to do,\n\t   because we need to let any possibly pending IRQ out of\n\t   the system (and while we are WL1271_STATE_OFF the IRQ\n\t   work function will not do anything.) Also, any other\n\t   possible concurrent operations will fail due to the\n\t   current state, hence the wl1271 struct should be safe. */\n\twlcore_disable_interrupts(wl);\n\tmutex_lock(&wl->mutex);\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_get_spare_blocks(struct wl1271 *wl, bool is_gem)\n{\n\tif (is_gem)\n\t\treturn WL12XX_TX_HW_BLOCK_GEM_SPARE;\n\n\treturn WL12XX_TX_HW_BLOCK_SPARE_DEFAULT;\n}\n\nstatic int wl12xx_set_key(struct wl1271 *wl, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key_conf)\n{\n\treturn wlcore_set_key(wl, cmd, vif, sta, key_conf);\n}\n\nstatic int wl12xx_set_peer_cap(struct wl1271 *wl,\n\t\t\t       struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t       bool allow_ht_operation,\n\t\t\t       u32 rate_set, u8 hlid)\n{\n\treturn wl1271_acx_set_ht_capabilities(wl, ht_cap, allow_ht_operation,\n\t\t\t\t\t      hlid);\n}\n\nstatic bool wl12xx_lnk_high_prio(struct wl1271 *wl, u8 hlid,\n\t\t\t\t struct wl1271_link *lnk)\n{\n\tu8 thold;\n\n\tif (test_bit(hlid, &wl->fw_fast_lnk_map))\n\t\tthold = wl->conf.tx.fast_link_thold;\n\telse\n\t\tthold = wl->conf.tx.slow_link_thold;\n\n\treturn lnk->allocated_pkts < thold;\n}\n\nstatic bool wl12xx_lnk_low_prio(struct wl1271 *wl, u8 hlid,\n\t\t\t\tstruct wl1271_link *lnk)\n{\n\t/* any link is good for low priority */\n\treturn true;\n}\n\nstatic u32 wl12xx_convert_hwaddr(struct wl1271 *wl, u32 hwaddr)\n{\n\treturn hwaddr << 5;\n}\n\nstatic int wl12xx_setup(struct wl1271 *wl);\n\nstatic struct wlcore_ops wl12xx_ops = {\n\t.setup\t\t\t= wl12xx_setup,\n\t.identify_chip\t\t= wl12xx_identify_chip,\n\t.boot\t\t\t= wl12xx_boot,\n\t.plt_init\t\t= wl12xx_plt_init,\n\t.trigger_cmd\t\t= wl12xx_trigger_cmd,\n\t.ack_event\t\t= wl12xx_ack_event,\n\t.wait_for_event\t\t= wl12xx_wait_for_event,\n\t.process_mailbox_events\t= wl12xx_process_mailbox_events,\n\t.calc_tx_blocks\t\t= wl12xx_calc_tx_blocks,\n\t.set_tx_desc_blocks\t= wl12xx_set_tx_desc_blocks,\n\t.set_tx_desc_data_len\t= wl12xx_set_tx_desc_data_len,\n\t.get_rx_buf_align\t= wl12xx_get_rx_buf_align,\n\t.get_rx_packet_len\t= wl12xx_get_rx_packet_len,\n\t.tx_immediate_compl\t= NULL,\n\t.tx_delayed_compl\t= wl12xx_tx_delayed_compl,\n\t.hw_init\t\t= wl12xx_hw_init,\n\t.init_vif\t\t= NULL,\n\t.convert_fw_status\t= wl12xx_convert_fw_status,\n\t.sta_get_ap_rate_mask\t= wl12xx_sta_get_ap_rate_mask,\n\t.get_pg_ver\t\t= wl12xx_get_pg_ver,\n\t.get_mac\t\t= wl12xx_get_mac,\n\t.set_tx_desc_csum\t= wl12xx_set_tx_desc_csum,\n\t.set_rx_csum\t\t= NULL,\n\t.ap_get_mimo_wide_rate_mask = NULL,\n\t.debugfs_init\t\t= wl12xx_debugfs_add_files,\n\t.scan_start\t\t= wl12xx_scan_start,\n\t.scan_stop\t\t= wl12xx_scan_stop,\n\t.sched_scan_start\t= wl12xx_sched_scan_start,\n\t.sched_scan_stop\t= wl12xx_scan_sched_scan_stop,\n\t.get_spare_blocks\t= wl12xx_get_spare_blocks,\n\t.set_key\t\t= wl12xx_set_key,\n\t.channel_switch\t\t= wl12xx_cmd_channel_switch,\n\t.pre_pkt_send\t\t= NULL,\n\t.set_peer_cap\t\t= wl12xx_set_peer_cap,\n\t.convert_hwaddr\t\t= wl12xx_convert_hwaddr,\n\t.lnk_high_prio\t\t= wl12xx_lnk_high_prio,\n\t.lnk_low_prio\t\t= wl12xx_lnk_low_prio,\n\t.interrupt_notify\t= NULL,\n\t.rx_ba_filter\t\t= NULL,\n\t.ap_sleep\t\t= NULL,\n};\n\nstatic struct ieee80211_sta_ht_cap wl12xx_ht_cap = {\n\t.cap = IEEE80211_HT_CAP_GRN_FLD | IEEE80211_HT_CAP_SGI_20 |\n\t       (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT),\n\t.ht_supported = true,\n\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K,\n\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_8,\n\t.mcs = {\n\t\t.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t\t.rx_highest = cpu_to_le16(72),\n\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n};\n\nstatic const struct ieee80211_iface_limit wl12xx_iface_limits[] = {\n\t{\n\t\t.max = 3,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination\nwl12xx_iface_combinations[] = {\n\t{\n\t\t.max_interfaces = 3,\n\t\t.limits = wl12xx_iface_limits,\n\t\t.n_limits = ARRAY_SIZE(wl12xx_iface_limits),\n\t\t.num_different_channels = 1,\n\t},\n};\n\nstatic const struct wl12xx_clock wl12xx_refclock_table[] = {\n\t{ 19200000,\tfalse,\tWL12XX_REFCLOCK_19\t},\n\t{ 26000000,\tfalse,\tWL12XX_REFCLOCK_26\t},\n\t{ 26000000,\ttrue,\tWL12XX_REFCLOCK_26_XTAL\t},\n\t{ 38400000,\tfalse,\tWL12XX_REFCLOCK_38\t},\n\t{ 38400000,\ttrue,\tWL12XX_REFCLOCK_38_XTAL\t},\n\t{ 52000000,\tfalse,\tWL12XX_REFCLOCK_52\t},\n\t{ 0,\t\tfalse,\t0 }\n};\n\nstatic const struct wl12xx_clock wl12xx_tcxoclock_table[] = {\n\t{ 16368000,\ttrue,\tWL12XX_TCXOCLOCK_16_368\t},\n\t{ 16800000,\ttrue,\tWL12XX_TCXOCLOCK_16_8\t},\n\t{ 19200000,\ttrue,\tWL12XX_TCXOCLOCK_19_2\t},\n\t{ 26000000,\ttrue,\tWL12XX_TCXOCLOCK_26\t},\n\t{ 32736000,\ttrue,\tWL12XX_TCXOCLOCK_32_736\t},\n\t{ 33600000,\ttrue,\tWL12XX_TCXOCLOCK_33_6\t},\n\t{ 38400000,\ttrue,\tWL12XX_TCXOCLOCK_38_4\t},\n\t{ 52000000,\ttrue,\tWL12XX_TCXOCLOCK_52\t},\n\t{ 0,\t\tfalse,\t0 }\n};\n\nstatic int wl12xx_get_clock_idx(const struct wl12xx_clock *table,\n\t\t\t\tu32 freq, bool xtal)\n{\n\tint i;\n\n\tfor (i = 0; table[i].freq != 0; i++)\n\t\tif ((table[i].freq == freq) && (table[i].xtal == xtal))\n\t\t\treturn table[i].hw_idx;\n\n\treturn -EINVAL;\n}\n\nstatic int wl12xx_setup(struct wl1271 *wl)\n{\n\tstruct wl12xx_priv *priv = wl->priv;\n\tstruct wlcore_platdev_data *pdev_data = dev_get_platdata(&wl->pdev->dev);\n\n\tBUILD_BUG_ON(WL12XX_MAX_LINKS > WLCORE_MAX_LINKS);\n\tBUILD_BUG_ON(WL12XX_MAX_AP_STATIONS > WL12XX_MAX_LINKS);\n\n\twl->rtable = wl12xx_rtable;\n\twl->num_tx_desc = WL12XX_NUM_TX_DESCRIPTORS;\n\twl->num_rx_desc = WL12XX_NUM_RX_DESCRIPTORS;\n\twl->num_links = WL12XX_MAX_LINKS;\n\twl->max_ap_stations = WL12XX_MAX_AP_STATIONS;\n\twl->iface_combinations = wl12xx_iface_combinations;\n\twl->n_iface_combinations = ARRAY_SIZE(wl12xx_iface_combinations);\n\twl->num_mac_addr = WL12XX_NUM_MAC_ADDRESSES;\n\twl->band_rate_to_idx = wl12xx_band_rate_to_idx;\n\twl->hw_tx_rate_tbl_size = WL12XX_CONF_HW_RXTX_RATE_MAX;\n\twl->hw_min_ht_rate = WL12XX_CONF_HW_RXTX_RATE_MCS0;\n\twl->fw_status_len = sizeof(struct wl12xx_fw_status);\n\twl->fw_status_priv_len = 0;\n\twl->stats.fw_stats_len = sizeof(struct wl12xx_acx_statistics);\n\twl->ofdm_only_ap = true;\n\twlcore_set_ht_cap(wl, NL80211_BAND_2GHZ, &wl12xx_ht_cap);\n\twlcore_set_ht_cap(wl, NL80211_BAND_5GHZ, &wl12xx_ht_cap);\n\twl12xx_conf_init(wl);\n\n\tif (!fref_param) {\n\t\tpriv->ref_clock = wl12xx_get_clock_idx(wl12xx_refclock_table,\n\t\t\t\t\t\tpdev_data->ref_clock_freq,\n\t\t\t\t\t\tpdev_data->ref_clock_xtal);\n\t\tif (priv->ref_clock < 0) {\n\t\t\twl1271_error(\"Invalid ref_clock frequency (%d Hz, %s)\",\n\t\t\t\t     pdev_data->ref_clock_freq,\n\t\t\t\t     pdev_data->ref_clock_xtal ?\n\t\t\t\t     \"XTAL\" : \"not XTAL\");\n\n\t\t\treturn priv->ref_clock;\n\t\t}\n\t} else {\n\t\tif (!strcmp(fref_param, \"19.2\"))\n\t\t\tpriv->ref_clock = WL12XX_REFCLOCK_19;\n\t\telse if (!strcmp(fref_param, \"26\"))\n\t\t\tpriv->ref_clock = WL12XX_REFCLOCK_26;\n\t\telse if (!strcmp(fref_param, \"26x\"))\n\t\t\tpriv->ref_clock = WL12XX_REFCLOCK_26_XTAL;\n\t\telse if (!strcmp(fref_param, \"38.4\"))\n\t\t\tpriv->ref_clock = WL12XX_REFCLOCK_38;\n\t\telse if (!strcmp(fref_param, \"38.4x\"))\n\t\t\tpriv->ref_clock = WL12XX_REFCLOCK_38_XTAL;\n\t\telse if (!strcmp(fref_param, \"52\"))\n\t\t\tpriv->ref_clock = WL12XX_REFCLOCK_52;\n\t\telse\n\t\t\twl1271_error(\"Invalid fref parameter %s\", fref_param);\n\t}\n\n\tif (!tcxo_param && pdev_data->tcxo_clock_freq) {\n\t\tpriv->tcxo_clock = wl12xx_get_clock_idx(wl12xx_tcxoclock_table,\n\t\t\t\t\t\tpdev_data->tcxo_clock_freq,\n\t\t\t\t\t\ttrue);\n\t\tif (priv->tcxo_clock < 0) {\n\t\t\twl1271_error(\"Invalid tcxo_clock frequency (%d Hz)\",\n\t\t\t\t     pdev_data->tcxo_clock_freq);\n\n\t\t\treturn priv->tcxo_clock;\n\t\t}\n\t} else if (tcxo_param) {\n\t\tif (!strcmp(tcxo_param, \"19.2\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_19_2;\n\t\telse if (!strcmp(tcxo_param, \"26\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_26;\n\t\telse if (!strcmp(tcxo_param, \"38.4\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_38_4;\n\t\telse if (!strcmp(tcxo_param, \"52\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_52;\n\t\telse if (!strcmp(tcxo_param, \"16.368\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_16_368;\n\t\telse if (!strcmp(tcxo_param, \"32.736\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_32_736;\n\t\telse if (!strcmp(tcxo_param, \"16.8\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_16_8;\n\t\telse if (!strcmp(tcxo_param, \"33.6\"))\n\t\t\tpriv->tcxo_clock = WL12XX_TCXOCLOCK_33_6;\n\t\telse\n\t\t\twl1271_error(\"Invalid tcxo parameter %s\", tcxo_param);\n\t}\n\n\tpriv->rx_mem_addr = kmalloc(sizeof(*priv->rx_mem_addr), GFP_KERNEL);\n\tif (!priv->rx_mem_addr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int wl12xx_probe(struct platform_device *pdev)\n{\n\tstruct wl1271 *wl;\n\tstruct ieee80211_hw *hw;\n\tint ret;\n\n\thw = wlcore_alloc_hw(sizeof(struct wl12xx_priv),\n\t\t\t     WL12XX_AGGR_BUFFER_SIZE,\n\t\t\t     sizeof(struct wl12xx_event_mailbox));\n\tif (IS_ERR(hw)) {\n\t\twl1271_error(\"can't allocate hw\");\n\t\tret = PTR_ERR(hw);\n\t\tgoto out;\n\t}\n\n\twl = hw->priv;\n\twl->ops = &wl12xx_ops;\n\twl->ptable = wl12xx_ptable;\n\tret = wlcore_probe(wl, pdev);\n\tif (ret)\n\t\tgoto out_free;\n\n\treturn ret;\n\nout_free:\n\twlcore_free_hw(wl);\nout:\n\treturn ret;\n}\n\nstatic int wl12xx_remove(struct platform_device *pdev)\n{\n\tstruct wl1271 *wl = platform_get_drvdata(pdev);\n\tstruct wl12xx_priv *priv;\n\n\tif (!wl)\n\t\tgoto out;\n\tpriv = wl->priv;\n\n\tkfree(priv->rx_mem_addr);\n\nout:\n\treturn wlcore_remove(pdev);\n}\n\nstatic const struct platform_device_id wl12xx_id_table[] = {\n\t{ \"wl12xx\", 0 },\n\t{  } /* Terminating Entry */\n};\nMODULE_DEVICE_TABLE(platform, wl12xx_id_table);\n\nstatic struct platform_driver wl12xx_driver = {\n\t.probe\t\t= wl12xx_probe,\n\t.remove\t\t= wl12xx_remove,\n\t.id_table\t= wl12xx_id_table,\n\t.driver = {\n\t\t.name\t= \"wl12xx_driver\",\n\t}\n};\n\nmodule_platform_driver(wl12xx_driver);\n\nmodule_param_named(fref, fref_param, charp, 0);\nMODULE_PARM_DESC(fref, \"FREF clock: 19.2, 26, 26x, 38.4, 38.4x, 52\");\n\nmodule_param_named(tcxo, tcxo_param, charp, 0);\nMODULE_PARM_DESC(tcxo,\n\t\t \"TCXO clock: 19.2, 26, 38.4, 52, 16.368, 32.736, 16.8, 33.6\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Luciano Coelho <coelho@ti.com>\");\nMODULE_FIRMWARE(WL127X_FW_NAME_SINGLE);\nMODULE_FIRMWARE(WL127X_FW_NAME_MULTI);\nMODULE_FIRMWARE(WL127X_PLT_FW_NAME);\nMODULE_FIRMWARE(WL128X_FW_NAME_SINGLE);\nMODULE_FIRMWARE(WL128X_FW_NAME_MULTI);\nMODULE_FIRMWARE(WL128X_PLT_FW_NAME);\n"
}