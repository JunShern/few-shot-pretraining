{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4606",
    "text": "Q:\n\nRxJS handling closure variables\n\nMy scenario is following:\n- Reach to database for some object\n- After obtaining base object grab it's additional data\n- Merge additional data to base object\nI wish to write it in pure functional manner (i.e. with no side effects) but so far I'm unable to achieve it:\ngetMeterPointWithMeterDatabyId(id: number, allowEmpty: boolean = false): Observable<MergeObject> {\n    const params = this.getEmptyParams();\n    let mp: MergeObject; // This is my enclosed objects I refer to\n\n    return this.masterService.getMasterById(params)\n    .concatMap<MergeObject, MergeData[]>((master: MergeObject) => {\n      mp = master; // This is side effect generation\n      return this.meterService.getMasterData(params);\n    })\n    .concatMap<MasterData[], MergeObject>((md: MasterData[]) => {\n      mp.data = md.slice(); // Even more side effects\n      return Observable.of(mp); // Final result generated form impure result\n    });\n\nI think I have a ggo understanding of how Rx works when there is no cycle dependency between objects (i.e. my call chain produced A -> B -> C) but I'm loosing my confidence when I need to step back at one processing step to grab some previous data (i.e. A -> B -> A , where A finally contains B)\nEDIT: As far a si know, zip operator is doing the trick, but I'd like to know, is it possible to achieve such manually \n\nA:\n\nIf you actually need the base object to query the details (i.e., the requests must happen consecutively), you can do\nthis.service.getMaster(id)\n  .switchMap(master => this.service.getDetails(master)\n    // .catch(\u2026) <-- if you want to continue even if fetching the details fails\n    .map(details => merge(master, details))\n  )\n  .subscribe();\n\nThe trick is to simply nest the map inside the switchMap, that way master stays in scope without having to jump through hoops.\nIf the details request is actually independent, you can fire both in parallel using\nObservable.forkJoin(\n  this.service.getMaster(id),\n  this.service.getDetails(id)\n    // .catch(\u2026) <-- if you want to continue even if fetching the details fails\n)\n  .map(([master, details) => merge(master, details))\n  .subscribe();\n\nThe technique of delinearizing an operator chain, that is transforming\nsource$\n  .switchMap(data1 => transformationA(data1))\n  // From here on out, you only see data1\n  .switchMap(data2 => transformationB(data2))\n  // From here on out, you only see data2\n  .subscribe(data3 => \u2026);\n\ninto\nsource$\n  .switchMap(data1 => transformationA(data1)\n    .switchMap(data2 => transformationB(data2)\n    // You can see both data1 and data2 here!\n  )\n  .subscribe(data3 => \u2026);\n\nis useful quite often in order to keep data from multiple steps in scope, e.g. to combine them. It's definitely something to always keep in mind: you can also nest.\n\n"
}