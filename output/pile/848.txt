{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains For example."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "848",
    "text": "Q:\n\nConvert nested JSON to nested Java object using gson TypeAdapter\n\nI am trying to use google gson TypeAdapter for converting nested JSON into nested Java object having implementation of TypeAdapter for each class. But I don't want to write complete read() method logic in single adapter class. I have referred few questions and blog examples over net. But complete read logic is in single class.\nFor small nested object its fine to have logic in single Adapter but for big object (having more than 10-15 fields in each class) it's not good.\n[Update]\nFor example json keys look same as of class attributes, but in actual I will be getting input as hyphen-separated-small-case keys instead of Camel case keys. So my json and java classes attribute names will not be same hence I have to write my custom logic for mapping.\nE.g.\nSample Json input :\n{\n  \"id\": 1,\n  \"name\": \"Alex\",\n  \"emailId\": \"alex@gmail.com\",\n  \"address\": {\n    \"address\": \"21ST & FAIRVIEW AVE\",\n    \"district\": \"district\",\n    \"city\": \"EATON\",\n    \"region\": \"PA\",\n    \"postalCode\": \"18044\",\n    \"country\": \"US\"\n  }\n}\n\nAnd Java beans are as below :\n//Employee object class\npublic class Employee {\n\n  private int id;\n  private String name;\n  private String emailId;\n  private Address address;\n  ..\n}\n\n//Address object class\npublic class Address {\n\n  private String address;\n  private String district;\n  private String city;\n  private String region;\n  private String postalCode;\n  private String country;\n  ..\n}\n\nI want to have two different adapters and integrate multiple adapters in read() method.\npublic class EmployeeAdapter extends TypeAdapter<Employee> {\n  @Override\n  public void write(JsonWriter out, Employee employee) throws IOException {\n    //\n  }\n\n  @Override\n  public Employee read(JsonReader jsonReader) throws IOException {\n    //read logic for employee class using AddressAdapter for address json\n  }\n}\n\npublic class AddressAdapter extends TypeAdapter<Address> {\n  @Override\n  public void write(JsonWriter out, Address address) throws IOException {\n    //\n  }\n\n  @Override\n  public Address read(JsonReader jsonReader) throws IOException {\n    //read logic for Address class\n  }\n}\n\nHow can I use AddressAdapter inside EmployeeAdapter? \n\nA:\n\nI use a TypeAdapterFactory for this kind of thing. It allows passing the gson instance to the TypeAdapter instance.\n(In the example below, I left in passing \"rawType\" to the TypeAdapter instance, since its often useful.  Pull that out if not needed.)\nExample TypeAdapterFactory:\npublic class ContactTypeAdapterFactory implements TypeAdapterFactory {\n\n    // Add @SuppressWarnings(\"unchecked\") as needed.\n\n    @Override\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n        final Class<? super T> rawClass = typeToken.getRawType();\n        if (Employee.class.isAssignableFrom(rawClass)) {\n            // Return EmployeeAdapter for Employee class\n            return EmployeeAdapter.get(rawClass, gson);\n        }\n        if (Address.class.isAssignableFrom(rawClass)) {\n            // Return AddressAdapter for Address class\n            return AddressAdapter.get(rawClass, gson);\n        }\n        return null; // let Gson find somebody else\n    }\n\n    private static final class EmployeeAdapter<T> extends TypeAdapter<T> {\n\n        private final Gson gson;\n        private final Class<? super T> rawClass;  // Not used in this example\n\n        private EmployeeAdapter(Class<? super T> rawClass, Gson gson) {\n            this.rawClass = rawClass;\n            this.gson = gson;\n        }\n\n        private static <T> TypeAdapter<T> get(Class<? super T> rawClass, Gson gson) {\n            // Wrap TypeAdapter in nullSafe so we don't need to do null checks\n            return new EmployeeAdapter<>(rawClass, gson).nullSafe();\n        }\n\n        @Override\n        public void write(JsonWriter out, T value)\n                throws IOException {\n\n            // We should only ever be here for Employee types\n            // Cast value to Employee\n            Employee record = (Employee)value;\n\n            // Output start of JSON object\n            out.beginObject();\n\n            // Output key / value pairs\n            out.name(\"name\");\n            gson.getAdapter(String.class).write(out, record.getName());\n            // [...]\n            out.name(\"address\");\n            gson.getAdapter(Address.class).write(out, record.getAddress());\n\n            // Output end of JSON object\n            out.endObject();\n        }\n\n        @Override\n        public T read(JsonReader in)\n                throws IOException {\n\n            String fieldName;\n\n            // Create an empty Employee object\n            Employee record = new Employee();\n\n            // Consume start of JSON object\n            in.beginObject();\n\n            // Iterate each key/value pair in the json object\n            while (in.hasNext()) {\n                fieldName = in.nextName();\n                switch (fieldName) {\n                    case \"name\":\n                        record.setName(gson.getAdapter(String.class).read(in));\n                        break;\n                    // [...] \n                    case \"address\":\n                        record.setAddress(gson.getAdapter(Address.class).read(in));\n                        break;\n                    default:\n                        // Skip any values we don't support\n                        in.skipValue();\n                }\n            }\n            // Consume end of JSON object\n            in.endObject();\n\n            // Return new Object\n            return (T)record;\n        }\n\n    }\n\n    private static final class AddressAdapter<T> extends TypeAdapter<T> {\n\n        private final Gson gson;\n        private final Class<? super T> rawClass; // Not used in this example\n\n        private AddressAdapter(Class<? super T> rawClass, Gson gson) {\n            this.rawClass = rawClass;\n            this.gson = gson;\n        }\n\n        private static <T> TypeAdapter<T> get(Class<? super T> rawClass, Gson gson) {\n            // Wrap TypeAdapter in nullSafe so we don't need to do null checks\n            return new AddressAdapter<>(rawClass, gson).nullSafe();\n        }\n\n        @Override\n        public void write(JsonWriter out, T value)\n                throws IOException {\n\n            // We should only ever be here for Address types\n            // Cast value to Address\n            Address record = (Address)value;\n\n            // Output start of JSON object\n            out.beginObject();\n\n            // Output key / value pairs\n            out.name(\"address\");\n            gson.getAdapter(String.class).write(out, record.getName());\n            // [...]\n            out.name(\"country\");\n            gson.getAdapter(String.class).write(out, record.getCountry());\n\n            // Output end of JSON object\n            out.endObject();\n        }\n\n        @Override\n        public T read(JsonReader in)\n                throws IOException {\n\n            String fieldName;\n\n            Address record = new Address();\n            in.beginObject();\n            // Iterate each parameter in the json object\n            while (in.hasNext()) {\n                fieldName = in.nextName();\n                switch (fieldName) {\n                    case \"address\":\n                        record.setAddress(gson.getAdapter(String.class).read(in));\n                        break;\n                    // [...]    \n                    case \"country\":\n                        record.setCountry(gson.getAdapter(String.class).read(in));\n                        break;\n                    default:\n                        in.skipValue();\n                }\n            }\n            in.endObject();\n            return (T)record;\n\n        }\n\n    }\n\n}\n\nUse:\nGson gson = new GsonBuilder()\n    .registerTypeAdapterFactory(new ContactTypeAdapterFactory())\n    .create();\nEmployee employee = gson.fromJson(jsonString, Employee.class);\n\n"
}