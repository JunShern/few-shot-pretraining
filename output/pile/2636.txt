{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2636",
    "text": "Q:\n\nMemory leaks and dispose\n\nMay I do not understand the conecept or I do something wrong.\nI have some questions about the memory management in .NET.\nImagine the situation:\nForm1 is the big man Form, as MDI-parent and a little FormChild, is bound as child:\npublic partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n        }\n\n        private void simpleButton1_Click(object sender, EventArgs e)\n        {\n            FormChild formChild = new FormChild();\n\n            formChild.MdiParent = this;\n            formChild.Show();\n\n        }\n    }\n\nNow the child is allocating a little bit memory as simulation:\npublic partial class FormChild : Form\n{\n    private readonly List<byte[]> _list = new List<byte[]>();\n\n    public FormChild()\n    {\n        InitializeComponent();\n\n    }\n\n    private void FormChild_Load(object sender, EventArgs e)\n    {\n        int i = 0;\n        while (i < 100)\n        {\n            _list.Add(new byte[1024 * 1024 * 10]);\n            i += 1;\n        }\n\n    }\n\n}\n\nNow, I'm inspecting with a memory profiler whats going on in the memory heap.\nI see, if i click on the button, the memory is allocated. Then I close the FormChild and it calls Dispose(). But the memory is still allocated. If I click again a System.OutOfMemoryException occures.\nWhy is the GC waiting to free the managed memory?\nOr is this my mistake of design?\n\nA:\n\nThe GC only frees memory in response to memory pressure, the main purpose of Dispose is to clean up non-memory related resources.\nIn other words nulling out managed objects isn't necessarily going to make them get collected any faster, but makes diagnosing memory issues much easier to diagnose.\n\nA:\n\nIt looks like some sort of timing problem, where the first instance of formChild  is still reachable (ie not garbage) wen the second one is created. You can't accommodate that _list twice. \nNote that I close the FormChild and it calls Dispose() is a statement about resources and Window handles, not about freeing the memory. \nIt is not clear if you wrote your own Dispose() but in this (rather special) case you should. \n\nCut the void Dispose(bool disposing) method from the FormChild.Designer.cs file and move it to FormChild.cs . \nuse it to release the huge memory block:\nprotected override void Dispose(bool disposing)\n{\n    _list = null;  // add this\n\n    if (disposing && (components != null))\n    {\n        components.Dispose();\n    }\n    base.Dispose(disposing);\n}\n\nNote that this is not a 'usual' form of memory management but it's needed because your _list is unusual too. \n\n"
}