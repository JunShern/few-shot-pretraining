{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9729",
    "text": "Q:\n\nHow can I set a listnode value to Null without getting this error?\n\nI just would Like to take a moment to thank Remy Lebeau for editing this post for me.\nMY compiler is giving me this error:\n\nmain.cpp:93:20: error: invalid conversion from \u2018int\u2019 to \u2018listnode*\u2019 [-fpermissive]\n  temp -> next = NULL;\n\nThis is in the InsertTail method.\nI don't understand where the issue is. Can someone help me to solve this please? All I need is to be able to set the listnode value to Null.\nHere is my C++ file:\nprogram4.cpp\n#include <iostream>\n\nusing namespace std;\n\n#undef NULL\n\nconst int NULL = 0;\n\ntypedef int element;\n\nconst element SENTINEL = -1;\n\nelement read_element();\n\nclass listnode{\n\n    public:\n        element data;\n        listnode * next;\n\n    };\n\nclass LList {\n\n    private:\n        listnode * head;\n        listnode * tail;\n\n    public:\n        LList();\n        ~LList();\n        void Print();\n        void InsertHead(element thing);\n        void InsertTail(element thing);\n        element DeleteHead();\n        void ReadForward();\n        void ReadBackward();\n        void Clean();\n        void Steal(LList & Victim);\n        void Append(LList & Donor);\n        void Duplicate(LList & Source);\n        void Reverse();\n\n    };\n\nvoid LList::Print(){\n\n    // PRE: the N. O. LList is valid\n    // POST: the N. O. LList is unchanged, and its elements\n    //      have been displayed\n\n    listnode * temp;\n\n    temp = head;\n    while (temp != NULL){\n        cout << temp -> data << endl;\n        temp = temp -> next;\n        }\n\n    }\n\nvoid LList::ReadForward(){\n\n    // PRE: the N. O. LList is valid\n    // POST: the N. O. LList is valid, all of its previous\n    //      listnodes have been deleted, and it now\n    //      consists of new listnodes containing elements\n    //      given by the user in forward order\n\n    element userval;\n\n    Clean();\n    cout << \"Enter elements, \" << SENTINEL << \" to stop: \";\n    userval = read_element();\n    while (userval != SENTINEL){\n        InsertTail(userval);\n        userval = read_element();\n        }\n\n    }\n\nvoid LList::InsertTail(element thing){\n\n    // PRE: the N. O. LList is valid\n    // POST: the N. O. LList is unchanged, except that a\n    //      new listnode containing element thing has been\n    //      inserted at the tail-end of the list\n\n    listnode * temp;\n\n    temp = new listnode;\n    temp -> data = thing;\n    temp -> next = NULL;\n    if (head == NULL)\n        head = temp;\n    else\n        tail -> next = temp;\n    tail = temp;\n\n    }\n\nelement read_element(){\n\n    // PRE: the user must enter a series of zero or \n    //      more non-valid element values, followed\n    //      by a valid element value \n    //\n    // POST: all entered non-valid element values will\n    //      be successfully discarded, and the first\n    //      valid element value entered will be \n    //      returned\n\n    element userval;\n\n    cin >> boolalpha >> userval;\n    while (! cin.good()){\n        cin.clear();\n        cin.ignore(80, '\\n');\n        cout << \"Invalid data type, should be an element, \"\n            << \"try again: \";\n        cin >> boolalpha >> userval;\n        }\n    return userval;\n    }\n\nvoid LList::ReadBackward(){\n\n    // PRE: the N. O. LList is valid \n    // POST: the N. O. LList is valid, all of its previous\n    //      listnodes have been deleted, and it now\n    //      consists of new listnodes containing elements\n    //      given by the user in backward order\n\n    element userval;\n\n    Clean();\n    cout << \"Enter elements, \" << SENTINEL << \" to stop: \";\n    userval = read_element();\n    while (userval != SENTINEL){\n        InsertHead(userval);\n        userval = read_element();\n        }\n\n    }\n\nvoid LList::InsertHead(element thing){\n\n    // PRE: the N. O. LList is valid\n    // POST: the N. O. LList is unchanged, except that a \n    //      new listnode containing element thing has been\n    //      inserted at the head-end of the list \n\n    listnode * temp;\n\n    temp = new listnode;\n    temp -> data = thing;\n    temp -> next = head;\n    if (head == NULL)\n        tail = temp;\n    else\n        ;\n    head = temp;\n\n    }\n\nvoid LList::Clean(){\n    // PRE: the N. O. LList is valid \n    // POST: the N. O. LList is valid and empty, and all of \n    //      its listnodes have been deleted\n\n    while (head != NULL)\n        DeleteHead();\n\n    }\n\nelement LList::DeleteHead(){\n\n    // PRE: the N. O. LList is valid and not empty\n    // POST: the N. O. LList is unchanged, except that the \n    //      listnode at the head end of the list has been\n    //      deleted, and its data element has been\n    //      returned\n\n    listnode * temp;\n    element thing;\n\n    temp = head;\n    head = head -> next;\n    thing = temp -> data;\n    delete temp;\n    return thing;\n    }\n\nLList::LList(){\n\n    // PRE: none\n    // POST: the N. O. LList is valid and empty\n\n    head = NULL;\n    }\n\nLList::~LList(){\n\n    // PRE: the N. O. LList is valid \n    // POST: the N. O. LList is valid and empty, and its \n    //      listnodes have been deleted \n\n    Clean();\n    }\n\nvoid LList::Steal(LList & Victim){\n\n    // PRE: the N. O. and Victim LLists are valid\n    // POST: the Victim LList is valid and empty\n    //      the N. O. LList is valid, all of its previous\n    //      listnodes have been deleted, and it now\n    //      consists of the listnodes originally on the \n    //      Victim LList\n\n    Clean();\n    head = Victim.head;\n    tail = Victim.tail;\n    Victim.head = NULL;\n\n    }\n\nvoid LList::Append(LList & Donor){\n\n    // PRE: the N. O. and Donor LLists are valid \n    // POST: the Donor LList is valid and empty\n    //      the N. O. LList is valid, and it now consists\n    //      of its own original listnodes followed by the \n    //      listnodes originally on the Donor LList\n\n    if (head != NULL)\n        tail -> next = Donor.head;\n    else\n        head = Donor.head;\n    if (Donor.head != NULL)\n        tail = Donor.tail;\n    else\n        ;\n    Donor.head = NULL;\n    }\n\nvoid LList::Duplicate(LList & Source){\n\n    // PRE: the N. O. and Source LLists are valid \n    // POST: the Source LList is unchanged \n    //      the N. O. LList is valid, all of its previous\n    //      listnodes have been deleted, and it now\n    //      consists of listnodes containing the same\n    //      elements and in the same order as on the \n    //      Source LList\n\n    listnode * temp;\n\n    Clean();\n    temp = Source.head;\n    while (temp != NULL){\n        InsertTail(temp -> data);\n        temp = temp -> next;\n        }\n\n    }\n\nvoid LList::Reverse(){\n\n    // PRE: the N. O. LList is valid \n    // POST: the N. O. LList is unchanged, except its \n    //      elements are in reverse order \n\n    listnode * temp;\n    LList Helper;\n\n    temp = head;\n    while (temp != NULL){\n        Helper.InsertHead(temp -> data);\n        temp = temp -> next;\n        }\n    Steal(Helper);\n\n    }\n\niny main(){\n\n    cout << \"creating/constructing LList object L\" << endl;\n    LList L;\n    cout << \"L has been created/constructed\" << endl;\n\n    cout << \"L is calling its print method\" << endl;\n    L.Print();\n    cout << \"L has been printed\" << endl;\n\n    cout << \"L is calling its ReadForward method\" << endl;\n    L.ReadForward();\n    cout << \"L has been read forward\" << endl;\n\n    cout << \"L is calling its Print method\" << endl;\n    L.Print();\n    cout << \"L has been printed\" << endl;\n\n    cout << \"L is calling its ReadBackward method\" << endl;\n    L.ReadBackward();\n    cout << \"L has been read backward\" << endl;\n\n    cout << \"L is calling its Print method\" << endl;\n    L.Print();\n    cout << \"L has been printed\" << endl;\n\n    cout << \"L is calling its Clean method\" << endl;\n    L.Clean();\n    cout << \"L has been cleaned\" << endl;\n\n    cout << \"L is calling its Print method\" << endl;\n    L.Print();\n    cout << \"L has been printed\" << endl;\n\n    }\n\nA:\n\nThe reason of the error this code\n#undef NULL\n\nconst int NULL = 0;\n\nIt is unclear why you decided to use it. But to avoid the error just remove these two lines.\nThis declaration\nconst int NULL = 0;\n\ndoes not introduce a null-pointer constant.\nMoreover instead of NULL you could use nullptr.\nPay attention to that the class listnode should be a private member of the class LList.\nFor example\nclass LList {\n\n    private:\n\n        struct listnode{\n            element data;\n            listnode * next;\n        } *head = nullptr, *tail = nullptr;\n        //...\n\n"
}