{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4284",
    "text": "Q:\n\nNSString allocation and initializing\n\nWhat is the difference between:\nNSString *string1 = @\"This is string 1.\";\n\nand\nNSString *string2 = [[NSString alloc]initWithString:@\"This is string 2.];\n\nWhy am I not allocating and initializing the first string, yet it still works? I thought I was supposed to allocate NSString since it is an object? \nIn Cocoa Touch,\n-(IBAction) clicked: (id)sender{\n   NSString *titleOfButton = [sender titleForState:UIControlStateNormal];\n   NSString *newLabelText = [[NSString alloc]initWithFormat:@\"%@\", titleOfButton];\n   labelsText.text=newLabelText;\n   [newLabelText release];\n}\n\nWhy do I not allocate and initialize for the titleOfButton string? Does the method I call do that for me? \nAlso, I'm using XCode 4, but I dislike iOS 5, and such, so I do not use ARC if that matters. Please don't say I should, I am just here to find out why this is so. Thanks!\n\nA:\n\nThe variable string1 is an NSString string literal. The compiler allocates space for it in your executable file. It is loaded into memory and initialized when your program is run. It lives as long as the app runs. You don't need to retain or release it.\nThe lifespan of variable string2 is as long as you dictate, up to the point when you release its last reference. You allocate space for it, so you're responsible for cleaning up after it.\nThe lifespan of variable titleOfButton is the life of the method -clicked:. That's because the method -titleForState: returns an autorelease-d NSString. That string will be released automatically, once you leave the scope of the method.\nYou don't need to create newLabelText. That step is redundant and messy. Simply set the labelsText.text property to titleOfButton:\nlabelsText.text = titleOfButton;\n\nWhy use properties? Because setting this retain property will increase the reference count of titleOfButton by one (that's why it's called a retain property), and so the string that is pointed to by titleOfButton will live past the end of -clicked:.\nAnother way to think about the use of retain in this example is that labelsText.text is \"taking ownership\" of the string pointed to by titleOfButton. That string will now last as long as labelsText lives (unless some other variable also takes ownership of the string).\n\n"
}