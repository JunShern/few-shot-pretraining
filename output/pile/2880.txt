{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 41 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2880",
    "text": "<?php\n/**\n * Zend Framework\n *\n * LICENSE\n *\n * This source file is subject to the new BSD license that is bundled\n * with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * http://framework.zend.com/license/new-bsd\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@zend.com so we can send you a copy immediately.\n *\n * @category  Zend\n * @package   Zend_Uri\n * @copyright  Copyright (c) 2005-2011 Zend Technologies USA Inc. (http://www.zend.com)\n * @license   http://framework.zend.com/license/new-bsd     New BSD License\n * @version   $Id: Http.php 23970 2011-05-03 15:46:57Z ralph $\n */\n\n/**\n * @see Zend_Uri\n */\nrequire_once 'Zend/Uri.php';\n\n/**\n * @see Zend_Validate_Hostname\n */\nrequire_once 'Zend/Validate/Hostname.php';\n\n/**\n * HTTP(S) URI handler\n *\n * @category  Zend\n * @package   Zend_Uri\n * @uses      Zend_Uri\n * @copyright  Copyright (c) 2005-2011 Zend Technologies USA Inc. (http://www.zend.com)\n * @license   http://framework.zend.com/license/new-bsd     New BSD License\n */\nclass Zend_Uri_Http extends Zend_Uri\n{\n    /**\n     * Character classes for validation regular expressions\n     */\n    const CHAR_ALNUM    = 'A-Za-z0-9';\n    const CHAR_MARK     = '-_.!~*\\'()\\[\\]';\n    const CHAR_RESERVED = ';\\/?:@&=+$,';\n    const CHAR_SEGMENT  = ':@&=+$,;';\n    const CHAR_UNWISE   = '{}|\\\\\\\\^`';\n\n    /**\n     * HTTP username\n     *\n     * @var string\n     */\n    protected $_username = '';\n\n    /**\n     * HTTP password\n     *\n     * @var string\n     */\n    protected $_password = '';\n\n    /**\n     * HTTP host\n     *\n     * @var string\n     */\n    protected $_host = '';\n\n    /**\n     * HTTP post\n     *\n     * @var string\n     */\n    protected $_port = '';\n\n    /**\n     * HTTP part\n     *\n     * @var string\n     */\n    protected $_path = '';\n\n    /**\n     * HTTP query\n     *\n     * @var string\n     */\n    protected $_query = '';\n\n    /**\n     * HTTP fragment\n     *\n     * @var string\n     */\n    protected $_fragment = '';\n\n    /**\n     * Regular expression grammar rules for validation; values added by constructor\n     *\n     * @var array\n     */\n    protected $_regex = array();\n\n    /**\n     * Constructor accepts a string $scheme (e.g., http, https) and a scheme-specific part of the URI\n     * (e.g., example.com/path/to/resource?query=param#fragment)\n     *\n     * @param  string $scheme         The scheme of the URI\n     * @param  string $schemeSpecific The scheme-specific part of the URI\n     * @throws Zend_Uri_Exception When the URI is not valid\n     */\n    protected function __construct($scheme, $schemeSpecific = '')\n    {\n        // Set the scheme\n        $this->_scheme = $scheme;\n\n        // Set up grammar rules for validation via regular expressions. These\n        // are to be used with slash-delimited regular expression strings.\n\n        // Escaped special characters (eg. '%25' for '%')\n        $this->_regex['escaped']    = '%[[:xdigit:]]{2}';\n\n        // Unreserved characters\n        $this->_regex['unreserved'] = '[' . self::CHAR_ALNUM . self::CHAR_MARK . ']';\n\n        // Segment can use escaped, unreserved or a set of additional chars\n        $this->_regex['segment']    = '(?:' . $this->_regex['escaped'] . '|[' .\n            self::CHAR_ALNUM . self::CHAR_MARK . self::CHAR_SEGMENT . '])*';\n\n        // Path can be a series of segmets char strings seperated by '/'\n        $this->_regex['path']       = '(?:\\/(?:' . $this->_regex['segment'] . ')?)+';\n\n        // URI characters can be escaped, alphanumeric, mark or reserved chars\n        $this->_regex['uric']       = '(?:' . $this->_regex['escaped'] . '|[' .\n            self::CHAR_ALNUM . self::CHAR_MARK . self::CHAR_RESERVED .\n\n        // If unwise chars are allowed, add them to the URI chars class\n            (self::$_config['allow_unwise'] ? self::CHAR_UNWISE : '') . '])';\n\n        // If no scheme-specific part was supplied, the user intends to create\n        // a new URI with this object.  No further parsing is required.\n        if (strlen($schemeSpecific) === 0) {\n            return;\n        }\n\n        // Parse the scheme-specific URI parts into the instance variables.\n        $this->_parseUri($schemeSpecific);\n\n        // Validate the URI\n        if ($this->valid() === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Invalid URI supplied');\n        }\n    }\n\n    /**\n     * Creates a Zend_Uri_Http from the given string\n     *\n     * @param  string $uri String to create URI from, must start with\n     *                     'http://' or 'https://'\n     * @throws InvalidArgumentException  When the given $uri is not a string or\n     *                                   does not start with http:// or https://\n     * @throws Zend_Uri_Exception        When the given $uri is invalid\n     * @return Zend_Uri_Http\n     */\n    public static function fromString($uri)\n    {\n        if (is_string($uri) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('$uri is not a string');\n        }\n\n        $uri            = explode(':', $uri, 2);\n        $scheme         = strtolower($uri[0]);\n        $schemeSpecific = isset($uri[1]) === true ? $uri[1] : '';\n\n        if (in_array($scheme, array('http', 'https')) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"Invalid scheme: '$scheme'\");\n        }\n\n        $schemeHandler = new Zend_Uri_Http($scheme, $schemeSpecific);\n        return $schemeHandler;\n    }\n\n    /**\n     * Parse the scheme-specific portion of the URI and place its parts into instance variables.\n     *\n     * @param  string $schemeSpecific The scheme-specific portion to parse\n     * @throws Zend_Uri_Exception When scheme-specific decoposition fails\n     * @throws Zend_Uri_Exception When authority decomposition fails\n     * @return void\n     */\n    protected function _parseUri($schemeSpecific)\n    {\n        // High-level decomposition parser\n        $pattern = '~^((//)([^/?#]*))([^?#]*)(\\?([^#]*))?(#(.*))?$~';\n        $status  = @preg_match($pattern, $schemeSpecific, $matches);\n        if ($status === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Internal error: scheme-specific decomposition failed');\n        }\n\n        // Failed decomposition; no further processing needed\n        if ($status === false) {\n            return;\n        }\n\n        // Save URI components that need no further decomposition\n        $this->_path     = isset($matches[4]) === true ? $matches[4] : '';\n        $this->_query    = isset($matches[6]) === true ? $matches[6] : '';\n        $this->_fragment = isset($matches[8]) === true ? $matches[8] : '';\n\n        // Additional decomposition to get username, password, host, and port\n        $combo   = isset($matches[3]) === true ? $matches[3] : '';\n        $pattern = '~^(([^:@]*)(:([^@]*))?@)?((?(?=[[])[[][^]]+[]]|[^:]+))(:(.*))?$~';        \n        $status  = @preg_match($pattern, $combo, $matches);\n        if ($status === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Internal error: authority decomposition failed');\n        }\n        \n        // Save remaining URI components\n        $this->_username = isset($matches[2]) === true ? $matches[2] : '';\n        $this->_password = isset($matches[4]) === true ? $matches[4] : '';\n        $this->_host     = isset($matches[5]) === true \n                         ? preg_replace('~^\\[([^]]+)\\]$~', '\\1', $matches[5])  // Strip wrapper [] from IPv6 literal\n                         : '';\n        $this->_port     = isset($matches[7]) === true ? $matches[7] : '';\n    }\n\n    /**\n     * Returns a URI based on current values of the instance variables. If any\n     * part of the URI does not pass validation, then an exception is thrown.\n     *\n     * @throws Zend_Uri_Exception When one or more parts of the URI are invalid\n     * @return string\n     */\n    public function getUri()\n    {\n        if ($this->valid() === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('One or more parts of the URI are invalid');\n        }\n\n        $password = strlen($this->_password) > 0 ? \":$this->_password\" : '';\n        $auth     = strlen($this->_username) > 0 ? \"$this->_username$password@\" : '';\n        $port     = strlen($this->_port) > 0 ? \":$this->_port\" : '';\n        $query    = strlen($this->_query) > 0 ? \"?$this->_query\" : '';\n        $fragment = strlen($this->_fragment) > 0 ? \"#$this->_fragment\" : '';\n\n        return $this->_scheme\n             . '://'\n             . $auth\n             . $this->_host\n             . $port\n             . $this->_path\n             . $query\n             . $fragment;\n    }\n\n    /**\n     * Validate the current URI from the instance variables. Returns true if and only if all\n     * parts pass validation.\n     *\n     * @return boolean\n     */\n    public function valid()\n    {\n        // Return true if and only if all parts of the URI have passed validation\n        return $this->validateUsername()\n           and $this->validatePassword()\n           and $this->validateHost()\n           and $this->validatePort()\n           and $this->validatePath()\n           and $this->validateQuery()\n           and $this->validateFragment();\n    }\n\n    /**\n     * Returns the username portion of the URL, or FALSE if none.\n     *\n     * @return string\n     */\n    public function getUsername()\n    {\n        return strlen($this->_username) > 0 ? $this->_username : false;\n    }\n\n    /**\n     * Returns true if and only if the username passes validation. If no username is passed,\n     * then the username contained in the instance variable is used.\n     *\n     * @param  string $username The HTTP username\n     * @throws Zend_Uri_Exception When username validation fails\n     * @return boolean\n     * @link   http://www.faqs.org/rfcs/rfc2396.html\n     */\n    public function validateUsername($username = null)\n    {\n        if ($username === null) {\n            $username = $this->_username;\n        }\n\n        // If the username is empty, then it is considered valid\n        if (strlen($username) === 0) {\n            return true;\n        }\n\n        // Check the username against the allowed values\n        $status = @preg_match('/^(?:' . $this->_regex['escaped'] . '|[' .\n            self::CHAR_ALNUM . self::CHAR_MARK . ';:&=+$,' . '])+$/', $username);\n\n        if ($status === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Internal error: username validation failed');\n        }\n\n        return $status === 1;\n    }\n\n    /**\n     * Sets the username for the current URI, and returns the old username\n     *\n     * @param  string $username The HTTP username\n     * @throws Zend_Uri_Exception When $username is not a valid HTTP username\n     * @return string\n     */\n    public function setUsername($username)\n    {\n        if ($this->validateUsername($username) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"Username \\\"$username\\\" is not a valid HTTP username\");\n        }\n\n        $oldUsername     = $this->_username;\n        $this->_username = $username;\n\n        return $oldUsername;\n    }\n\n    /**\n     * Returns the password portion of the URL, or FALSE if none.\n     *\n     * @return string\n     */\n    public function getPassword()\n    {\n        return strlen($this->_password) > 0 ? $this->_password : false;\n    }\n\n    /**\n     * Returns true if and only if the password passes validation. If no password is passed,\n     * then the password contained in the instance variable is used.\n     *\n     * @param  string $password The HTTP password\n     * @throws Zend_Uri_Exception When password validation fails\n     * @return boolean\n     * @link   http://www.faqs.org/rfcs/rfc2396.html\n     */\n    public function validatePassword($password = null)\n    {\n        if ($password === null) {\n            $password = $this->_password;\n        }\n\n        // If the password is empty, then it is considered valid\n        if (strlen($password) === 0) {\n            return true;\n        }\n\n        // If the password is nonempty, but there is no username, then it is considered invalid\n        if (strlen($password) > 0 and strlen($this->_username) === 0) {\n            return false;\n        }\n\n        // Check the password against the allowed values\n        $status = @preg_match('/^(?:' . $this->_regex['escaped'] . '|[' .\n            self::CHAR_ALNUM . self::CHAR_MARK . ';:&=+$,' . '])+$/', $password);\n\n        if ($status === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Internal error: password validation failed.');\n        }\n\n        return $status == 1;\n    }\n\n    /**\n     * Sets the password for the current URI, and returns the old password\n     *\n     * @param  string $password The HTTP password\n     * @throws Zend_Uri_Exception When $password is not a valid HTTP password\n     * @return string\n     */\n    public function setPassword($password)\n    {\n        if ($this->validatePassword($password) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"Password \\\"$password\\\" is not a valid HTTP password.\");\n        }\n\n        $oldPassword     = $this->_password;\n        $this->_password = $password;\n\n        return $oldPassword;\n    }\n\n    /**\n     * Returns the domain or host IP portion of the URL, or FALSE if none.\n     *\n     * @return string\n     */\n    public function getHost()\n    {\n        return strlen($this->_host) > 0 ? $this->_host : false;\n    }\n\n    /**\n     * Returns true if and only if the host string passes validation. If no host is passed,\n     * then the host contained in the instance variable is used.\n     *\n     * @param  string $host The HTTP host\n     * @return boolean\n     * @uses   Zend_Filter\n     */\n    public function validateHost($host = null)\n    {\n        if ($host === null) {\n            $host = $this->_host;\n        }\n\n        // If the host is empty, then it is considered invalid\n        if (strlen($host) === 0) {\n            return false;\n        }\n\n        // Check the host against the allowed values; delegated to Zend_Filter.\n        $validate = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_ALL);\n\n        return $validate->isValid($host);\n    }\n\n    /**\n     * Sets the host for the current URI, and returns the old host\n     *\n     * @param  string $host The HTTP host\n     * @throws Zend_Uri_Exception When $host is nota valid HTTP host\n     * @return string\n     */\n    public function setHost($host)\n    {\n        if ($this->validateHost($host) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"Host \\\"$host\\\" is not a valid HTTP host\");\n        }\n\n        $oldHost     = $this->_host;\n        $this->_host = $host;\n\n        return $oldHost;\n    }\n\n    /**\n     * Returns the TCP port, or FALSE if none.\n     *\n     * @return string\n     */\n    public function getPort()\n    {\n        return strlen($this->_port) > 0 ? $this->_port : false;\n    }\n\n    /**\n     * Returns true if and only if the TCP port string passes validation. If no port is passed,\n     * then the port contained in the instance variable is used.\n     *\n     * @param  string $port The HTTP port\n     * @return boolean\n     */\n    public function validatePort($port = null)\n    {\n        if ($port === null) {\n            $port = $this->_port;\n        }\n\n        // If the port is empty, then it is considered valid\n        if (strlen($port) === 0) {\n            return true;\n        }\n\n        // Check the port against the allowed values\n        return ctype_digit((string) $port) and 1 <= $port and $port <= 65535;\n    }\n\n    /**\n     * Sets the port for the current URI, and returns the old port\n     *\n     * @param  string $port The HTTP port\n     * @throws Zend_Uri_Exception When $port is not a valid HTTP port\n     * @return string\n     */\n    public function setPort($port)\n    {\n        if ($this->validatePort($port) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"Port \\\"$port\\\" is not a valid HTTP port.\");\n        }\n\n        $oldPort     = $this->_port;\n        $this->_port = $port;\n\n        return $oldPort;\n    }\n\n    /**\n     * Returns the path and filename portion of the URL.\n     *\n     * @return string\n     */\n    public function getPath()\n    {\n        return strlen($this->_path) > 0 ? $this->_path : '/';\n    }\n\n    /**\n     * Returns true if and only if the path string passes validation. If no path is passed,\n     * then the path contained in the instance variable is used.\n     *\n     * @param  string $path The HTTP path\n     * @throws Zend_Uri_Exception When path validation fails\n     * @return boolean\n     */\n    public function validatePath($path = null)\n    {\n        if ($path === null) {\n            $path = $this->_path;\n        }\n\n        // If the path is empty, then it is considered valid\n        if (strlen($path) === 0) {\n            return true;\n        }\n\n        // Determine whether the path is well-formed\n        $pattern = '/^' . $this->_regex['path'] . '$/';\n        $status  = @preg_match($pattern, $path);\n        if ($status === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Internal error: path validation failed');\n        }\n\n        return (boolean) $status;\n    }\n\n    /**\n     * Sets the path for the current URI, and returns the old path\n     *\n     * @param  string $path The HTTP path\n     * @throws Zend_Uri_Exception When $path is not a valid HTTP path\n     * @return string\n     */\n    public function setPath($path)\n    {\n        if ($this->validatePath($path) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"Path \\\"$path\\\" is not a valid HTTP path\");\n        }\n\n        $oldPath     = $this->_path;\n        $this->_path = $path;\n\n        return $oldPath;\n    }\n\n    /**\n     * Returns the query portion of the URL (after ?), or FALSE if none.\n     *\n     * @return string\n     */\n    public function getQuery()\n    {\n        return strlen($this->_query) > 0 ? $this->_query : false;\n    }\n\n    /**\n     * Returns the query portion of the URL (after ?) as a\n     * key-value-array. If the query is empty an empty array\n     * is returned\n     *\n     * @return array\n     */\n    public function getQueryAsArray()\n    {\n        $query = $this->getQuery();\n        $querryArray = array();\n        if ($query !== false) {\n            parse_str($query, $querryArray);\n        }\n        return $querryArray;\n    }\n\n    /**\n     * Returns true if and only if the query string passes validation. If no query is passed,\n     * then the query string contained in the instance variable is used.\n     *\n     * @param  string $query The query to validate\n     * @throws Zend_Uri_Exception When query validation fails\n     * @return boolean\n     * @link   http://www.faqs.org/rfcs/rfc2396.html\n     */\n    public function validateQuery($query = null)\n    {\n        if ($query === null) {\n            $query = $this->_query;\n        }\n\n        // If query is empty, it is considered to be valid\n        if (strlen($query) === 0) {\n            return true;\n        }\n\n        // Determine whether the query is well-formed\n        $pattern = '/^' . $this->_regex['uric'] . '*$/';\n        $status  = @preg_match($pattern, $query);\n        if ($status === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Internal error: query validation failed');\n        }\n\n        return $status == 1;\n    }\n\n    /**\n     * Add or replace params in the query string for the current URI, and\n     * return the old query.\n     *\n     * @param  array $queryParams\n     * @return string Old query string\n     */\n    public function addReplaceQueryParameters(array $queryParams)\n    {\n        $queryParams = array_merge($this->getQueryAsArray(), $queryParams);\n        return $this->setQuery($queryParams);\n    }\n\n    /**\n     * Remove params in the query string for the current URI, and\n     * return the old query.\n     *\n     * @param  array $queryParamKeys\n     * @return string Old query string\n     */\n    public function removeQueryParameters(array $queryParamKeys)\n    {\n        $queryParams = array_diff_key($this->getQueryAsArray(), array_fill_keys($queryParamKeys, 0));\n        return $this->setQuery($queryParams);\n    }\n\n    /**\n     * Set the query string for the current URI, and return the old query\n     * string This method accepts both strings and arrays.\n     *\n     * @param  string|array $query The query string or array\n     * @throws Zend_Uri_Exception When $query is not a valid query string\n     * @return string              Old query string\n     */\n    public function setQuery($query)\n    {\n        $oldQuery = $this->_query;\n\n        // If query is empty, set an empty string\n        if (empty($query) === true) {\n            $this->_query = '';\n            return $oldQuery;\n        }\n\n        // If query is an array, make a string out of it\n        if (is_array($query) === true) {\n            $query = http_build_query($query, '', '&');\n        } else {\n            // If it is a string, make sure it is valid. If not parse and encode it\n            $query = (string) $query;\n            if ($this->validateQuery($query) === false) {\n                parse_str($query, $queryArray);\n                $query = http_build_query($queryArray, '', '&');\n            }\n        }\n\n        // Make sure the query is valid, and set it\n        if ($this->validateQuery($query) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"'$query' is not a valid query string\");\n        }\n\n        $this->_query = $query;\n\n        return $oldQuery;\n    }\n\n    /**\n     * Returns the fragment portion of the URL (after #), or FALSE if none.\n     *\n     * @return string|false\n     */\n    public function getFragment()\n    {\n        return strlen($this->_fragment) > 0 ? $this->_fragment : false;\n    }\n\n    /**\n     * Returns true if and only if the fragment passes validation. If no fragment is passed,\n     * then the fragment contained in the instance variable is used.\n     *\n     * @param  string $fragment Fragment of an URI\n     * @throws Zend_Uri_Exception When fragment validation fails\n     * @return boolean\n     * @link   http://www.faqs.org/rfcs/rfc2396.html\n     */\n    public function validateFragment($fragment = null)\n    {\n        if ($fragment === null) {\n            $fragment = $this->_fragment;\n        }\n\n        // If fragment is empty, it is considered to be valid\n        if (strlen($fragment) === 0) {\n            return true;\n        }\n\n        // Determine whether the fragment is well-formed\n        $pattern = '/^' . $this->_regex['uric'] . '*$/';\n        $status  = @preg_match($pattern, $fragment);\n        if ($status === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception('Internal error: fragment validation failed');\n        }\n\n        return (boolean) $status;\n    }\n\n    /**\n     * Sets the fragment for the current URI, and returns the old fragment\n     *\n     * @param  string $fragment Fragment of the current URI\n     * @throws Zend_Uri_Exception When $fragment is not a valid HTTP fragment\n     * @return string\n     */\n    public function setFragment($fragment)\n    {\n        if ($this->validateFragment($fragment) === false) {\n            require_once 'Zend/Uri/Exception.php';\n            throw new Zend_Uri_Exception(\"Fragment \\\"$fragment\\\" is not a valid HTTP fragment\");\n        }\n\n        $oldFragment     = $this->_fragment;\n        $this->_fragment = $fragment;\n\n        return $oldFragment;\n    }\n}\n"
}