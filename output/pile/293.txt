{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 8 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "293",
    "text": "/***************************************************************************/\n/*                                                                         */\n/*  ftcsbits.c                                                             */\n/*                                                                         */\n/*    FreeType sbits manager (body).                                       */\n/*                                                                         */\n/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2009 by             */\n/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */\n/*                                                                         */\n/*  This file is part of the FreeType project, and may only be used,       */\n/*  modified, and distributed under the terms of the FreeType project      */\n/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */\n/*  this file you indicate that you have read the license and              */\n/*  understand and accept it fully.                                        */\n/*                                                                         */\n/***************************************************************************/\n\n\n#include <ft2build.h>\n#include FT_CACHE_H\n#include \"ftcsbits.h\"\n#include FT_INTERNAL_OBJECTS_H\n#include FT_INTERNAL_DEBUG_H\n#include FT_ERRORS_H\n\n#include \"ftccback.h\"\n#include \"ftcerror.h\"\n\n#undef  FT_COMPONENT\n#define FT_COMPONENT  trace_cache\n\n\n  /*************************************************************************/\n  /*************************************************************************/\n  /*****                                                               *****/\n  /*****                     SBIT CACHE NODES                          *****/\n  /*****                                                               *****/\n  /*************************************************************************/\n  /*************************************************************************/\n\n\n  static FT_Error\n  ftc_sbit_copy_bitmap( FTC_SBit    sbit,\n                        FT_Bitmap*  bitmap,\n                        FT_Memory   memory )\n  {\n    FT_Error  error;\n    FT_Int    pitch = bitmap->pitch;\n    FT_ULong  size;\n\n\n    if ( pitch < 0 )\n      pitch = -pitch;\n\n    size = (FT_ULong)( pitch * bitmap->rows );\n\n    if ( !FT_ALLOC( sbit->buffer, size ) )\n      FT_MEM_COPY( sbit->buffer, bitmap->buffer, size );\n\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( void )\n  ftc_snode_free( FTC_Node   ftcsnode,\n                  FTC_Cache  cache )\n  {\n    FTC_SNode  snode  = (FTC_SNode)ftcsnode;\n    FTC_SBit   sbit   = snode->sbits;\n    FT_UInt    count  = snode->count;\n    FT_Memory  memory = cache->memory;\n\n\n    for ( ; count > 0; sbit++, count-- )\n      FT_FREE( sbit->buffer );\n\n    FTC_GNode_Done( FTC_GNODE( snode ), cache );\n\n    FT_FREE( snode );\n  }\n\n\n  FT_LOCAL_DEF( void )\n  FTC_SNode_Free( FTC_SNode  snode,\n                  FTC_Cache  cache )\n  {\n    ftc_snode_free( FTC_NODE( snode ), cache );\n  }\n\n\n  /*\n   *  This function tries to load a small bitmap within a given FTC_SNode.\n   *  Note that it returns a non-zero error code _only_ in the case of\n   *  out-of-memory condition.  For all other errors (e.g., corresponding\n   *  to a bad font file), this function will mark the sbit as `unavailable'\n   *  and return a value of 0.\n   *\n   *  You should also read the comment within the @ftc_snode_compare\n   *  function below to see how out-of-memory is handled during a lookup.\n   */\n  static FT_Error\n  ftc_snode_load( FTC_SNode    snode,\n                  FTC_Manager  manager,\n                  FT_UInt      gindex,\n                  FT_ULong    *asize )\n  {\n    FT_Error          error;\n    FTC_GNode         gnode  = FTC_GNODE( snode );\n    FTC_Family        family = gnode->family;\n    FT_Memory         memory = manager->memory;\n    FT_Face           face;\n    FTC_SBit          sbit;\n    FTC_SFamilyClass  clazz;\n\n\n    if ( (FT_UInt)(gindex - gnode->gindex) >= snode->count )\n    {\n      FT_ERROR(( \"ftc_snode_load: invalid glyph index\" ));\n      return FTC_Err_Invalid_Argument;\n    }\n\n    sbit  = snode->sbits + ( gindex - gnode->gindex );\n    clazz = (FTC_SFamilyClass)family->clazz;\n\n    sbit->buffer = 0;\n\n    error = clazz->family_load_glyph( family, gindex, manager, &face );\n    if ( error )\n      goto BadGlyph;\n\n    {\n      FT_Int        temp;\n      FT_GlyphSlot  slot   = face->glyph;\n      FT_Bitmap*    bitmap = &slot->bitmap;\n      FT_Pos        xadvance, yadvance; /* FT_GlyphSlot->advance.{x|y} */\n\n\n      if ( slot->format != FT_GLYPH_FORMAT_BITMAP )\n      {\n        FT_TRACE0(( \"ftc_snode_load:\"\n                    \" glyph loaded didn't return a bitmap\\n\" ));\n        goto BadGlyph;\n      }\n\n      /* Check that our values fit into 8-bit containers!       */\n      /* If this is not the case, our bitmap is too large       */\n      /* and we will leave it as `missing' with sbit.buffer = 0 */\n\n#define CHECK_CHAR( d )  ( temp = (FT_Char)d, temp == d )\n#define CHECK_BYTE( d )  ( temp = (FT_Byte)d, temp == d )\n\n      /* horizontal advance in pixels */\n      xadvance = ( slot->advance.x + 32 ) >> 6;\n      yadvance = ( slot->advance.y + 32 ) >> 6;\n\n      if ( !CHECK_BYTE( bitmap->rows  )     ||\n           !CHECK_BYTE( bitmap->width )     ||\n           !CHECK_CHAR( bitmap->pitch )     ||\n           !CHECK_CHAR( slot->bitmap_left ) ||\n           !CHECK_CHAR( slot->bitmap_top  ) ||\n           !CHECK_CHAR( xadvance )          ||\n           !CHECK_CHAR( yadvance )          )\n        goto BadGlyph;\n\n      sbit->width     = (FT_Byte)bitmap->width;\n      sbit->height    = (FT_Byte)bitmap->rows;\n      sbit->pitch     = (FT_Char)bitmap->pitch;\n      sbit->left      = (FT_Char)slot->bitmap_left;\n      sbit->top       = (FT_Char)slot->bitmap_top;\n      sbit->xadvance  = (FT_Char)xadvance;\n      sbit->yadvance  = (FT_Char)yadvance;\n      sbit->format    = (FT_Byte)bitmap->pixel_mode;\n      sbit->max_grays = (FT_Byte)(bitmap->num_grays - 1);\n\n      /* copy the bitmap into a new buffer -- ignore error */\n      error = ftc_sbit_copy_bitmap( sbit, bitmap, memory );\n\n      /* now, compute size */\n      if ( asize )\n        *asize = FT_ABS( sbit->pitch ) * sbit->height;\n\n    } /* glyph loading successful */\n\n    /* ignore the errors that might have occurred --   */\n    /* we mark unloaded glyphs with `sbit.buffer == 0' */\n    /* and `width == 255', `height == 0'               */\n    /*                                                 */\n    if ( error && error != FTC_Err_Out_Of_Memory )\n    {\n    BadGlyph:\n      sbit->width  = 255;\n      sbit->height = 0;\n      sbit->buffer = NULL;\n      error        = 0;\n      if ( asize )\n        *asize = 0;\n    }\n\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Error )\n  FTC_SNode_New( FTC_SNode  *psnode,\n                 FTC_GQuery  gquery,\n                 FTC_Cache   cache )\n  {\n    FT_Memory   memory = cache->memory;\n    FT_Error    error;\n    FTC_SNode   snode  = NULL;\n    FT_UInt     gindex = gquery->gindex;\n    FTC_Family  family = gquery->family;\n\n    FTC_SFamilyClass  clazz = FTC_CACHE__SFAMILY_CLASS( cache );\n    FT_UInt           total;\n\n\n    total = clazz->family_get_count( family, cache->manager );\n    if ( total == 0 || gindex >= total )\n    {\n      error = FT_Err_Invalid_Argument;\n      goto Exit;\n    }\n\n    if ( !FT_NEW( snode ) )\n    {\n      FT_UInt  count, start;\n\n\n      start = gindex - ( gindex % FTC_SBIT_ITEMS_PER_NODE );\n      count = total - start;\n      if ( count > FTC_SBIT_ITEMS_PER_NODE )\n        count = FTC_SBIT_ITEMS_PER_NODE;\n\n      FTC_GNode_Init( FTC_GNODE( snode ), start, family );\n\n      snode->count = count;\n\n      error = ftc_snode_load( snode,\n                              cache->manager,\n                              gindex,\n                              NULL );\n      if ( error )\n      {\n        FTC_SNode_Free( snode, cache );\n        snode = NULL;\n      }\n    }\n\n  Exit:\n    *psnode = snode;\n    return error;\n  }\n\n\n  FT_LOCAL_DEF( FT_Error )\n  ftc_snode_new( FTC_Node   *ftcpsnode,\n                 FT_Pointer  ftcgquery,\n                 FTC_Cache   cache )\n  {\n    FTC_SNode  *psnode = (FTC_SNode*)ftcpsnode;\n    FTC_GQuery  gquery = (FTC_GQuery)ftcgquery;\n\n\n    return FTC_SNode_New( psnode, gquery, cache );\n  }\n\n\n  FT_LOCAL_DEF( FT_Offset )\n  ftc_snode_weight( FTC_Node   ftcsnode,\n                    FTC_Cache  cache )\n  {\n    FTC_SNode  snode = (FTC_SNode)ftcsnode;\n    FT_UInt    count = snode->count;\n    FTC_SBit   sbit  = snode->sbits;\n    FT_Int     pitch;\n    FT_Offset  size;\n\n    FT_UNUSED( cache );\n\n\n    FT_ASSERT( snode->count <= FTC_SBIT_ITEMS_PER_NODE );\n\n    /* the node itself */\n    size = sizeof ( *snode );\n\n    for ( ; count > 0; count--, sbit++ )\n    {\n      if ( sbit->buffer )\n      {\n        pitch = sbit->pitch;\n        if ( pitch < 0 )\n          pitch = -pitch;\n\n        /* add the size of a given glyph image */\n        size += pitch * sbit->height;\n      }\n    }\n\n    return size;\n  }\n\n\n#if 0\n\n  FT_LOCAL_DEF( FT_Offset )\n  FTC_SNode_Weight( FTC_SNode  snode )\n  {\n    return ftc_snode_weight( FTC_NODE( snode ), NULL );\n  }\n\n#endif /* 0 */\n\n\n  FT_LOCAL_DEF( FT_Bool )\n  ftc_snode_compare( FTC_Node    ftcsnode,\n                     FT_Pointer  ftcgquery,\n                     FTC_Cache   cache )\n  {\n    FTC_SNode   snode  = (FTC_SNode)ftcsnode;\n    FTC_GQuery  gquery = (FTC_GQuery)ftcgquery;\n    FTC_GNode   gnode  = FTC_GNODE( snode );\n    FT_UInt     gindex = gquery->gindex;\n    FT_Bool     result;\n\n\n    result = FT_BOOL( gnode->family == gquery->family                    &&\n                      (FT_UInt)( gindex - gnode->gindex ) < snode->count );\n    if ( result )\n    {\n      /* check if we need to load the glyph bitmap now */\n      FTC_SBit  sbit = snode->sbits + ( gindex - gnode->gindex );\n\n\n      /*\n       *  The following code illustrates what to do when you want to\n       *  perform operations that may fail within a lookup function.\n       *\n       *  Here, we want to load a small bitmap on-demand; we thus\n       *  need to call the `ftc_snode_load' function which may return\n       *  a non-zero error code only when we are out of memory (OOM).\n       *\n       *  The correct thing to do is to use @FTC_CACHE_TRYLOOP and\n       *  @FTC_CACHE_TRYLOOP_END in order to implement a retry loop\n       *  that is capable of flushing the cache incrementally when\n       *  an OOM errors occur.\n       *\n       *  However, we need to `lock' the node before this operation to\n       *  prevent it from being flushed within the loop.\n       *\n       *  When we exit the loop, we unlock the node, then check the `error'\n       *  variable.  If it is non-zero, this means that the cache was\n       *  completely flushed and that no usable memory was found to load\n       *  the bitmap.\n       *\n       *  We then prefer to return a value of 0 (i.e., NO MATCH).  This\n       *  ensures that the caller will try to allocate a new node.\n       *  This operation consequently _fail_ and the lookup function\n       *  returns the appropriate OOM error code.\n       *\n       *  Note that `buffer == NULL && width == 255' is a hack used to\n       *  tag `unavailable' bitmaps in the array.  We should never try\n       *  to load these.\n       *\n       */\n\n      if ( sbit->buffer == NULL && sbit->width != 255 )\n      {\n        FT_ULong  size;\n        FT_Error  error;\n\n\n        ftcsnode->ref_count++;  /* lock node to prevent flushing */\n                                /* in retry loop                 */\n\n        FTC_CACHE_TRYLOOP( cache )\n        {\n          error = ftc_snode_load( snode, cache->manager, gindex, &size );\n        }\n        FTC_CACHE_TRYLOOP_END();\n\n        ftcsnode->ref_count--;  /* unlock the node */\n\n        if ( error )\n          result = 0;\n        else\n          cache->manager->cur_weight += size;\n      }\n    }\n\n    return result;\n  }\n\n\n  FT_LOCAL_DEF( FT_Bool )\n  FTC_SNode_Compare( FTC_SNode   snode,\n                     FTC_GQuery  gquery,\n                     FTC_Cache   cache )\n  {\n    return ftc_snode_compare( FTC_NODE( snode ), gquery, cache );\n  }\n\n\n/* END */\n"
}