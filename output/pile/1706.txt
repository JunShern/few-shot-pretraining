{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "1706",
    "text": "Q:\n\nUsing combineLatest with UITextFields in RAC 3+\n\nI would like to simply \"combine\" the signals emitted by a number of textfields and fire a block of code. It seems there are a few ways this \"should\" work using methods like combineLatest() or the values: SignalProducer initializer.  But I am not able to get anything to compile or function as expected.\nRAC documentations uses the following example\ncombineLatest(numbersSignal, lettersSignal)\n  |> observe(next: println, completed: { println(\"Completed\") })\n\nBut I am not able to compile this kind of usage\nI am able to do the following with redundant blocks...\nlocationTextfield.rac_textSignal().toSignalProducer()\n  |> start(next: { txt in\n    println(txt)\n  })\n\naircraftTextfield.rac_textSignal().toSignalProducer()\n  |>  start(next: { txt in\n    println(txt)\n  })\n\nI also am not understanding why I need to use toSignalProducer() and start rather than just observing the rac_textsignal itself.  This \"compiles\" but nothing seems to be sent on the signal unless a producer is created and started.\nThis question/answer ReactiveCocoa combine SignalProducers into one also works, but still seems like a work around, and doesn't explain why signal producers need to be created rather than observing the original rac_textSignal()s\n\nA:\n\nObserving rac_textSignal without transformations is possible, we just need to clarify that rac_textSignal is RACSignal. RACSignal is the ReactiveCocoa 2.0 signal and is related to the Objective-C version. So you need to apply RAC2 operators to such signals, combineLatestWith: could help you to solve such task.\nTransformations are necessary to apply Swift operators due to diff in the basic concept in RAC3. In RAC2 such core entity was RACSignal, against Signal and SignalProducer in the RAC3.\n\n"
}