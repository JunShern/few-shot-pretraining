{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": true,
            "reason": "Text contains ['SAT']."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['-', '-', '-', '-', '-', '-', '1', '2', '1', '1', '2', '-', '-', '-', '-', '1', '2', '3', '-', '-', '-', '-', '-', '1', '2', '-', '-', '-', '-', '-', '*', '1', '2', '*', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['Some well-known examples of such ${{\\\\Sigma}_{2}^{P}}$-complete problems are the following ones, which will be further detailed in Section\\xa0\\\\[sec:applications\\\\]: (0.167)', 'Note that the meta-interpreters available are normal logic programs (including arbitrary negation), and can not be used for our purposes for the reasons explained above. (0.192)', 'The steps of the transformation cast the various conditions there into rules of $\\\\Pi_{meta}$, and also provide auxiliary machinery which is needed for this aim. (0.188)', 'Guessing a strategic set, and checking its minimality can be done by the following two programs, where we adopt the constraint in [@cado-etal-97] that each product is produced by at most two companies and each company is jointly controlled by at most three other companies. (0.176)', 'While the ad hoc encodings from [@eite-etal-2000c; @leon-etal-2002-dlv], which can also be found in \\\\[app:adhoc-sc\\\\], are not immediate (and require some thought), the above programs are very natural and easy to come up with. (0.200)', 'However, in our opinion, none of these ad hoc encodings is obvious at first sight compared with the separate guess and check programs shown above. (0.191)', 'The results in Tables\\xa0\\\\[tab:SC\\\\]-\\\\[tab:BIT\\\\] show that the \u201cguess and saturate\u201d strategy in our approach benefits a lot from optimizations for all problems considered. (0.189)', 'Some preliminary experimental results suggest that a structural analysis of the given guess and check program might be valuable for this purpose. (0.196)', 'A further issue are alternative transformations, which are possibly tailored for certain classes of programs. (0.180)', 'Howewer, this succinct encoding relies very much on the fixed number of producing and controlling companies; an extension to arbitrarily many producers and controllers seems not to be as easy as in our separate guess and check programs from Section\\xa0\\\\[sec:strategic\\\\]. (0.200)']."
        }
    ],
    "doc_id": "2221",
    "text": "---\nauthor:\n- Thomas Eiter\n- Axel Polleres\ndate: January 2004\ntitle: |\n    Towards Automated Integration\\\n    of Guess and Check Programs\\\n    in Answer Set Programming:\\\n    A Meta-Interpreter and Applications\n---\n\nIntroduction\n============\n\nAnswer set programming (ASP) [@asp-2001; @gelf-lifs-91; @lifs-2002; @mare-trus-99; @niem-99], also called A-Prolog [@bald-gelf-2003; @bara-2002; @gelf-2002], is widely proposed as a useful tool for solving problems in a declarative manner, by encoding the solutions to a problem in the answer sets of a normal logic program. By well-known complexity results, in this way all problems with complexity in ${\\mathrm{NP}}$ can be expressed and solved [@schl-95; @mare-remm-2003]; see also [@dant-etal-01].\n\nA frequently considered example of an ${\\mathrm{NP}}$-complete problem which can be elegantly solved in ASP is Graph-3-Colorability, i.e., deciding whether some given graph $G$ is 3-colorable. It is an easy exercise in ASP to write a program which determines whether a graph is 3-colorable. A straightforward encoding, following the \u201cGuess and Check\u201d [@eite-etal-2000c; @leon-etal-2002-dlv] respectively \u201cGenerate/Define/Test\u201d approach [@lifs-2002], consists of two parts:\n\n-   A \u201cguessing\u201d part, which assigns nondeterministically each node of the graph one of three colors:\n\n    > $\\mathtt{col(red,X)\\ {\\mbox{\\texttt{v}\\xspace}}\\ col(green,X)\\ {\\mbox{\\texttt{v}\\xspace}}\\ col(blue,X)\\ {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ node(X).}$\n\n-   and a \u201cchecking\u201d part, which tests whether no adjacent nodes have the same color:\n\n    > $\\mathtt{{\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}edge(X,Y),\\ col(C,X),\\ col(C,Y).}$\n\nHere, the graph $G$ is represented by a set of facts `node(x)` and `edge(x,y)`. Each legal 3-coloring of $G$ is a polynomial-size \u201cproof\u201d of its 3-colorability, and such a given proof can be validated in polynomial time. Furthermore, the answer sets of this program yield all legal 3-colorings of the graph $G$.\n\nHowever, we might encounter situations in which we want to express a problem which is complementary to some ${\\mathrm{NP}}$ problem, and thus belongs to the class ${\\textrm{co-}{\\mathrm{NP}}}$. It is widely believed that in general, not all problems in ${\\textrm{co-}{\\mathrm{NP}}}$ are in ${\\mathrm{NP}}$, and hence that it is not always the case that a polynomial-size \u201cproof\u201d of a ${\\textrm{co-}{\\mathrm{NP}}}$ property $P$ exists which can be verified in polynomial time. For such problems, we thus can not write a (polynomial-size propositional) normal logic program in ASP which guesses and verifies in its answer sets possible \u201cproofs\u201d of $P$. One such property, for instance, is the ${\\textrm{co-}{\\mathrm{NP}}}$-complete property that a given graph is [*not*]{} 3-colorable. However, this and similar properties $P$ can be dually expressed in ASP in terms of whether a normal logic program (equivalently, a head-cycle free disjunctive logic program [@bene-dech-94]) $\\Pi_P$ has no answer set if and only if the property $p$ holds.\n\nProperties that are ${\\textrm{co-}{\\mathrm{NP}}}$-complete often occur within the context of problems that reside in the class ${{\\Sigma}_{2}^{P}}$, which is above ${\\mathrm{NP}}$ in the polynomial time hierarchy\u00a0[@papa-94]. In particular, the solutions of a ${{\\Sigma}_{2}^{P}}$-complete problem can be typically singled out from given candidate solutions by testing a ${\\textrm{co-}{\\mathrm{NP}}}$-complete property. Some well-known examples of such ${{\\Sigma}_{2}^{P}}$-complete problems are the following ones, which will be further detailed in Section\u00a0\\[sec:applications\\]:\n\nQuantified Boolean Formulas:\n\n:   Evaluating a Quantified Boolean formula (QBF) of the form $\\exists X\\forall Y\\Phi(X,Y)$, where $\\Phi(X,Y)$ is a disjunctive normal form over propositional variables $X\\cup Y$. Here, a solution is a truth value assignment $\\sigma$ to the variables $X$ such that the formula $\\forall Y\\Phi(\\sigma(X),Y)$ evaluates to true, i.e., $\\Phi(\\sigma(X),Y)$ is a tautology. Given a candidate solution $\\sigma$, the ${\\textrm{co-}{\\mathrm{NP}}}$-complete property to check here is whether $\\Phi(\\sigma(X),Y)$ is a tautology.\n\nStrategic Companies:\n\n:   Computing strategic companies sets [@eite-etal-2000c; @leon-etal-2002-dlv]. Roughly, here the problem is to compute, given a set of companies $C$ in a holding, a minimal subset $S \\subseteq C$ which satisfies some constraints concerning the production of goods and control of companies. Any such set is called strategic; Given a candidate solution $S$ which satisfies the constraints, the ${\\textrm{co-}{\\mathrm{NP}}}$-complete property to check here is the minimality, i.e., that no set $S' \\subset S$ exists which also satisfies the constraints.\n\nConformant Planning:\n\n:   Computing conformant plans under incomplete information and nondeterministic action effects. Here the problem is to generate from a description of the initial state $I$, the planning goal $G$, and the actions $\\alpha$ and their effects a sequence of actions (a plan) $P = \\alpha_1,\\ldots,\\alpha_n$ which carries the agent from the initial state to a goal-fulfilling state under all contingencies, i.e., regardless of the precise initial state and how non-deterministic actions work out. Given a candidate solution in terms of an [*optimistic*]{} plan $P$, which works under [ *some*]{} execution [@eite-etal-2001e], the property to check is whether it works under [*all* ]{} executions, i.e., whether it is conformant [@gold-bodd-96]. The latter problem is in ${\\textrm{co-}{\\mathrm{NP}}}$, provided that executability of actions is polynomially decidable, cf.\u00a0[@eite-etal-2001e; @turn-2002].\n\nThis list can be extended, and further examples can be found, e.g., in [@eite-etal-97f; @eite-etal-2002-tplp; @grec-etal-2001; @saka-inou-2003].\n\nThe problems described above can be solved using ASP in a two-step approach as follows:\n\n1.  Generate a candidate solution $S$ by means of a logic program $\\Pi_{guess}$.\n\n2.  Check the solution $S$ by \u201crunning\u201d another logic program $\\Pi_{check}$ (=$\\Pi_p$) on $S$, such that $\\Pi_{check}\\cup S$ has no answer set if and only if $S$ is a valid solution.\n\nThe respective programs $\\Pi_{check}$ can be easily formulated (cf.Section\u00a0\\[sec:applications\\]).\n\nOn the other hand, ASP with disjunction, i.e.\u00a0full extended disjunctive logic programming, allows one to formulate problems in ${{\\Sigma}_{2}^{P}}$ in a [*single*]{} (disjunctive) program, since this formalism captures the complexity class ${{\\Sigma}_{2}^{P}}$, cf.[@dant-etal-01; @eite-etal-97f]. Hence, efficient ASP engines such as [`DLV`]{}\u00a0[@leon-etal-2002-dlv] or [[GnT]{}]{}\u00a0[@janh-etal-2000] can be used to solve such programs directly in a one-step approach.\n\nA difficulty here is that sometimes, an encoding of a problem in a single logic program (e.g., for the conformant planning problem above) may not be easy to find. This raises the issue whether there exists an (effective) possibility to [*combine*]{} separate $\\Pi_{guess}$ and $\\Pi_{check}$ programs into a single program $\\Pi_{solve}$, such that this unified program computes the same set of solutions as the two-step process outlined above. A potential benefit of such a combination is that the space of candidate solutions might be reduced in the evaluation due to its interaction with the checking part. Furthermore, automated program optimization techniques may be applied which consider both the guess and check part as well as the interactions between them. This is not possible for separate programs.\n\nThe naive attempt of taking the union $\\Pi_{guess} \\cup \\Pi_{check}$ unsurprisingly fails: indeed, each desired answer set of $\\Pi_{guess}$ would be eliminated by $\\Pi_{check}$ (assuming that, in a hierarchical fashion, $\\Pi_{check}$ has no rules defining atoms from $\\Pi_{guess}$). Therefore, some program transformation is necessary. A natural question here is whether it is possible to rewrite $\\Pi_{check}$ to some other program $\\Pi'_{check}$ such that an integrated logic program $\\Pi_{solve} = \\Pi_{guess} \\cup \\Pi'_{check}$ is feasible, and, moreover, whether this can be done automatically.\n\nFrom theoretical complexity results about disjunctive logic programs cf.\u00a0[@dant-etal-01; @eite-etal-97f], one can infer that the program $\\Pi'_{check}$ should be truly disjunctive in general, i.e., not rewritable to an equivalent non-disjunctive program in polynomial time. This and further considerations (see Section\u00a0\\[sec:trans\\]) provide some evidence that a suitable rewriting of $\\Pi_{check}$ to $\\Pi'_{check}$ is not immediate.\n\nIn this paper, we therefore address this issue and present a generic method for constructing the program $\\Pi_{check}'$ by using a meta-interpreter approach. In particular, we make the following contributions:\n\nWe provide a transformation ${\\ensuremath{tr}\\xspace}(\\Pi)$ from propositional head-cycle-free [@bene-dech-94] (extended) disjunctive logic programs (HDLPs) $\\Pi$ to disjunctive logic programs (DLPs), which enjoys the properties that the answer sets of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ encode the answer sets of $\\Pi$, if $\\Pi$ has some answer set, and that ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ has a canonical answer set otherwise which is easy to recognize. The transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ is polynomial and modular in the sense of [@janh-2000], and employs meta-interpretation of $\\Pi$.\n\nFurthermore, we describe variants and modifications of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ aiming at optimization of the transformation. In particular, we present a transformation to positive DLPs, and show that in a precise sense, modular transformations to such programs do not exist.\n\nWe show how to use ${\\ensuremath{tr}\\xspace}(\\cdot)$ for integrating separate guess and check programs $\\Pi_{guess}$ and $\\Pi_{check}$, respectively, into a single DLP $\\Pi_{solve}$ such that the answer sets of $\\Pi_{solve}$ yield the solutions of the overall problem.\n\nWe demonstrate the method on the examples of QBFs, the Strategic Companies problem, and conformant planning [@gold-bodd-96] under fixed polynomial plan length (cf.\u00a0[@eite-etal-2001e; @turn-2002]). Our method proves useful to loosen some restrictions of previous encodings, and to obtain disjunctive encodings for more general problem classes.\n\nWe compare our approach on integrating separate guess and check programs experimentally against existing ad hoc encodings for QBFs and Strategic Companies and also applying it to conformant planning, where no such ad hoc encodings were known previously. For these experiments, we use [`DLV`]{}\u00a0[@leon-etal-2002-dlv], a state-of-the-art Answer Set engine for solving DLPs. The results which we obtained reveal interesting aspects: While as intuitively expected, efficient ad hoc encodings have better performance than the synthesized integrated encodings in general, there are also cases where the performances scale similarly (i.e., the synthesized encoding is within a constant factor), or where even ad hoc encodings from the literature are outperformed.\n\nOur results contribute to further the \u201cGuess and Check\u201d resp.\u201cGenerate/Define/ Test\u201d paradigms for ASP, and fill a gap by providing an automated construction for integrating guess and check programs. They relieve the user from the burden to use sophisticated techniques such as saturation, as employed e.g.\u00a0in [@eite-etal-97f; @eite-etal-2000c; @leon-etal-2001], in order to overcome the technical intricacies in combining natural guess and check parts into a single program. Furthermore, our results complement recent results about meta-interpretation techniques in ASP, cf.[@mare-remm-2003; @delg-etal-01; @eite-etal-2002a].\n\nThe rest of this paper is organized a follows. In the next section, we very briefly recall the necessary concepts and fix notation. After that, we present in Section\u00a0\\[sec:trans\\] our transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ of a \u201cchecking\u201d program $\\Pi$ into a disjunctive logic program. We start there with making the informal desirable properties described above more precise, present the constituents of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$, the factual program representation $F(\\Pi)$ and a meta-interpreter $\\Pi_{meta}$, and prove that our transformation satisfies the desirable properties. Section\u00a0\\[sec:optimizations\\] thereafter is devoted to modifications towards optimization. In Section\u00a0\\[sec:integration\\], we show how to synthesize separate guess and check programs to integrated encodings. Several applications are considered in Section\u00a0\\[sec:applications\\], and experimental results for these are reported in Section\u00a0\\[sec:experiments\\]. The final Section\u00a0\\[sec:conclusion\\] gives a summary and presents issues for further research.\n\nPreliminaries {#sec:prelim}\n=============\n\nWe assume that the reader is familiar with logic programming and answer set semantics, see [@gelf-lifs-91; @asp-2001], and only briefly recall the necessary concepts.\n\nA *literal* is an atom $a(t_1, \\ldots,t_n)$, or its negation ${\\ensuremath{\\neg}}{a(t_1, \\ldots,t_n)}$, where \u201c[$\\neg$]{}\u201d is the strong negation symbol, for which we also use the customary \u201c\u2013\u201d, in a function-free first-order language (including at least one constant), which is customarily given by the programs considered. We write $|a| = |{\\ensuremath{\\neg}}{a}| = a$ to denote the atom of a literal.\n\nExtended disjunctive logic programs (EDLPs; or simply programs) are disjunctive logic programs with default (weak) and strong negation, i.e., finite sets $\\Pi$ of rules $r$ $$\\label{stmt:lprule}\nh_1 {\\mbox{\\texttt{v}\\xspace}}\\ \\ldots\\ {\\mbox{\\texttt{v}\\xspace}}\\ h_l\\ {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ b_1,\\ \\ldots,\\ b_m,\\\n{\\ensuremath{\\mathtt{not}\\ }b_{m+1}},\\ \\ldots\\ {\\ensuremath{\\mathtt{not}\\ }b_n}.$$ $l,m,n \\geq 0$, where each $h_i$ and $b_j$ is a literal and is weak negation (negation as failure). By ${\\ensuremath{H(r)}} =\n\\{h_1, \\ldots, h_l\\}$, ${\\ensuremath{B^+(r)}} = \\{b_1,\\ldots, b_m\\}$, ${\\ensuremath{B^-(r)}} = \\{b_{m+1},\\ldots, b_n\\}$, and ${\\ensuremath{B(r)}} = {\\ensuremath{B^+(r)}}\n\\cup {\\ensuremath{B^-(r)}}$ we denote the head and (positive, resp.negative) body of rule $r$. Rules with $|{\\ensuremath{H(r)}}|{=}1$ and ${\\ensuremath{B(r)}}{=}\\emptyset$ are called *facts* and rules with ${\\ensuremath{H(r)}}{=}\\emptyset$ are called *constraints*. For convenience, we omit \u201cextended\u201d in what follows and refer to EDLPs as DLPs etc.\n\nLiterals (resp.\u00a0rules, programs) are *ground* if they are variable-free. Non-ground rules (resp.\u00a0programs) amount to their *ground instantiation*, i.e.,\u00a0all rules obtained by substituting variables with constants from the (implicit) language.\n\nRules (resp.\u00a0programs) are *positive*, if \u201c${\\ensuremath{\\mathtt{not}}\\xspace}$\u201d does not occur in them, and *normal*, if $|{\\ensuremath{H(r)}}| \\leq\n1$. A ground program $\\Pi$ is *head-cycle free* [@bene-dech-94], if no literals $l\\neq l'$ occurring in the same rule head mutually depend on each other by positive recursion; $\\Pi$ is stratified [@przy-89b; @przy-91], if no literal $l$ depends by recursion through negation on itself (counting disjunction as positive recursion).\n\nThe [*answer set semantics*]{}\u00a0[@gelf-lifs-91] for DLPs is as follows. Denote by $Lit(\\Pi)$ the set of all ground literals for a program $\\Pi$. Consider first positive (ground) programs $\\Pi$. Let $S\n\\subseteq Lit(\\Pi)$ be a set of consistent literals. Such a set $S$ satisfies a positive rule $r$, if ${\\ensuremath{H(r)}} \\cap S \\not= \\emptyset$ whenever ${\\ensuremath{B^+(r)}} \\subseteq S$. An *answer set* for $\\Pi$ then is a minimal (under $\\subseteq$) set $S$ satisfying all rules.[^1] To extend this definition to programs with weak negation, the *reduct* $\\Pi^S$ of a program $\\Pi$ with respect to a set of literals $S$ is the set of rules $$h_1\\ {\\mbox{\\texttt{v}\\xspace}}\\ \\ldots\\ {\\mbox{\\texttt{v}\\xspace}}\\ h_l\\ {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ b_1,\\ \\ldots,\\ b_m$$ for all rules (\\[stmt:lprule\\]) in $\\Pi$ such that $S \\cap {\\ensuremath{B^-(r)}} = \\emptyset$. Then $S$ is an [*answer set*]{} of $\\Pi$, if $S$ is an answer set for $\\Pi^S$.\n\nThere is a rich literature on characterizations of answer sets of DLPs and restricted fragments; for our concerns, we recall here the following characterization of (consistent) answer sets for HDLPs, given by Ben-Eliyahu and Dechter\u00a0[-@bene-dech-94]:\n\n\\[theo:hedlp\\] Given a ground HDLP $\\Pi$, a consistent $S \\subseteq Lit(\\Pi)$ is an answer set iff\n\n1.  $S$ satisfies each rule in $\\Pi$, and\n\n2.  there is a function $\\phi: Lit(\\Pi) \\mapsto \\Nat$ such that for each literal $l$ in $S$ there is a rule $r$ in $\\Pi$ with\n\n    1.  ${\\ensuremath{B^+(r)}} \\subseteq S$\n\n    2.  ${\\ensuremath{B^-(r)}} \\cap S = \\emptyset$\n\n    3.  $l \\in {\\ensuremath{H(r)}}$\n\n    4.  $S \\cap ({\\ensuremath{H(r)}}\\setminus \\{l\\}) = \\emptyset$\n\n    5.  $\\phi(l') < \\phi(l)$ for each $l' \\in {\\ensuremath{B^+(r)}}$\n\nWe will use Theorem\u00a0\\[theo:hedlp\\] as a basis for the transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ in the next section.\n\nMeta-Interpreter Transformation {#sec:trans}\n===============================\n\nAs discussed in the Introduction, rewriting a given check program $\\Pi_{check}$ to a program $\\Pi_{check}'$ for integration with a separate guess program $\\Pi_{guess}$ into a single program $\\Pi_{solve} = \\Pi_{guess}\\cup \\Pi'_{check}$ can be difficult in general. The problem is that the working of the answer set semantics, to be emulated in $\\Pi_{check}'$, is not easy to express there.\n\nOne difficulty is that for a given answer set $S$ of $\\Pi_{guess}$, we have to test the [*non-existence*]{} of an answer set of $\\Pi_{check}$ with respect to $S$, while $\\Pi_{solve}$ [*should have an answer set*]{} extending $S$ to $\\Pi'_{check}$ if the check succeeds. A possibility to work around this problem is to design $\\Pi'_{check}$ in a way such that it has a dummy answer set with respect to $S$ if the check of $\\Pi_{check}$ on $S$ succeeds, and no answer set if the check fails, i.e., if $\\Pi_{check}$ has some answer set on $S$. While this may not look to be very difficult, the following observations suggest that this is not straightforward.\n\nSince $\\Pi_{solve}$ may need to solve a ${{\\Sigma}_{2}^{P}}$-complete problem, any suitable program $\\Pi'_{check}$ must be truly disjunctive in general, i.e., contain disjunctions which are not head-cycle free (assuming that no head literal in $\\Pi'_{check}$ occurs in $\\Pi_{guess}$). Indeed, if both $\\Pi_{guess}$ and $\\Pi'_{check}$ are head-cycle free, then also $\\Pi_{solve} = \\Pi_{guess} \\cup \\Pi'_{check}$ is head-cycle free, and thus can only express a problem in ${\\mathrm{NP}}$.\n\nFurthermore, we can make in $\\Pi_{check}'$ only limited use of default negation on atoms which do not occur in $\\Pi_{guess}$. The reason is that upon a \u201cguess\u201d $S$ for an answer set of $\\Pi_{solve} =\n\\Pi_{guess} \\cup \\Pi_{check}'$, the reduct $\\Pi_{solve}^S$ is ${\\ensuremath{\\mathtt{not}}\\xspace}$-free. Contrary to the case of $\\Pi_{check}$ in the two-step approach, it is not possibile to explicitly consider for a guess $S_{guess}$ of an answer set of $\\Pi_{guess}$ varying extensions $S =\nS_{guess}\\cup S'_{check}$ to the whole program $\\Pi_{solve}$ which activate different rules in $\\Pi'_{check}$ (e.g.,\u00a0unstratified clauses $a {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}{\\ensuremath{\\mathtt{not}}\\xspace}\\,b$ and $b{\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}{\\ensuremath{\\mathtt{not}}\\xspace}\\, a$ encoding a choice among $a$ and $b$). Therefore, default negation in rules of $\\Pi_{check}$ must be handled with care and might cause major rewriting as well.\n\nThese observations provide some evidence that a rule-rewriting approach for obtaining $\\Pi'_{check}$ from $\\Pi_{check}$ may be complicated. For this reason, we adopt at a generic level a Meta-interpreter approach, in which the ${\\textrm{co-}{\\mathrm{NP}}}$-check modeled by $\\Pi_{check}$ is \u201cemulated\u201d by a minimality check for a positive DLP $\\Pi_{check}'$.\n\nBasic approach\n--------------\n\nThe considerations above lead us to an approach in which the program $\\Pi_{check}'$ is constructed by the use of meta-interpretation techniques [@mare-remm-2003; @delg-etal-01; @eite-etal-2002a]. The idea behind meta-interpretation is here that a program $\\Pi$ is represented by a set of facts, $F(\\Pi)$, which is input to a fixed program $\\Pi_{meta}$, the meta-interpreter, such that the answer sets of $\\Pi_{meta} \\cup F(\\Pi)$ correspond to the answer sets of $\\Pi$. Note that the meta-interpreters available are normal logic programs (including arbitrary negation), and can not be used for our purposes for the reasons explained above. We thus have to construct a novel meta-interpreter which is essentially ${\\ensuremath{\\mathtt{not}}\\xspace}$-free, i.e.\u00a0uses negation as failure only in a restricted way, and contains disjunction.\n\nBasically, we present a general approach to translate normal LPs and HDLPs into stratified disjunctive logic programs. To this end, we exploit Theorem\u00a0\\[theo:hedlp\\] as a basis for a transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ from a given HDLP $\\Pi$ to a DLP ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace} =\nF(\\Pi) \\cup \\Pi_{meta}$ such that ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ fulfills the properties mentioned in the introduction. More precisely, it will satisfy the following properties:\n\nT0\n\n:   ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ is computable in time polynomial in the size of $\\Pi$.\n\nT1\n\n:   Each answer set $S'$ of the transformed program ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ corresponds to an answer set $S$ of $\\Pi$, such that $S = \\{ l \\mid \\texttt{inS}(l) \\in S'\\}$ for some predicate `inS(\\cdot)`, provided $\\Pi$ is consistent, and conversely, each answer set $S$ of $\\Pi$ corresponds to some answer set $S'$ of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ such that $S = \\{ l \\mid \\texttt{inS}(l) \\in S'\\}$.\n\nT2\n\n:   If the program $\\Pi$ has no answer set, then ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ has exactly one designated answer set $\\Omega$, which is easily recognizable.\n\nT3\n\n:   The transformation is of the form ${\\ensuremath{tr}\\xspace}(\\Pi) = F(\\Pi) \\cup\n      \\Pi_{meta}$, where $F(\\Pi)$ is a factual representation of $\\Pi$ and $\\Pi_{meta}$ is a fixed meta-interpreter.\n\nT4\n\n:   ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ is [*modular*]{} (at the syntactic level), i.e., ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace} = \\bigcup_{r\\in \\Pi} {\\ensuremath{{\\ensuremath{tr}\\xspace}(r)}\\xspace}$ holds. Moreover, ${\\ensuremath{tr}\\xspace}(\\Pi)$ returns a stratified DLP [@przy-89b; @przy-91] which uses negation only in its \u201cdeterministic\u201d part.\n\nNote that properties [**T0**]{} \u2013 [**T4**]{} for ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\cdot)}\\xspace}$ are similar yet different from the notion of polynomial faithful modular (PFM) transformation by Janhunen\u00a0[-@janh-2000; -@janh-2001], which is a function $Tr$ mapping a class of logic programs $\\cal C$ to another class $\\cal C'$ of logic programs (where $\\cal C'$ is assumed to be a subclass or superclass of $\\cal C$), such that the following three conditions hold: (1) For each program $\\Pi\\in {\\cal C}$, $Tr(\\Pi)$ is computable in polynomial time in the size of $\\Pi$ (called [*polynomiality*]{}), (2) the Herbrand base of $\\Pi$, ${\\ensuremath{\\mathit H\\!b}\\xspace}(\\Pi)$, is included in the Herbrand base of $Tr(\\Pi)$, ${\\ensuremath{\\mathit H\\!b}\\xspace}(Tr(\\Pi))$ and the models/interpretations of $\\Pi$ and $Tr(\\Pi)$, are in one-to-one correspondence and coincide up to ${\\ensuremath{\\mathit H\\!b}\\xspace}(\\Pi)$ ([*faithfulness*]{}), and (3) $Tr(\\Pi_1\\cup \\Pi_2)$ = $Tr(\\Pi_1)\\cup Tr(\\Pi_2)$ for all programs $\\Pi_1,\\Pi_1$ in ${\\cal C}$ and ${\\cal C}'\\subseteq {\\cal C}$ implies $Tr(\\Pi)=\\Pi$ for all $\\Pi$ in ${\\cal C}'$ ([*modularity*]{}).\n\nCompared to PFM, also our transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\cdot)}\\xspace}$ is polynomially computable by [**T0**]{} and hence satisfies condition 1). Moreover, by [**T4**]{} and the fact that stratified disjunctive programs are not necessarily head-cycle free, it also satisfies condition 3). However, condition 2) fails. Its first part, that ${\\ensuremath{\\mathit H\\!b}\\xspace}(\\Pi) \\subseteq {\\ensuremath{\\mathit H\\!b}\\xspace}({\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace})$ and that answer sets coincide on $Lit(\\Pi)$ could be fulfilled by adding rules $l\\ {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ \\texttt{inS}(l)$ for every $l \\in Lit(\\Pi)$); these polynomially many rules could be added during input generation. The second part of condition 2) is clearly in contradiction with [**T2**]{}, since for $\\Omega$ never a corresponding answer set of $\\Pi$ exists. Moreover, condition [**T1**]{} is a weaker condition than the one-to-one correspondence between the answer sets of $\\Pi$ and ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ required for faithfulness: In fact, in case $\\Pi$ has positive cycles, there might be several possible guesses for $\\phi$ for an answer set $S$ of $\\Pi$ in Theorem\u00a0\\[theo:hedlp\\] reflected by different answer sets of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$. We illustrate this by a short example:\n\nLet $\\Pi$ be the program consisting of the following four rules:\n\n\u00a0\u00a0\u00a0\u00a0a\u00a0\u00a0b. \u00a0b\u00a0\u00a0a. \u00a0a. \u00a0b.\n\nThen, $\\Pi$ has a single answer set $S = {\\ensuremath{\\{{\\ensuremath{\\mathtt{a,b}}}\\}}}$, while ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ has two answer sets such that $S_1 = {\\ensuremath{\\{{\\ensuremath{\\mathtt{inS(a),inS(b), phi(a,b), \\ldots}}}\\}}}$ and $S_2 = {\\ensuremath{\\{{\\ensuremath{\\mathtt{inS(a),inS(b), phi(b,a), \\ldots}}}\\}}}$, intuitively reflecting that here the order of applications of rules $r1$ and $r2$ does not matter, although they are cyclic.\n\nWe remind that the different properties of our transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\cdot)}\\xspace}$ and PFM transformations is not an accident but a necessary feature, since we want to express nonexistence of certain answer sets via the transformation, and not merely preserve the exact semantics as targeted by PFM. Apart from this different objective, the other properties involved (polynomiality and modularity) are in effect the same.\n\nInput representation $F(\\Pi)$ {#sec:transinput}\n-----------------------------\n\nAs input for our meta-interpreter $\\Pi_{meta}$, which will be introduced in the next subsection, we choose the representation $F(\\Pi)$ of the propositional program $\\Pi$ defined below. We assume that each rule $r$ has a unique name $n(r)$; for convenience, we identify $r$ with $n(r)$.\n\nLet $\\Pi$ be any ground (propositional) HDLP. The set $F(\\Pi)$ consists of the facts\n\nXXX= `lit(h,l,r).\u00a0\u00a0atom(l,|l|).` = for each literal $l$ $\\in {\\ensuremath{H(r)}}$,\\\n`lit(p,l,r).` for each literal $l \\in {\\ensuremath{B^+(r)}}$,\\\n`lit(n,l,r).` for each literal $l \\in {\\ensuremath{B^-(r)}}$,\n\nfor every rule $r \\in \\Pi$.\n\nWhile the facts for predicate `lit` obviously encode the rules of $\\Pi$, the facts for predicate `atom` indicate whether a literal is classically positive or negative. We only need this information for head literals; this will be further explained below.\n\nMeta-Interpreter $\\Pi_{meta}$ {#sec:transmeta}\n-----------------------------\n\nWe construct our meta-interpreter program $\\Pi_{meta}$, which in essence is a positive disjunctive program, in a sequence of several steps. They center around checking whether a guess for an answer set $S \\subseteq Lit(\\Pi)$, encoded by a predicate `inS(\\cdot)`, is an answer set of $\\Pi$ by testing the criteria of Theorem\u00a0\\[theo:hedlp\\]. The steps of the transformation cast the various conditions there into rules of $\\Pi_{meta}$, and also provide auxiliary machinery which is needed for this aim.\n\n#### Step 1\n\nWe add the following preprocessing rules:\n\n: \u00a0\u00a0\u00a0rule(L,R) lit(h,L,R), not lit(p,L,R), not lit(n,L,R).\\\n\n: ruleBefore(L,R) rule(L,R), rule(L,R1), R1 &lt; R.\\\n\n: ruleAfter(L,R) rule(L,R), rule(L,R1), R &lt; R1.\\\n\n: ruleBetween(L,R1,R2) rule(L,R1), rule(L,R2), rule(L,R3),\\\nR1 &lt; R3, R3 &lt; R2.\\\n\n: firstRule(L,R) rule(L,R), [$\\mathtt{not}\\ $ruleBefore(L,R)]{}.\\\n\n: lastRule(L,R) rule(L,R), [$\\mathtt{not}\\ $ruleAfter(L,R)]{}.\\\n\n: nextRule(L,R1,R2) rule(L,R1), rule(L,R2), R1 &lt; R2,\\\n[$\\mathtt{not}\\ $ruleBetween(L,R1,R2)]{}.\\\n\n: before(HPN,L,R) lit(HPN,L,R), lit(HPN,L1,R), L1 &lt; L.\\\n\n: after(HPN,L,R) lit(HPN,L,R), lit(HPN,L1,R), L &lt; L1.\\\n\n: between(HPN,L,L2,R) lit(HPN,L,R), lit(HPN,L1,R),\\\nlit(HPN,L2,R), L&lt;L1, L1&lt;L2.\\\n\n: next(HPN,L,L1,R) lit(HPN,L,R), lit(HPN,L1,R), L &lt; L1,\\\n[$\\mathtt{not}\\ $between(HPN,L,L1,R)]{}.\\\n\n: first(HPN,L,R) lit(HPN,L,R), [$\\mathtt{not}\\ $before(HPN,L,R)]{}.\\\n\n: last(HPN,L,R) lit(HPN,L,R), [$\\mathtt{not}\\ $after(HPN,L,R)]{}.\\\n\n: hlit(L) rule(L,R).\n\nLines 1 to 7 fix an enumeration of the rules in $\\Pi$ from which a literal $l$ may be derived, assuming a given order `<` on rule names (e.g.\u00a0in [`DLV`]{}, built-in lexicographic order; `<` can also be easily generated using guessing rules). Note that under answer set semantics, we need only to consider rules where the literal $l$ to prove does not occur in the body.\n\nLines 8 to 13 fix enumerations of ${\\ensuremath{H(r)}}$, ${\\ensuremath{B^+(r)}}$ and ${\\ensuremath{B^-(r)}}$ for each rule. The final line 14 collects all literals that can be derived from rule heads. Note that the rules on lines 1-14 plus $F(\\Pi)$ form a stratified program, which has a single answer set, cf.\u00a0[@przy-89b; @przy-91].\n\n#### Step 2\n\nNext, we add rules which \u201cguess\u201d a candidate answer set $S \\subseteq Lit(\\Pi)$ and a total ordering `phi` on $S$ corresponding with the function $\\phi$ in condition $2$ of Theorem\u00a0\\[theo:hedlp\\]. We will explain this correspondence in more detail below (cf.\u00a0proof of Theorem\u00a0\\[theo:corr\\]).\n\n: \u00a0\u00a0\u00a0\u012bnS(L) \u00a0ninS(L) hlit(L).\\\n\n: ninS(L) lit($pn$,L,R), [$\\mathtt{not}\\ $hlit(L)]{}. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\\n\n: \u00a0\u00a0\u00a0notok inS(L), inS(NL), L[$\\mathtt{\\,!\\!\\!=}\\,$]{}NL, atom(L,A), atom(NL,A).\\\n\n: phi(L,L1) \u00a0phi(L1,L) inS(L), inS(L1), L &lt; L1.\\\n\n: phi(L,L2) :- phi(L,L1),phi(L1,L2).\n\nLine\u00a015 focuses the guess of $S$ to literals occurring in some relevant rule head in $\\Pi$; only these can belong to an answer set $S$, but no others (line\u00a016). Line\u00a017 then checks whether $S$ is consistent, deriving a new distinct atom `notok` otherwise. Line\u00a018 guesses a strict total order `phi` on `inS` where line\u00a019 guarantees transitivity; note that minimality of answer sets prevents that `phi` is cyclic, i.e., that `phi(L,L)` holds.\n\nIn the subsequent steps, we will check whether $S$ and `phi` violate the conditions of Theorem\u00a0\\[theo:hedlp\\] by deriving the distinct atom `notok` (considered in Step\u00a05 below) in case, indicating that $S$ is not an answer set or `phi` does not represent a proper function $\\phi$.\n\n#### Step 3\n\nCorresponding to condition $1$ in Theorem\u00a0\\[theo:hedlp\\], `notok` is derived whenever there is an unsatisfied rule by the following program part:\n\n:\u00a0\u00a0\u00a0\u0101llInSUpto(p,Min,R) inS(Min), first(p,Min,R).\\\n\n: allInSUpto(p,L1,R) \u012bnS(L1), allInSUpto(p,L,R), next(p,L,L1,R).\\\n\n: allInS(p,R) allInSUpto(p,Max,R),last(p,Max,R).\n\n$\\left.\\mbox{\\begin{minipage}{0.9\\textwidth}\n\\begin{tabbing}\n{\\addtocounter{bctr}{1}\\thebctr}:\\ \\ \\ \\=allNinSUpto($hn$,Min,R) {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}ninS(Min), first($hn$,Min,R).\\\\[0.33ex]\n{\\addtocounter{bctr}{1}\\thebctr}: \\>allNinSUpto($hn$,L1,R) {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\=ninS(L1), allNinSUpto($hn$,L,R),\\\\ \\>\\>next($hn$,L,L1,R).\\\\[0.33ex]\n{\\addtocounter{bctr}{1}\\thebctr}: \\>allNinS($hn$,R) {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}allNinSUpto($hn$,Max,R), last($hn$,Max,R).\n\\end{tabbing}\n\\end{minipage}\n\\hspace{-1ex}}\\right\\}$\n\n:\u00a0\u00a0\u00a0hasHead(R) lit(h,L,R).\\\n\n: hasPBody(R) lit(p,L,R).\\\n\n: hasNBody(R) lit(n,L,R).\\\n\n: allNinS(h,R) lit(HPN,L,R), [$\\mathtt{not}\\ $hasHead(R)]{}.\\\n\n: allInS(p,R) lit(HPN,L,R), [$\\mathtt{not}\\ $hasPBody(R)]{}.\\\n\n: allNinS(n,R) lit(HPN,L,R), [$\\mathtt{not}\\ $hasNBody(R)]{}.\\\n\n: notok allNinS(h,R), allInS(p,R), allNinS(n,R), lit(HPN,L,R).\n\nThese rules compute by iteration over ${\\ensuremath{B^+(r)}}$ (resp.\u00a0${\\ensuremath{H(r)}}$, ${\\ensuremath{B^-(r)}}$) for each rule $r$, whether for all positive body (resp.\u00a0head and default negated body) literals in rule $r$ `inS` holds (resp.\u00a0`ninS` holds) (lines 20 to 25). Here, empty heads (resp. bodies) are interpreted as unsatisfied (resp.\u00a0satisfied), cf.\u00a0lines 26 to 31. The final rule 32 fires exactly if one of the original rules from $\\Pi$ is unsatisfied.\n\n#### Step 4\n\nWe derive `notok` whenever there is a literal $l\\in S$ which is not provable by any rule $r$ with respect to `phi`. This corresponds to checking condition $2$ from Theorem\u00a0\\[theo:hedlp\\].\n\n:\u00a0\u00a0\u00a0failsToProve(L,R) rule(L,R), lit(p,L1,R), ninS(L1).\\\n\n: failsToProve(L,R) rule(L,R), lit(n,L1,R), inS(L1).\\\n\n: failsToProve(L,R) rule(L,R), rule(L1,R), inS(L1), L1[$\\mathtt{\\,!\\!\\!=}\\,$]{}L, inS(L).\\\n\n: failsToProve(L,R) rule(L,R), lit(p,L1,R), phi(L1,L).\\\n\n: allFailUpto(L,R) failsToProve(L,R), firstRule(L,R).\\\n\n: allFailUpto(L,R1) failsToProve(L,R1), allFailUpto(L,R),\\\nnextRule(L,R,R1).\\\n\n: notok allFailUpto(L,R), lastRule(L,R), inS(L).\n\nLines 33 and 34 check whether condition $2.(a)$ or $(b)$ are violated, i.e.\u00a0some rule can only prove a literal if its body is satisfied. Condition $2.(d)$ is checked in line\u00a035, i.e. $r$ fails to prove $l$ if there is some $l'\\neq l$ such that $l' \\in {\\ensuremath{H(r)}}\\cap S$. Violations of condition $2.(e)$ are checked in line 36. Finally, lines 37 to 39 derive `notok` if all rules fail to prove some literal $l\\in S$. This is checked by iterating over all rules with $l\\in {\\ensuremath{H(r)}}$ using the order from Step\u00a01. Thus, condition $2.(c)$ is implicitly checked by this iteration.\n\n#### Step 5\n\nWhenever `notok` is derived, indicating a wrong guess, then we apply a saturation technique as in [@eite-etal-97f; @eite-etal-2000c; @leon-etal-2001] to some other predicates, such that a canonical set $\\Omega$ results. This set turns out to be an answer set iff no guess for $S$ and $\\phi$ works out, i.e., $\\Pi$ has no answer set. In particular, we saturate the predicates `inS`, `ninS`, and `phi` by the following rules:\n\n:\u00a0\u00a0\u00a0= phi(L,L1)\u00a0=notok, hlit(L), hlit(L1).\\\n\n: inS(L) notok, hlit(L).\\\n\n: ninS(L) notok, hlit(L).\n\nIntuitively, by these rules, any answer set containing `notok` is \u201cblown up\u201d to an answer set $\\Omega$ containing all possible guesses for `inS`, `ninS`, and `phi`.\n\nThe program $\\Pi_{meta}$ consists of the rule 1\u201342 from above.\n\nWe then can formally define our transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ as follows.\n\nGiven any ground HDLP $\\Pi$, its transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ is given by the DLP ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}= F(\\Pi) \\cup \\Pi_{meta}$.\n\nExamples of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ will be provided in Section\u00a0\\[sec:applications\\].\n\nProperties of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$\n-------------------------------------------------------------------\n\nWe now show that ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ satisfies indeed the properties [**T0**]{} \u2013 [**T4**]{} from the beginning of this section.\n\nAs for [**T0**]{}, we note the following proposition, which is not difficult to establish.\n\n\\[prop:poly\\] Given $\\Pi$, the transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ and its ground instantiation are both computable in logarithmic workspace (and thus in polynomial time).\n\nThe input representation $F(\\Pi)$ is easily generated in a linear scan of $\\Pi$, using the rule numbers as names, for which a counter (representable in logspace) is sufficient. The meta-interpreter part $\\Pi_{meta}$ is fixed anyway. A naive grounding of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ can be constructed by instantiating each rule $r$ from $\\Pi_{meta}$ with constants from $\\Pi$ and rule ids in all possible ways; for each variable `X` in $r$, all constants of $\\Pi$ can be systematically considered, using counters to mark the start and end position in $\\Pi$ (viewed as a string), and the rule ids by a rule number counter. A constant number of such counters is sufficient. Thus, the grounding of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ is constructible in logarithmic work space. Notice that intelligent, efficient grounding methods such as those used in [`DLV`]{}[@leon-etal-2002-dlv] usually generate a smaller ground program than this naive ground instantiation.\n\nClearly, ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ satisfies property [**T3**]{}, and as easily checked, ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ is modular. Moreover, strong negation does not occur in ${\\ensuremath{tr}\\xspace}(\\Pi)$ and weak negation only stratified. The latter is not applied to literals depending on disjunction; it thus occurs only in the deterministic part of ${\\ensuremath{tr}\\xspace}(\\Pi)$, which means [**T4**]{} holds.\n\nTo establish [**T1**]{} and [**T2**]{}, we define the literal set $\\Omega$ as follows:\n\nLet $\\Pi_{meta}^i$ be the set of rules in $\\Pi_{meta}$ established in Step\u00a0$i \\in \\{1,\\ldots,5\\}$. For any program $\\Pi$, let $\\Pi_{\\Omega} = F(\\Pi) \\cup \\bigcup_{i\\in \\{1,3,4,5\\}}\\Pi_{meta}^i \\cup {\\ensuremath{\\{\\texttt{notok}.\\}}}$. Then, $\\Omega$ is defined as the answer set of $\\Pi_{\\Omega}$.\n\n$\\Omega$ is well-defined and uniquely determined by $\\Pi$.\n\n(Sketch) This follows immediately from the fact that $\\Pi_{\\Omega}$ is a (locally) stratified normal logic program without ${\\ensuremath{\\neg}}{}$ and constraints, which as well-known has a single answer set.\n\n\\[theo:corr\\] For a given HDLP $\\Pi$ the following holds for ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$:\n\n1.  ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ always has some answer set, and $S' \\subseteq\n            \\Omega$ for every answer set $S'$ of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$.\n\n2.  $S$ is an answer set of $\\Pi$ $\\Leftrightarrow$ there exists an answer set $S'$ of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ such that $S={\\ensuremath{\\{ l \\mid \\mathtt{inS(\\mbox{$l$})} \\in S'\\}}}$ and $\\texttt{notok} \\not\\in S'$.\n\n3.  $\\Pi$ has no answer set $\\Leftrightarrow$ ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ has the unique answer set $\\Omega$.\n\n$1.$\u00a0The first part follows immediately from the fact that ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ has no constraints, no strong negation, and weak negation is stratified; this guarantees the existence of at least one answer set $S$ of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$\u00a0[@przy-91]. Moreover, $S'\\subseteq\\Omega$ must hold for every answer set: after removing $\\{\\texttt{notok.}\\}$ from $\\Pi_{\\Omega}$ and adding $\\Pi_{meta}^{2}$, we obtain ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$. Note that any rule in $\\Pi_{meta}^{2}$ fires with respect to $S'$ only if all literals in its head are in $\\Omega$, and `inS`, `ninS`, and `phi` are elsewhere not referenced recursively through negation or disjunction. Therefore, increasing $S'$ locally to the value of $\\Omega$ on `inS`, `ninS`, `phi`, and `notok`, and closing off thus increases it globally to $\\Omega$, which means $S'\n\\subseteq \\Omega$.\n\n$2.$\u00a0($\\Rightarrow$)\u00a0 Assume that $S$ is an answer set of $\\Pi$. Clearly, then $S$ is a consistent set of literals which has a corresponding set $S''= {\\ensuremath{\\{ \\texttt{inS}(l) \\mid l \\in S\\}}}$ $\\cup$ ${\\ensuremath{\\{\\texttt{ninS}(l) \\mid l \\in Lit(\\Pi)\\setminus S\\}}}$ being one possible guess by the rules in lines 15 to 17 of $\\Pi_{meta}$. Let now $\\phi: Lit(\\Pi) \\rightarrow \\Nat$ be the function from Theorem\u00a0\\[theo:hedlp\\] for answer set $S$: Without loss of generality, we may assume two restrictions on this function $\\phi$:\n\n-   $\\phi(l) = 0$ for all $l\\in Lit(\\Pi)\\setminus S$ and $\\phi(l) >\n    0$ for all $l\\in S$.\n\n-   $\\phi(l)\\neq\\phi(l')$ for all $l,l' \\in S$.\n\nThen, the function $\\phi$ can be mapped to a total order over $S$ `phi` such that $$\\mathtt{phi(\\mbox{$l,l'$})} \\Leftrightarrow \\phi(l) > \\phi(l') > 0.$$ This relation `phi` fixes exactly one possible guess by the lines 18 and 19 of $\\Pi_{meta}$.\n\nNote that it is sufficient to define `phi` only over literals in $S$: Violations of condition $2.(e)$ have only to be checked for rules with ${\\ensuremath{B^+(r)}} \\subseteq S$, as otherwise condition $2.(a)$ already fails. Obviously, condition 2.$(e)$ of Theorem\u00a0\\[theo:hedlp\\] is violated with respect to $\\phi$ iff (a) `phi(Y,X)` holds for some `X` in the head of a rule with `Y` in its positive body or (b) if `X` itself occurs in its positive body. While (a) is checked in lines 36, (b) is implicit by definition of predicate `rule` (line 1) which says that a literal can not prove itself.\n\nGiven $S''$ and `phi` from above, we can now verify by our assumption that $S$ is an answer set and by the conditions of Theorem\u00a0\\[theo:hedlp\\] that (a) `notok` can never be derived in ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ and (b) $S''$ and `phi` uniquely determine an answer set $S'$ of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ of the form we want to prove. This can be argued by construction of Steps 3 and 4 of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$, where `notok` will only be derived if some rule is unsatisfied (Step 3) or there is a literal in $S$ (i.e.\u00a0$S''$) which fails to be proved by all other rules (Step 4). ($\\Leftarrow$)Assume that $S'$ is an answer set of [${\\ensuremath{tr}\\xspace}(\\Pi)$]{} not containing `notok`. Then by the guess of `phi` in Step 5 a function $\\phi: Lit(\\Pi) \\rightarrow \\Nat$ can be constructed by the implied total order of `phi` as follows: We number all literals $l \\in S={\\ensuremath{\\{l \\mid \\mathtt{inS(\\mbox{$l$})} \\in S'\\}}}$ according to that order from $1$ to $|S|$ and fix $\\phi(l)=0$ for all other literals. Again, by construction of Steps 3 to 5 and the assumption that $\\texttt{notok} \\not\\in S'$, we can see that $S$ and the function $\\phi$ constructed fulfill all the conditions of Theorem\u00a0\\[theo:hedlp\\]; in particular, line\u00a017 guarantees consistency. Hence $S$ is an answer set of $\\Pi$.\n\n$3.$\u00a0($\\Leftarrow$)\u00a0 Assume that $\\Pi$ has an answer set. Then, by the already proved Part\u00a02 of the Theorem, we know that there exists an answer set $S'$ of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ such that `notok` $\\not\\in S'$. By minimality of answer sets, $\\Omega$ can not be an answer set of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$.\n\n($\\Rightarrow$)\u00a0 By Part\u00a01 of Theorem\u00a0\\[theo:corr\\], we know that ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ always has an answer set $S' \\subseteq\n        \\Omega$. Assume that there is an answer set $S'\\subsetneqq\\Omega$. We distinguish 2 cases: (a) `notok` $\\not\\in S'$ and (b) `notok` $\\in S'$. In case (a), proving Part\u00a02 of this proposition, we have already shown that $\\Pi$ has an answer set; this is a contradiction. On the other hand, in case (b) the final \u201csaturation\u201d rules in Step 5 \u201cblow up\u201d any answer set containing `notok` to $\\Omega$, which contradicts the assumption $S'\\subsetneqq\\Omega$.\n\nAs noticed above, the transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ uses weak negation only stratified and in a deterministic part of the program; we can easily eliminate it by computing in the transformation the complement of each predicate accessed through ${\\ensuremath{\\mathtt{not}}\\xspace}$ and providing it in $F(\\Pi)$ as facts; we then obtain a positive program. (The built-in predicates `<` and `!=` can be eliminated similarly if desired.) However, such a modified transformation is not modular. As shown next, this is not incidental.\n\n\\[prop:non-modular\\] There is no modular transformation ${\\ensuremath{tr}\\xspace}'(\\Pi)$ from HDLPs to DLPs (i.e.\u00a0such that ${\\ensuremath{tr}\\xspace}'(\\Pi) = \\bigcup_{r \\in \\Pi} {\\ensuremath{tr}\\xspace}'(r)$), satisfying [**T1**]{} such that ${\\ensuremath{tr}\\xspace}'(\\Pi)$ is a positive program.\n\nAssuming such a transformation exists, we derive a contradiction. Let $\\Pi_1 = \\{ \\texttt{ a {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}{\\ensuremath{\\mathtt{not}}\\xspace}b.} \\}$ and $\\Pi_2 = \\Pi_1 \\cup\n\\{ \\texttt{b.} \\}$. Then, ${\\ensuremath{tr}\\xspace}'(\\Pi_2)$ has some answer set $S_2$. Since ${\\ensuremath{tr}\\xspace}'(\\cdot)$ is modular, ${\\ensuremath{tr}\\xspace}'(\\Pi_1) \\subseteq\n{\\ensuremath{tr}\\xspace}'(\\Pi_2)$ holds and thus $S_2$ satisfies each rule in ${\\ensuremath{tr}\\xspace}'(\\Pi_1)$. Since ${\\ensuremath{tr}\\xspace}'(\\Pi_1)$ is a positive program, $S_2$ contains some answer set $S_1$ of ${\\ensuremath{tr}\\xspace}'{\\Pi_1}$. By [ **T1**]{}, we have that `inS(a)` $\\in S_1$ must hold, and hence `inS(a)` $\\in S_2$. By [**T1**]{} again, it follows that $\\Pi_2$ has an answer set $S$ such that $\\texttt{a} \\in S$. But the single answer set of $\\Pi_2$ is $\\{ \\texttt{b} \\}$, which is a contradiction.\n\nWe remark that Prop.\u00a0\\[prop:non-modular\\] remains true if [**T1**]{} is generalized such that the answer set $S$ of $\\Pi$ corresponding to $S'$ is given by $S=\\{l \\mid S'\\models \\Psi(l)\\}$, where $\\Psi(x)$ is a monotone query (e.g., computed by a normal positive program without constraints). Moreover, if a successor predicate `next(X,Y)` and predicates `first(X)` and `last(X)` for the constants are available, given that the universe is finite by the constants in $\\Pi$ and rule names, then computing the negation of the non-input predicates accessed through ${\\ensuremath{\\mathtt{not}}\\xspace}$ is feasible by a positive normal program, since such programs capture polynomial time computability by well-known results on the expressive power of Datalog\u00a0[@papa-85]; thus, negation of input predicates in $F(\\Pi)$ is sufficient in this case.\n\nModifications towards Optimization {#sec:optimizations}\n==================================\n\nThe meta-interpreter $\\Pi_{meta}$ from above can be modified in several respects. We discuss in this section some modifications which, though not necessarily reducing the size of the ground instantiation, intuitively prune the search of an answer set solver applied to ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$.\n\nGiving up modularity (OPT$_{mod}$)\n----------------------------------\n\nIf we sacrifice modularity and allow that $\\Pi_{meta}$ partly depends on the input, then we can circumvent the iterations in Step\u00a03 and in part of Step\u00a01. Intuitively, instead of iterating over the heads and bodies of all rules in order to determine whether these rules are satisfied, we add a single rule in ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ for each rule $r$ in $\\Pi$ firing [$\\mathtt{notok}$]{} whenever $r$ is unsatisfied. We therefore replace the rules from Step\u00a03 by $$\\label{stmt:rulesatisfied}\n\\begin{split}\n\\mathtt{notok\\ {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ }&\\mathtt{ninS(\\mbox{$h_1$}),\\ \\ldots,\\ ninS(\\mbox{$h_l$}),\\\ninS(\\mbox{$b_1$}),\\ \\ldots,\\ inS(\\mbox{$b_m$}),}\\\\\n& \\mathtt{ninS(\\mbox{$b_{m+1}$}),\\ \\ldots\\, ninS(\\mbox{$b_n$}).}\n\\end{split}$$ for each rule $r$ in $\\Pi$ of form (\\[stmt:lprule\\]). These rules can be efficiently generated in parallel to $F(\\Pi)$. Lines 8 to 13 of Step 1 then become unnecessary and can be dropped.\n\nWe can even refine this further. For every normal rule $r \\in \\Pi$ with non-empty head, i.e.${\\ensuremath{H(r)}}={\\ensuremath{\\{h\\}}}$, which has a satisfied body, we can force the guess of $h$: we replace (\\[stmt:rulesatisfied\\]) by $$\\label{stmt:forcenormal}\n\\mathtt{inS(\\mbox{$h$}) {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ inS(\\mbox{$b_1$}),\\ \\ldots,\\ inS(\\mbox{$b_m$}), ninS(\\mbox{$b_{m+1}$}),\\ \\ldots\\ ninS(\\mbox{$b_n$}).}$$\n\nIn this context, since constraints only serve to \u201cdiscard\u201d unwanted models but cannot prove any literal, we can ignore them during input generation $F(\\Pi)$. Note that dropping input representation $\\mathtt{lit(n,\\mbox{$l$},\\mbox{$c$}).}$ for literals only occurring in the negative body of constraints but nowhere else in $\\Pi$ requires some care. Such $l$ can be removed by simple preprocessing, though, by removing all $l \\in {\\ensuremath{B^-(c)}}$ which do not occur in any rule head in $\\Pi$. On the other hand, all literals $l\\in {\\ensuremath{B^-(c)}}$ which appear in some other (non-constraint) rule $r$ are not critical, since facts `lit(hpn,l,r).` ($hpn \\in \\{\\texttt{h,p,n}\\}$) from this other rule will ensure that either line\u00a015 or line\u00a016 in $\\Pi_{meta}$ is applicable and therefore, either `inS(l)` or `ninS(l)` will be derived. Thus, after elimination of critical literals in constraints beforehand, we can safely drop the factual representation of constraints completely (including `lit(n,l,c).` for the remaining negative literals).\n\nRestricting to potentially applicable rules (OPT$_{pa}$)\n--------------------------------------------------------\n\nWe only need to consider literals in heads of [*potentially applicable*]{} rules. These are all rules with empty bodies, and rules where any positive body literal \u2013 recursively \u2013 is the head of another potentially applicable rule. This suggests the following definition:\n\n\\[def:poss\\_app\\] A set $R$ of ground rules is *potentially applicable*, if there exists an enumeration ${\\ensuremath{\\langle}r_i\\ensuremath{\\rangle}}_{i \\in I}$ of $R$, where $I$ is a prefix of $\\Nat$ resp.\u00a0$I{=}\\Nat$, such that ${\\ensuremath{B^+(r_i)}} \\subseteq \\bigcup_{j<i} {\\ensuremath{H(r_j)}}$.\n\nThe following proposition is then not difficult to establish.\n\nLet $\\Pi$ be any ground HDLP. Then there exists a unique maximal set $R^* \\subseteq \\Pi$ of potentially applicable rules, denoted by $\\mathrm{PA}(\\Pi)$.\n\nIndeed, suppose ${\\ensuremath{\\langle}r_i\\ensuremath{\\rangle}}_{i \\in I}$ and ${\\ensuremath{\\langle}r'_i\\ensuremath{\\rangle}}_{i \\in I'}$ are enumerations witnessing that rule sets $R$ and $R'$ such that $R,R'\\subseteq \\Pi$ are potentially applicable. Then their union $R\\cup R'$ is potentially applicable, witnessed by the enumeration obtained from the alternating enumeration $r_0,r'_0,r_1,r'_1$,\u2026whose suffix are the rules from the larger set of $R$ and $R'$ if they have different cardinalities, from which duplicate rules are removed (i.e., remove any rule $r'_j$ if $r'_j=r_i$, for some $i\\leq j$, and remove any rule $r_j$ if $r'_i=r_j$ and for some $i<j$). It follows that a unique largest set $R^* \\subseteq \\Pi$ of potentially applicable rules exists.\n\nThe set $\\mathrm{PA}(\\Pi)$ can be computed by adding a rule:\n\n\u00a0\u00a0 pa($r$) :- lit(h,$b_1$,R$_1$), pa(R$_1$), \u2026, lit(h,$b_m$,R$_m$), pa(R$_m$).\n\nfor any rule $r$ of the form\u00a0(\\[stmt:lprule\\]) in $\\Pi$. In particular, if $m=0$ we simply add the fact `pa(r).` Finally, we change line\u00a01 in $\\Pi_{meta}$ to:\n\n\u00a0\u00a0 rule(L,R) lit(h,L,R), not lit(p,L,R), not lit(n,L,R), pa(R).\n\nsuch that only \u201cinteresting\u201d rules are considered.\n\nWe note, however, that computing `pa(\\cdot)` incurs some cost: Informally, a profit of optimization **OPT$_{pa}$** might only be expected in domains where $\\Pi_{check}$ contains a a reasonable number of rules which positively depend on each other and might on the other hand likely be \u201cswitched off\u201d by particular guesses in $\\Pi_{guess}$.\n\nOptimizing the order guess (OPT$_{dep}$)\n----------------------------------------\n\nWe only need to guess and check the order $\\phi$ for literals $L$, $L'$ if they allow for cyclic dependency, i.e., they appear in the heads of rules within the same strongly connected component of the program with respect to $S$.[^2] These dependencies with respect to $S$ are easily computed:\n\n\u00a0\u00a0 dep(L,L1) lit(h,L,R),lit(p,L1,R),inS(L),inS(L1).\\\ndep(L,L2) lit(h,L,R),lit(p,L1,R),dep(L1,L2),inS(L).\\\ncyclic dep(L,L1),dep(L1,L).\n\nThe guessing rules for $\\phi$ (line 18 and 19) are then be replaced by:\n\n\u00a0\u00a0 phi(L,L1) \u00a0phi(L,L1) dep(L,L1), dep(L1,L), L &lt; L1,cyclic.\\\nphi(L,L2) :- phi(L,L1),phi(L1,L2), cyclic.\n\nMoreover, we add the new atom `cyclic` also to the body of any other rule where `phi` appears (lines 36,40) to check `phi` only in case $\\Pi$ has *any* cyclic dependencies with respect to $S$.\n\nIn the following, we will denote the transformation obtained by the optimizations from this section as ${\\ensuremath{{\\ensuremath{tr}\\xspace}_{Opt}(\\Pi)}\\xspace}$ while we refer to ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ for the original transformation.\n\nIntegrating Guess and ${\\textrm{co-}{\\mathrm{NP}}}$ Check Programs {#sec:integration}\n==================================================================\n\nIn this section, we show how our transformation ${\\ensuremath{tr}\\xspace}$ (resp.${\\ensuremath{tr}\\xspace}_{Opt}$) from above can be used to automatically combine a HDLP $\\Pi_{guess}$ which guesses in its answer sets solutions of a problem, and a HDLP $\\Pi_{check}$ which encodes a ${\\textrm{co-}{\\mathrm{NP}}}$-check of the solution property, into a single DLP $\\Pi_{solve}$ of the form $\\Pi_{solve} =\n\\Pi_{guess} \\cup \\Pi'_{check}$.\n\nWe assume that the set $Lit(\\Pi_{guess})$ is a Splitting Set [@lifs-turn-94] for $\\Pi_{guess} \\cup \\Pi_{check}$, i.e.\u00a0no head literal from $\\Pi_{check}$ occurs in $\\Pi_{guess}$. This can be easily achieved by introducing new predicate names, e.g., $\\texttt{p}'$ for a predicate $\\texttt{p}$, and adding a rule $\\texttt{p}'(t) {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\texttt{p}(t)$ in case there is an overlap.\n\nEach rule $r$ in $\\Pi_{check}$ is of the form $$\\label{eqn:int}\n\\begin{split}\nh_1 {\\mbox{\\texttt{v}\\xspace}}\\ \\cdots\\ {\\mbox{\\texttt{v}\\xspace}}\\ h_l\\ {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ & bc_1,\\ \\ldots,\\ bc_m,\\\n{\\ensuremath{\\mathtt{not}\\ }bc_{m+1}},\\ \\ldots,\\ {\\ensuremath{\\mathtt{not}\\ }bc_n}\\\\\n& bg_1,\\ \\ldots,\\ bg_p,\\\n{\\ensuremath{\\mathtt{not}\\ }bg_{p+1}},\\ \\ldots,\\ {\\ensuremath{\\mathtt{not}\\ }bg_q}.\n\\end{split}$$ where the $bg_i$ are the body literals defined in $\\Pi_{guess}$. We write ${\\sf body}_{guess}(r)$ for $bg_1,\\\n\\ldots,\\ bg_p,\\ {\\ensuremath{\\mathtt{not}\\ }bg_{p+1}},\\ \\ldots,\\ {\\ensuremath{\\mathtt{not}\\ }bg_q}$. We now define a new check program as follows.\n\nFor any ground program $\\Pi_{check}$ as above, the program $\\Pi'_{check}$ contains the following rules and constraints:\n\n:   \\(i) The facts $F(\\Pi_{check})$ in a conditional version: For each rule $r\\in\\Pi_{check}$ of form (\\[eqn:int\\]), the rules\n\n    \u00a0\u00a0\u00a0\u00a0`lit(p,bg_i,r)`= `lit(h,l,r)`$\\!\\!$ '$\\!\\!\\!\\!$[body]{}$_{guess}(r).$ `atom(l,|l|).` \\` for each $l \\in {\\ensuremath{H(r)}}$;\\\n    `lit(p,bc_i,r)`$\\!\\!$ '$\\!\\!\\!\\!$[body]{}$_{guess}(r).$ \\` for each $i \\in \\{1,\\ldots, m\\}$;\\\n    `lit(n,bc_j,r)`$\\!\\!$ '$\\!\\!\\!\\!$[body]{}$_{guess}(r).$ \\` for each $j \\in \\{m+1,\\ldots, n\\}$;\n\n:   \\(ii) each rule in $\\Pi_{meta}{\\,=\\,}{\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi_{check})}\\xspace}\\!\\setminus F(\\Pi_{check})$ (resp.\u00a0in ${\\ensuremath{{\\ensuremath{tr}\\xspace}_{Opt}(\\Pi_{check})}\\xspace}\\!\\setminus\\!F(\\Pi_{check})$, where ${\\sf body}_{guess}(r)$ must be added to the bodies of the rules (\\[stmt:rulesatisfied\\]) and (\\[stmt:forcenormal\\]));\n\n:   \\(iii) a constraint\n\n    \u00a0\u00a0\u00a0=\u00a0[$\\mathtt{not}\\ $notok]{}.\n\n    It eliminates any answer set $S$ such that $\\Pi_{check} \\cup S$ has an answer set.\n\nThe union of $\\Pi_{guess}$ and $\\Pi_{check}'$ then amounts to the desired integrated encoding $\\Pi_{solve}$, which is expressed by the following result.\n\n\\[theo:integrate\\] Given separate guess and check programs $\\Pi_{guess}$ and $\\Pi_{check}$, the answer sets of $$\\Pi_{solve}=\\Pi_{guess}\\cup\\Pi_{check}',$$ denoted $S_{solve}$, are in 1-1 correspondence with the answer sets $S$ of $\\Pi_{guess}$ such that $\\Pi_{check}\\!\\cup\\!S$ has no answer set.\n\nThis result can be derived from Theorem\u00a0\\[theo:corr\\] and the Splitting Set Theorem for logic programs under answer set semantics [@lifs-turn-94]. We consider the proof for the original transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\cdot)}\\xspace}$; the proof for the optimized transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}_{Opt}(\\cdot)}\\xspace}$ is similar (with suitable extensions in places). In what follows, for any program $Q$ and any consistent literal set $S$, we let $Q[S]$ denote the program obtained from $Q$ by eliminating every rule $r$ such that ${\\sf body}_{guess}(r)$ is false in $S$, and by removing ${\\sf body}_{guess}(r)$ from the remaining rules. Notice that $\\Pi_{check}\\cup S$ and $\\Pi_{check}[S]\\cup S$ have the same answer sets.\n\nWe can rewrite $\\Pi_{solve}$ as $$\\Pi_{solve} = \\Pi_{guess} \\cup F'(\\Pi_{check}) \\cup \\Pi_{meta} \\cup\n\\{\\,{\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ {\\ensuremath{\\mathtt{not}\\ }\\texttt{notok}}.\\,\\}$$ where $F'(\\Pi_{check})$ denotes the modified factual representation for $\\Pi_{check}$, given in item $1.$ of the definition of $\\Pi'_{check}$. By hypothesis on $\\Pi_{guess}\\cup \\Pi_{check}$, the set $Lit(\\Pi_{guess})$ is a splitting set for $\\Pi_{solve}$. Hence, as easily seen also $Lit(\\Pi_{guess} \\cup F'(\\Pi_{check}))$ is a splitting set for $\\Pi_{solve}$, and $Lit(\\Pi_{guess})$ is also a splitting set for $\\Pi_{guess} \\cup F'(\\Pi_{check})$. Moreover, each answer set $S$ of $\\Pi_{guess}$ is in 1-1 correspondence with an answer set $S'$ of $\\Pi_{guess} \\cup F'(\\Pi_{check})$. Then $S'\n\\setminus S = F(\\Pi_{check}[S]) \\cup A_S$, such that $F(\\Pi_{check}[S])$ is the factual representation of $\\Pi_{check}[S]$ in the transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi_{check}[S])}\\xspace}$ and $A_S = {\\ensuremath{\\{\\texttt{atom}(l,|l|). \\mid l \\in\n{\\ensuremath{H(\\Pi_{check})}}\\setminus {\\ensuremath{H(\\Pi_{check}[S])}}\\}}}$[^3] is an additional set of facts emerging from $F'(\\Pi_{check})$, since we added facts `atom`$(l,|l|)$. for all head literals of $r \\in \\Pi_{check}$, not only for those $r$ where ${\\sf body}_{guess}(r)$ was satisfied.\n\nNow let $S_{solve}$ be any (consistent) answer set of $\\Pi_{solve}$. From the Splitting Set Theorem [@lifs-turn-94], we can conclude that $S_{solve}$ can be written as $S_{solve} =\nS \\cup S_{check} \\cup A_S$ where $S$ and $S_{check} \\cup A_S$ are disjoint, $S$ is an answer set of $\\Pi_{guess}$, and $S_{check} \\cup A_S$ is an answer set of the program $\\Pi'_S = (\\Pi_{solve} \\setminus\n\\Pi_{guess})[S]$. Since $F'(\\Pi_{check})$ is the only part of $\\Pi_{solve} \\setminus \\Pi_{guess}$ where literals from $Lit(\\Pi_{guess})$ occur, we obtain $$\\begin{aligned}\n\\Pi'_S &=&  F(\\Pi_{check}[S]) \\cup A_S \\cup \\Pi_{meta} \\cup \\{{\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\\n{\\ensuremath{\\mathtt{not}\\ }\\texttt{notok}}.\\}\\\\       &=& {\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi_{check}[S])}\\xspace} \\cup A_S \\cup \\{{\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\\n{\\ensuremath{\\mathtt{not}\\ }\\texttt{notok}}.\\}.\\end{aligned}$$ The additional facts $A_S$ can be viewed as independent part of any answer set of $\\Pi'_S$, since the answer sets of $\\Pi'_S$ are the sets $T \\cup A_S$ where $T$ is any answer set of $\\Pi'_S \\setminus A_S$; note that $T\\cap A_S = \\emptyset$. Indeed, the only rule in $\\Pi'_S$ where the facts of $A_S$ play a role, is line 17 of $\\Pi_{meta}$. All ground instances of line 17 are of the following form: $$\\texttt{\\ \\ \\ notok {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}inS(l), inS(nl), l{\\ensuremath{\\mathtt{\\,!\\!\\!=}\\,}}nl,\natom(l,|l|), atom(nl,|l|).}$$ We assume $r$ fires and $\\texttt{atom(l,|l|)} \\in A_S$ (resp.\u00a0$\\texttt{atom(nl,|l|} \\in A_S$). Then, in order for the rule to fire, `inS(l)` (resp.\u00a0`inS(nl)`) has to be true. However, this can only be the case for literals `l` (resp.\u00a0`nl`) occurring in a rule head of $\\Pi_{check}[S]$ (backwards, by the rules in line 15, 14 and 1 of $\\Pi_{meta}$ and by definition of $\\Pi'_{check}$), which contradicts our assumption that $\\texttt{atom(l,|l|)} \\in A_S$ (resp.\u00a0$\\texttt{atom(nl,|l|} \\in A_S$). Therefore, the facts of $A_S$ do not affect the rule in line 17 and consequently $\\Pi'_S$ has an answer set if and only if $\\Pi'_S \\setminus A_S$ has an answer set and these answer sets coincide on $Lit(\\Pi'_S) \\setminus A_S$.\n\nBy Theorem\u00a0\\[theo:corr\\], we know that (i) ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi_{check}[S])}\\xspace}$ always has an answer set and (ii) ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi_{check}[S])}\\xspace}$ has any answer set containing `notok` (which is unique) if and only if $\\Pi_{check}[S]$ has no answer set. However, the constraint ${\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}~{\\ensuremath{\\mathtt{not}\\ }\\texttt{notok}}.$ only allows for answer sets of $\\Pi'_S$ containing `notok`. Hence, an answer set $S_{check}$ of $\\Pi'_S \\setminus A_S$ exists if and only if $\\Pi_{check}[S]$ has no answer set, equivalently, $\\Pi_{check}\\cup S$ has no answer set.\n\nConversely, suppose $S$ is an answer set of $\\Pi_{guess}$ such that $\\Pi_{check}\\cup S$ has no answer set; equivalently, $\\Pi_{check}[S]$ has no answer set. By Theorem\u00a0\\[theo:corr\\], we know that ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi_{check}[S])}\\xspace} = F(\\Pi_{check}[S]) \\cup \\Pi_{meta}$ has a unique answer set $S_{check}$, and $S_{check}$ contains `notok`. Hence, also the program $$Q_S = F(\\Pi_{check}[S]) \\cup \\Pi_{meta} \\cup \\{{\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ {\\ensuremath{\\mathtt{not}\\ }\\texttt{notok}}.\\}$$ has the unique answer set $S_{check}$. On the other hand, since $S$ is an answer set of $\\Pi_{guess}$ and $Lit(\\Pi_{guess})$ is a splitting set for $\\Pi_{solve}$, for each answer set $S''$ of the program $\\Pi'_S = (\\Pi_{solve} \\setminus\n\\Pi_{guess})[S]$, we have that $S \\cup S''$ is an answer set of $\\Pi_{solve}$. However, $\\Pi'_S = Q_S \\cup A_S$; hence, $S''=S_{check} \\cup A_S$ must hold and $S_{solve} = S \\cup S_{check} \\cup A_S$ is the unique answer set of $\\Pi_{solve}$ which extends $S$. This proves the result.\n\nThe optimizations **OPT$_{pa}$** and **OPT$_{dep}$** in Section\u00a0\\[sec:optimizations\\] still apply. However, concerning **OPT$_{mod}$**, the following modifications are necessary:\n\n1.\u00a0Like the input representation, rules (\\[stmt:rulesatisfied\\]) and (\\[stmt:forcenormal\\]) have to be extended by adding [body]{}$_{guess}$`(r)`.\n\n2.\u00a0As for constraints $c$, we mentioned above that the factual representation of literals in ${\\ensuremath{B(c)}}$ may be skipped. This now only applies to literals in ${\\ensuremath{B^+(c)}}$; the rule `lit(n,l,c)\u00a0\u00a0body_{guess}(c).` for $l\\in {\\ensuremath{B^-(c)}}$ may no longer be dropped in general, as shown by the following example.\n\nLet $\\Pi_{guess} = \\{\\ \\texttt{g {\\mbox{\\texttt{v}\\xspace}}-g.}\\ \\}$ and $\\Pi_{check}=\\{\\ r1:\\texttt{~x {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}g.},\\ r2:\\texttt{~{\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}{\\ensuremath{\\mathtt{not}\\ }x}.}\\ \\}$ The \u201cinput\u201d representation of $\\Pi_{check}$ with respect to optimization **OPT$_{mod}$**, i.e., the variable part of $\\Pi'_{check}$, now consists of:\n\n\u00a0\u00a0\u00a0\u00a0lit(h,x,$r1$)$\\,$$\\,$g.\u00a0\u00a0lit(n,x,$r2$).\u00a0\u00a0inS(x)$\\,$:-$\\,$g.\u00a0\u00a0notok$\\,$:-$\\,$ninS(x).\n\nwhere the latter correspond to rules (\\[stmt:forcenormal\\]) and (\\[stmt:rulesatisfied\\]). If we now assume that we want to check answer set $S={\\ensuremath{\\{\\,\\mbox{\\tt-g}\n\\,\\}}}$ of $\\Pi_{guess}$, it is easy to see that $\\Pi_{check}$ has no answer set for $S$, and therefore $S$ should be represented by some answer set of our integrated encoding. Now assume that [lit(n,x,$r2$).]{} is dropped and we proceed in generating the integrated encoding as outlined above with respect to **OPT$_{mod}$**. Since $\\texttt{g} \\not\\in S$ and we have dropped [lit(n,x,$r2$).]{}, the \u201cinput\u201d representation of $\\Pi_{check}$ for $S$ comprises only the final rule `notok :- ninS(x).`. However, this rule can never fire because neither line\u00a015 nor line\u00a016 of $\\Pi_{meta}$ can ever derive [ninS(c)]{}. Therefore, also `notok` can not be derived and the integrated check fails. On the other hand, [lit(n,x,$r2$).]{} suffices to derive [ninS(x)]{} from line\u00a016 of $\\Pi_{meta}$, such that `notok` can be derived and the integrated check works as intended.\n\nIn certain cases, we can still drop $l\\in {\\ensuremath{B^-(c)}}$. For example, if $l$ occurs in the head of a rule $r$ with [body]{}$_{guess}(r) = \\emptyset$, since in this case [lit(h,l,$r$)]{} will always be added to the program (see also respective remarks in Section\u00a0\\[sec:applications\\]).\n\nIntegrating Guess and ${\\mathrm{NP}}\\!$ Check Programs\n------------------------------------------------------\n\nIn contrast to the situation above, integrating a guess program $\\Pi_{guess}$ and a check program $\\Pi_{check}$ which succeeds iff $\\Pi_{check}\\cup S$ has *some* answer set, is easy. Given that $\\Pi_{check}$ is a HDLP again, this amounts to integrating a check which is in ${\\mathrm{NP}}$. After a rewriting to ensure the Splitting Set property (if needed), simply take $\\Pi_{solve}=\\Pi_{guess} \\cup\n\\Pi_{check}$; its answer sets correspond on the predicates in $\\Pi_{guess}$ to the desired solutions.\n\nApplications {#sec:applications}\n============\n\nWe now give examples of the use of our transformation for three well-known ${{\\Sigma}_{2}^{P}}$-complete problems from the literature, which involve ${\\textrm{co-}{\\mathrm{NP}}}$-complete checking for a polynomial-time solution guess: the first is about quantified Boolean formulas (QBFs) with one quantifier alternation, which are well-studied in Answer Set Programming, the second about conformant planning [@eite-etal-2001e; @turn-2002; @leon-etal-2001], and the third is about strategic companies in the business domain [@leon-etal-2002-dlv].\n\nFurther examples and ad hoc encodings of such problems can be found e.g.\u00a0in [@eite-etal-97f; @eite-etal-2002-tplp; @leon-etal-2002-dlv] (and solved similarly). However, note that our method is applicable to [*any*]{} checks encoded by inconsistency of a HDLP; ${\\textrm{co-}{\\mathrm{NP}}}$-hardness is not a prerequisite.\n\nQuantified Boolean formulas {#sec:QBF}\n---------------------------\n\nGiven a QBF $F = \\exists x_1 \\cdots \\exists x_m \\forall y_1 \\cdots\n\\forall y_n\\,\\Phi$, where $\\Phi = c_1 \\vee \\cdots \\vee c_k $ is a propositional formula over $x_1,\\ldots,x_m, y_1,\\ldots,y_n$ in disjunctive normal form, i.e. each $c_i = a_{i,1} \\wedge \\cdots \\wedge a_{i,l_i}$ and $|a_{i,j}| \\in\n\\{x_1,\\ldots,x_m,y_1\\ldots,y_n\\}$, the problem is to compute some resp.\u00a0all assignments to the variable $x_1,\\ldots,x_m$ which witness that $F$ evaluates to true.\n\nIntuitively, this problem can be solved by \u201cguessing and checking\u201d as follows:\n\n($\\mathit{QBF}_{guess}$)\n\n:   Guess a truth assignment for the variables $x_1,\\ldots, x_m$.\n\n($\\mathit{QBF}_{check}$)\n\n:   Check whether this (fixed) assignment satisfies $\\Phi$ for all assignments of variables $y_1, \\ldots, y_n$.\n\nBoth parts can be encoded by very simple HDLPs (or similarly by normal programs):\n\n=\\\n$x_1$ \u00a0$-x_1.$ \u2026\u00a0$x_m$ \u00a0$-x_m.$\\\n\\[3ex\\]\\\n$y_1$ = \u00a0$-y_1.$ \u2026\u00a0$y_n$ \u00a0$-y_n.$\\\n$a_{1,1}, \\ldots, a_{1,l_1}$.\\\n\\\n$a_{k,1}, \\ldots, a_{k,l_1}$.\n\nClearly, both programs are head-cycle free. Moreover, for every answer set $S$ of $\\mathit{QBF}_{guess}$ \u2013representing an assignment to $x_1,\\ldots,x_m$\u2013 the program $\\mathit{QBF}_{check} \\cup S$ has no answer set thanks to the constraints, iff every assignment for $y_1, \\ldots, y_n$ satisfies formula $\\Phi$.\n\n`%%%%\u00a0GUESS\u00a0PART`\\\n`\u00a0x0\u00a0v\u00a0-x0.\u00a0\u00a0x1\u00a0v\u00a0-x1.`\\\n\\\n`%%%%\u00a0REWRITTEN\u00a0CHECK\u00a0PART`\\\n`%%\u00a01.\u00a0Create\u00a0dynamically\u00a0the\u00a0facts\u00a0for\u00a0the\u00a0check\u00a0program:`\\\n\\\n`%\u00a0y0\u00a0v\u00a0-y0.\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0%\u00a0y1\u00a0v\u00a0-y1.`\\\n`\u00a0\u00a0lit(h,`\u201c`y0`\u201d`,1).\u00a0lit(h,`\u201c`-y0`\u201d`,1).\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lit(h,`\u201c`y1`\u201d`,2).\u00a0lit(h,`\u201c`-y1`\u201d`,2).`\\\n`\u00a0\u00a0atom(`\u201c`y0`\u201d`,`\u201c`y0`\u201d`).\u00a0atom(`\u201c`-y0`\u201d`,`\u201c`y0`\u201d`).\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0atom(`\u201c`y1`\u201d`,`\u201c`y1`\u201d`).\u00a0atom(`\u201c`-y1`\u201d`,`\u201c`y1`\u201d`).`\\\n\\\n`\u00a0%\u00a0:-\u00a0-y0,\u00a0-x0.`\\\n`\u00a0%\u00a0:-\u00a0\u00a0y0,\u00a0-x0.`\\\n`\u00a0%\u00a0:-\u00a0-y0,\u00a0y1,\u00a0x0.`\\\n`\u00a0%\u00a0:-\u00a0-y0,\u00a0y0,\u00a0-x1.`\\\n\\\n`%%\u00a02.\u00a0Optimized\u00a0meta-interpreter`\\\n`%%\u00a02.1\u00a0\u2013\u00a0program\u00a0dependent\u00a0part`\\\n\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`y0`\u201d`),ninS(`\u201c`-y0`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`y1`\u201d`),ninS(`\u201c`-y1`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0inS(`\u201c`-y0`\u201d`),-x0.`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0inS(`\u201c`y0`\u201d`),-x0.`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0inS(`\u201c`y1`\u201d`),inS(`\u201c`-y0`\u201d`),x0.`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0inS(`\u201c`y0`\u201d`),inS(`\u201c`-y0`\u201d`),-x1.`\\\n\\\n`%%\u00a02.2\u00a0\u2013\u00a0fixed\u00a0rules`\\\n\\\n`%\u00a0Iterate\u00a0only\u00a0over\u00a0rules\u00a0which\u00a0contain\u00a0L\u00a0in\u00a0the\u00a0head:`\\\n`\u00a0\u00a0rule(L,R)\u00a0:-\u00a0lit(h,L,R),\u00a0not\u00a0lit(p,L,R),\u00a0not\u00a0lit(n,L,R).`\\\n`\u00a0\u00a0ruleBefore(L,R)\u00a0:-\u00a0rule(L,R),\u00a0rule(L,R1),\u00a0R1<R.`\\\n`\u00a0\u00a0ruleAfter(L,R)\u00a0:-\u00a0rule(L,R),\u00a0rule(L,R1),\u00a0R<R1.`\\\n`\u00a0\u00a0ruleBetween(L,R1,R2)\u00a0:-\u00a0rule(L,R1),\u00a0rule(L,R2),\u00a0rule(L,R3),\u00a0R1<R3,\u00a0R3<R2.`\\\n`\u00a0\u00a0firstRule(L,R)\u00a0:-\u00a0rule(L,R),\u00a0not\u00a0ruleBefore(L,R).`\\\n`\u00a0\u00a0lastRule(L,R)\u00a0:-\u00a0rule(L,R),\u00a0not\u00a0ruleAfter(L,R).`\\\n`\u00a0\u00a0nextRule(L,R1,R2)\u00a0:-\u00a0rule(L,R1),\u00a0rule(L,R2),\u00a0R1<R2,\u00a0not\u00a0ruleBetween(L,R1,R2).`\\\n\\\n`%\u00a0hlits\u00a0are\u00a0only\u00a0those\u00a0from\u00a0active\u00a0rules:`\\\n`\u00a0\u00a0hlit(L)\u00a0:-\u00a0rule(L,R).`\\\n`\u00a0\u00a0inS(L)\u00a0v\u00a0ninS(L)\u00a0:-\u00a0hlit(L).`\\\n`\u00a0\u00a0ninS(L)\u00a0:-\u00a0lit(HPN,L,R),\u00a0not\u00a0hlit(L).`\\\n\\\n`%\u00a0Consistency\u00a0check\u00a0could\u00a0be\u00a0skipped\u00a0for\u00a0programs\u00a0without\u00a0class.\u00a0negation:`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0inS(L),\u00a0inS(NL),\u00a0L\u00a0!=\u00a0NL,\u00a0atom(L,A),\u00a0atom(NL,A).`\\\n\\\n`\u00a0\u00a0dep(L,L1)\u00a0:-\u00a0rule(L,R),lit(p,L1,R),inS(L1),\u00a0inS(L).`\\\n`\u00a0\u00a0dep(L,L2)\u00a0:-\u00a0rule(L,R),lit(p,L1,R),dep(L1,L2),inS(L).`\\\n`\u00a0\u00a0cyclic\u00a0:-\u00a0dep(L,L1),\u00a0dep(L1,L).`\\\n`\u00a0\u00a0phi(L,L1)\u00a0v\u00a0phi(L1,L)\u00a0:-\u00a0dep(L,L1),\u00a0dep(L1,L),\u00a0L<L1,\u00a0cyclic.`\\\n`\u00a0\u00a0phi(L,L2)\u00a0:-\u00a0phi(L,L1),phi(L1,L2),\u00a0cyclic.`\\\n`\u00a0\u00a0failsToProve(L,R)\u00a0:-\u00a0rule(L,R),\u00a0lit(p,L1,R),\u00a0ninS(L1).`\\\n`\u00a0\u00a0failsToProve(L,R)\u00a0:-\u00a0rule(L,R),\u00a0lit(n,L1,R),\u00a0inS(L1).`\\\n`\u00a0\u00a0failsToProve(L,R)\u00a0:-\u00a0rule(L,R),\u00a0rule(L1,R),\u00a0inS(L1),\u00a0L1`[$\\mathtt{\\,!\\!\\!=}\\,$]{}`L.`\\\n`\u00a0\u00a0failsToProve(L,R)\u00a0:-\u00a0lit(p,L1,R),\u00a0rule(L,R),\u00a0phi(L1,L),\u00a0cyclic.`\\\n`\u00a0\u00a0allFailUpto(L,R)\u00a0:-\u00a0failsToProve(L,R),\u00a0firstRule(L,R).`\\\n`\u00a0\u00a0allFailUpto(L,R1)\u00a0:-\u00a0failsToProve(L,R1),\u00a0allFailUpto(L,R),\u00a0nextRule(L,R,R1).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0allFailUpto(L,R),\u00a0lastRule(L,R),\u00a0inS(L).`\\\n`\u00a0\u00a0phi(L,L1)\u00a0:-\u00a0notok,\u00a0hlit(L),\u00a0hlit(L1),\u00a0cyclic.`\\\n`\u00a0\u00a0inS(L)\u00a0:-\u00a0notok,\u00a0hlit(L).`\\\n`\u00a0\u00a0ninS(L)\u00a0:-\u00a0notok,\u00a0hlit(L).`\\\n\\\n`%%%\u00a03.\u00a0constraint`\\\n`\u00a0\u00a0\u00a0:-\u00a0not\u00a0notok.`\n\nBy the method described in Section\u00a0\\[sec:integration\\], we can automatically generate a single program $\\Pi_{solve}$ integrating the guess and check programs. For illustration, we consider the following QBF: $$\\exists x_0x_1\\forall y_0y_1\n({\\ensuremath{\\neg}}{x_0} \\wedge {\\ensuremath{\\neg}}{y_0}) \\vee\n(y_0 \\wedge {\\ensuremath{\\neg}}{x_0}) \\vee\n(y_1 \\wedge x_0 \\wedge {\\ensuremath{\\neg}}{y_0}) \\vee\n(y_0 \\wedge {\\ensuremath{\\neg}}{x_1} \\wedge {\\ensuremath{\\neg}}{y_0})$$ This QBF evaluates to true: for the assignments $x_0=0,x_1=0$ and $x_0=0,x_1=1$, the subformula $\\forall y_0y_1(\\cdots)$ is a tautology.\n\nThe integrated program $\\mathit{QBF}_{solve} = \\mathit{QBF}_{guess} \\cup \\mathit{QBF}'_{check}$ under use of the optimized transformation ${\\ensuremath{{\\ensuremath{tr}\\xspace}_{Opt}(\\cdot)}\\xspace}$ of ${\\ensuremath{tr}\\xspace}(\\cdot)$ as discussed is shown in Figure\u00a0\\[fig:qbf\\]. It has two answer sets of the form $S_1 = \\{ x_0,  -x_1, \\ldots, \\}$ and $S_2 = \\{ x_0,  x_1, \\ldots, \\}$, respectively.\n\nWith respect to the variants of the transformation, we remark that for the QBF encoding considerations upon negative literals in constraints in **OPT$_{mod}$** do not play a role, because all literals in the constraints of $\\mathit{QBF}_{check}$ are positive. Also **OPT$_{pa}$** does not play a role, since the only rules in $\\mathit{QBF}_{check}$ with non-empty heads are always potentially applicable because their bodies are empty.\n\nNote that the customary (but tricky) saturation technique in disjunctive logic programming to solve this problem, as used e.g.\u00a0in [@eite-etal-97f; @leon-etal-2002-dlv] and shown in \\[app:adhoc-qbf\\], is fully transparent to the non-expert, who might easily come up with the two programs above.\n\nConformant planning {#sec:conformant}\n-------------------\n\nLoosely speaking, planning is the problem of finding a sequence of actions $P=\\alpha_1$, $\\alpha_2$,\u2026, $\\alpha_n$, a [*plan*]{}, which takes a system from an initial state $s_0$ to a state $s_n$ in which a goal (often, given by an atom $g$) holds, where a state $s$ is described by values of fluents, i.e., predicates which might change over time. [*Conformant planning*]{} [@gold-bodd-96] is concerned with finding a plan $P$ which works under all contingencies which may arise because of incomplete information about the initial state and/or nondeterministic action effects.\n\nAs well-known, conformant planning in a STRIPS-style formulation is a ${{\\Sigma}_{2}^{P}}$-complete problem (precisely, deciding plan existence) in certain settings, e.g.\u00a0if the plan length $n$ (of polynomial size) is given and executability of actions is guaranteed, cf.[@eite-etal-2001e; @turn-2002]. Hence, the problem can be solved with a guess and (${\\textrm{co-}{\\mathrm{NP}}}$) check strategy.\n\nAs an example, we consider a simplified version of the well-known \u201c[*Bomb in the Toilet*]{}\u201d planning problem [@mcde-87] as in [@eite-etal-2001e]: We have been alarmed that a possibly armed bomb is in a lavatory which has a toilet bowl. Possible actions are dunking the bomb into the bowl and flushing the toilet. After just dunking, the bomb may be disarmed or not; only flushing the toilet guarantees that it is really disarmed.\n\nUsing the following guess and check programs $\\mathit{Bomb_{guess}}$ and $\\mathit{Bomb_{check}}$, respectively, we can compute a plan for having the bomb disarmed by two actions:\n\nX=\\\n% Timestamps:\\\ntime(0). time(1).\\\n% Guess a plan:\\\ndunk(T) v -dunk(T) :- time(T).\\\nflush(T) v -flush(T) :- time(T).\\\n% Forbid concurrent actions:\\\n:- flush(T), dunk(T).\\\n\\\n% Initial state:\\\narmed(0) v -armed(0).\\\n% Frame Axioms:\\\narmed(T1) :- armed(T), not -armed(T1), time(T), T1=T+1.\\\ndunked(T1) :- dunked(T), T1=T+1.\\\n% Effect of dunking:\\\ndunked(T1) :- dunk(T), T1=T+1.\\\narmed(T1) v -armed(T1) dunk(T), armed(T), T1=T+1.\\\n% Effect of flushing:\\\n-armed(T1) :- flush(T), dunked(T), T1=T+1.\\\n% Check whether goal holds in stage 2:\\\n:- not armed(2).\n\n$\\mathit{Bomb_{guess}}$ guesses all candidate plans $P=\\alpha_1,\\alpha_2$, starting from possible time points for action execution, while $\\mathit{Bomb_{check}}$ checks whether any such plan $P$ is conformant for the goal $g$ = `not armed(2)`. Here, the closed world assumption (CWA) on `armed` is used, i.e., absence of `armed(t)` is viewed as `-armed(t)`, which saves a negative frame axiom on `-armed`. The final constraint eliminates a plan execution iff it reaches the goal; thus, $\\mathit{Bomb_{check}}$ has no answer set iff the plan $P$ is conformant. As can be checked, the answer set $S=\\{ \\texttt{time(0)}, \\texttt{time(1)},\n\\texttt{dunk(0)}, \\texttt{flush(1)}\\}$ of $\\mathit{Bomb_{guess}}$ corresponds to the (single) conformant plan $P$= `dunk`, `flush` for the goal `not armed(2)`.\n\nBy using the method from Section\u00a0\\[sec:integration\\], the programs $\\mathit{Bomb_{guess}}$ and $\\mathit{Bomb_{check}}$ can be integrated automatically into a single program $\\mathit{Bomb_{plan}}= \\mathit{Bomb_{guess}} \\cup\n\\mathit{Bomb_{check}}'$ (cf.\u00a0\\[app:planning\\]). It has a single answer set, corresponding to the single conformant plan $P$ = `dunk`, `flush` as desired.\n\nWe point out that our rewriting method is more generally applicable than the encoding for conformant planning proposed in [@leon-etal-2001]. It loosens some of the restrictions there: While [@leon-etal-2001] requires that the state transition function is specified by a positive constraint-free logic program, our method can still safely be used in presence of negation and constraints, provided action execution will always lead to a consistent successor state and not entail absurdity; see [@eite-etal-2001e; @turn-2002] for a discussion of this setting.\n\nConcerning **OPT$_{mod}$**, we point out that there is the interesting constraint $$\\texttt{$c:$ :- not armed(2).}$$ in program $\\mathit{Bomb_{check}}$. Here, we may drop $\\texttt{lit(h,\"armed(2)\",c)}$ safely: For the frame axiom $$\\texttt{$r:$ armed(2)\\ {\\mbox{\\texttt{:\\hspace{-0.15em}-}}\\xspace}\\ armed(1),\\ not\\ -armed(2),\\ time(1).}$$ (cf.\u00a0\\[app:planning\\]), we have [body]{}$_{guess}(r) =\n{\\ensuremath{\\{\\texttt{time(1)}\\}}}$. Therefore, we obtain: $$\\texttt{lit(h,\"armed(2)\",r) :- time(1).}$$ However, this rule will always be added since $\\texttt{time(1)}$ is a deterministic consequence of $\\mathit{Bomb_{guess}}$. As for **OPT$_{pa}$** and considering the \u201cBomb in the Toilet\u201d instances from [@eite-etal-2001e], there might be rules which are *not* possible applicable with respect to a guessed plan; however, in experiments, the additional overhead for computing unfounded sets did not pay off.\n\nA generalization of the method demonstrated here on a small planning problem expressed in Answer Set Programming to conformant planning in the [${\\texttt{\\small DLV}\\xspace}^{{\\ensuremath{\\mathcal{K}}\\xspace}}$]{} planning system [@eite-etal-2001e], is discussed in detail in\u00a0[@poll-2003]. In this system, planning problems are encoded in a logical action language, and the encodings are mapped to logic programs. For conformant planning problems, separate guess and check programs have been devised [@eite-etal-2001e], which by our method can be automatically integrated into a single logic program. Such an encoding was previously unkown.\n\nStrategic Companies {#sec:strategic}\n-------------------\n\nAnother ${{\\Sigma}_{2}^{P}}$-complete problem is the strategic companies problem from [@cado-etal-97]. Briefly, a holding owns companies, each of which produces some goods. Moreover, several companies may jointly have control over another company. Now, some companies should be sold, under the constraint that all goods can be still produced, and that no company is sold which would still be controlled by the holding after the transaction. A company is [*strategic*]{}, if it belongs to a [*strategic set*]{}, which is a minimal set of companies satisfying these constraints. Guessing a strategic set, and checking its minimality can be done by the following two programs, where we adopt the constraint in [@cado-etal-97] that each product is produced by at most two companies and each company is jointly controlled by at most three other companies.\n\nXX=\\\nstrat(X) = v -strat(X) company(X).\\\nprod\\_by(X,Y,Z), not strat(Y), not strat(Z).\\\n= contr\\_by(W,X,Y,Z), not strat(W),\\\nstrat(X), strat(Y), strat(Z).\\\n\\\nstrat1(X) = v -strat1(X) strat(X).\\\nprod\\_by(X,Y,Z), not strat1(Y), not strat1(Z).\\\n= contr\\_by(W,X,Y,Z), not strat1(W),\\\nstrat1(X), strat1(Y), strat1(Z).\\\nsmaller ' \u00a0-strat1(X).\\\nnot smaller.\n\nHere, [strat$(C)$]{} means that $C$ is strategic, [prod\\_by$(P,C1,C2)$]{} that product $P$ is produced by companies $C1$ and $C2$, and [contr\\_by]{}$(C,C1,$ $C2,C3)$ that $C$ is jointly controlled by $C1,C2$ and $C3$. We assume facts `company(\\cdot)., prod_by(\\cdot,\\cdot,\\cdot).`, and `contr_by(\\cdot,\\cdot,\\cdot,\\cdot).` to be defined in a separate program which can be considered as part of $SC_{guess}$.\n\nThe two programs above intuitively encode guessing a set `strat` of companies which fulfills the production and control preserving constraints, such that no real subset `strat1` fulfills these constraints. While the ad hoc encodings from [@eite-etal-2000c; @leon-etal-2002-dlv], which can also be found in \\[app:adhoc-sc\\], are not immediate (and require some thought), the above programs are very natural and easy to come up with.\n\n[|c|c|c|]{} PRODUCT & COMPANY \\#1 & COMPANY \\#2\\\nPasta & Barilla & Saiwa\\\nTomatoes & Frutto & Barilla\\\nWine & Barilla & \u2013\\\nBread & Saiwa & Panino\\\n\nAs an example, let us consider the following production and control relations from [@cado-etal-97] in a holding as shown in Tables \\[tab:prod\\] and \\[tab:contr\\]. The symbol \u201c\u2013\u201d there means that the entry is void, which we simply represent by duplicating the single producer (or one of the controlling companies, respectively) in the factual representation; a possible representation is thus\n\n[ company(barilla). company(saiwa). company(frutto). company(panino). prod\\_by(pasta,barilla,saiwa). prod\\_by(tomatoes,frutto,barilla). prod\\_by(wine,barilla,barilla). prod\\_by(bread,saiwa,panino). contr\\_by(frutto,barilla,saiwa,saiwa). ]{}\n\nIf we would consider only the production relation, then Barilla and Saiwa together would form a strategic set, because they jointly produce all goods but neither of them alone. On the other hand, Frutto would not be strategic. However, given the company control as in Table\u00a0\\[tab:contr\\] means that Barilla and Saiwa together have control over Frutto. Taking into account that therefore Frutto can be sold only if either Barilla or Saiwa is also sold, the minimal sets of companies that produce all goods change completely: $\\{$Barilla, Saiwa$\\}$ is no longer a strategic set, while $s_1=\\{$Barilla, Saiwa, Frutto$\\}$ is. Alternatively, $s_2=\\{$Barilla, Panino$\\}$ is another strategic set.\n\n[|c|c|c|c|]{} CONTROLLED & CONT \\#1 & CONT \\#2 & CONT \\#3\\\nFrutto & Barilla & Saiwa & \u2013\\\n\nIntegration of the programs $SC_{guess}$ and $SC_{check}$ after grounding is again possible by the method from Section\u00a0\\[sec:integration\\] in an automatic way. Here, the facts representing the example instance are to be added as part of $SC_{guess}$, yielding two answer sets corresponding to $s_1$ and $s_2$ (cf.\u00a0\\[app:stratcomp\\]).\n\nWith regard to **OPT$_{mod}$**, we remark that depending on the concrete problem instance, $SC_{check}$ contains critical constraints $c$, where `\\mathtt{not}\\ strat1(\\cdot)` occurs, such that `lit(n,strat1(\\cdot),c)` may not be dropped here (cf.\u00a0\\[app:stratcomp\\]). Furthermore, as for **OPT$_{pa}$** all rules with non-empty heads are either possibly applicable or \u201cswitched off\u201d by $SC_{guess}$. Since there are no positive dependencies among the rules, `pa(\\cdot)` does not play a role there.\n\nAs a final remark, we note that modifying the guess and check programs $SC_{guess}$ and $SC_{check}$ to allow for unbounded numbers of producers for each product and controllers for each company, respectively, is easy. Assume that production and control are represented instead of relations `prod_by` and `contr_by` by an arbitrary number of facts of the form `produces(c,p).` and `controls(c_1,g,c).`, which state that company $c$ produces $p$ and that company $c_1$ belongs to a group $g$ of companies which jointly control $c$, respectively. Then, we would simply have to change the constraints in $SC_{guess}$ to:\n\n\u00a0\u00a0\u00a0\u00a0no\\_control(G,C) :- controls(C1,G,C), not strat(C1).\\\n:- controls(C1,G,C), not no\\_control(G,C), not strat(C).\\\nproduced(P) :- produces(C,P), strat(C).\\\n:- produces(C,P), not produced(P).\n\nThe constraints in $SC_{check}$ are changed similarly. Then, the synthesized integrated encoding according to our method gives us a DLP solving this problem. The ad hoc encodings in [@eite-etal-2000c; @leon-etal-2002-dlv] can not be adapted that easily, and in fact require substantial changes.\n\nExperiments {#sec:experiments}\n===========\n\nAs for evaluation of the proposed approach we have conducted a series of experiments for the problems outlined in the previous Section. Here, we were mainly interested in the following questions:\n\n*What is the performance impact of our automatically generated, integrated encoding compared with ad hoc encodings of ${{\\Sigma}_{2}^{P}}$ problems?*\n\nWe have therefore compared our automatically generated integrated encoding of QBFs and Strategic Companies against the following ad hoc encodings:\n\n1.  QBF against the ad hoc encoding for QBFs described in [@leon-etal-2002-dlv] (which assumes that the quantifier-free part is in 3DNF, i.e., contains three literals per disjunct); see \\[app:adhoc-qbf\\].\n\n2.  Strategic companies against the two ad hoc encodings for the Strategic Companies problem from [@eite-etal-2000c]; see \\[app:adhoc-sc\\].\n\n    These two encodings significantly differ: The first encoding, $ad hoc_1$ is very concise, and integrates guessing and checking in only two rules; it is an illustrative example of the power of disjunctive rules and tailored for a DLP system under answer set semantics. The second encoding, $ad hoc_2$, has a more obvious separate structure of the guessing and checking parts of the problem at the cost of some extra rules. However, in our opinion, none of these ad hoc encodings is obvious at first sight compared with the separate guess and check programs shown above.\n\nConcerning (i) we have tested randomly generated QBF instances with $n$ existentially and $n$ universally quantified variables (QBF-$n$), and concerning (ii) we have chosen randomly generated instances involving $n$ companies (SC-$n$).\n\n*What is the performance impact of the automatically generated, integrated encoding compared with interleaved computation of guess and check programs?*\n\nTo this end, we have tested the performance of solving some conformant planning problems with integrated encodings compared with the ASP based planning system [${\\texttt{\\small DLV}\\xspace}^{{\\ensuremath{\\mathcal{K}}\\xspace}}$]{}\u00a0[@eite-etal-2001e] which solves conformant planning problems by interleaving the guess of a plan with checking plan security. For its interleaved computation, [${\\texttt{\\small DLV}\\xspace}^{{\\ensuremath{\\mathcal{K}}\\xspace}}$]{}hinges on translations of the planning problem to HDLPs, by computing \u201coptimistic\u201d plans as solutions of a HDLP $\\Pi^{plan}_{guess}$ and interleaved checking of plan security by non-existence of solutions of a new program $\\Pi^{plan}_{guess}$ which is dynamically generated with respect to the plan at hand. [${\\texttt{\\small DLV}\\xspace}^{{\\ensuremath{\\mathcal{K}}\\xspace}}$]{}generalizes in some sense solving the small planning example in Section\u00a0\\[sec:conformant\\] for arbitrary planning problems specified in a declarative language, [$\\mathcal{K}$]{}[@eite-etal-2001d]. For our experiments we have used elaborations of \u201cBomb in the Toilet\u201d as described in [@eite-etal-2001d], namely \u201cBomb in the Toilet with clogging\u201d BTC($i$), where the toilet is clogged after dunking a package, and \u201cBomb in the Toilet with Uncertain Clogging\u201d BTUC($i$) where this clogging effect is non-deterministic and there are $i$ many possibly armed packages.\n\nTest Environment and General Setting\n------------------------------------\n\nAll tests were performed on an AMD Athlon 1200MHz machine with 256MB of main memory running SuSE Linux 8.1.\n\nAll our experiments have been conducted using the [`DLV`]{} system [@leon-etal-2002-dlv; @dlv-web], which is a state-of-the-art Answer Set Programming engine capable of solving DLPs. Another available system, [[GnT]{}]{}\u00a0[@janh-etal-2000][^4] which is not reported here showed worse performance/higher memory consumption on the tested instances.\n\nSince our method works on ground programs, we had to ground all instances (i.e.\u00a0the corresponding guess and check programs) beforehand whenever dealing with non-ground programs. Here, we have used [`DLV`]{}grounding with most optimizations turned off:[^5] Some optimizations during [`DLV`]{}grounding rewrite the program, adding new predicate symbols, etc. which we turned off in order to obtain correct input for the meta-interpreters.\n\nIn order to assess the effect of various optimizations and improvements to the transformation [${\\ensuremath{tr}\\xspace}(\\cdot)$]{}, we have also conducted the above experiments with the integrated encodings based on different optimized versions of [${\\ensuremath{tr}\\xspace}(\\cdot)$]{}.\n\nResults\n-------\n\nThe results of our experiments are shown in Tables\u00a0\\[tab:QBF\\]-\\[tab:BIT\\]. We report there the following tests on the various instances:\n\n-   $meta$\u00a0 indicates the unoptimized meta-interpreter $\\Pi_{meta}$\n\n-   $mod$\u00a0\u00a0indicates the non-modular optimization **OPT$_{mod}$** including the refinement for constraints.\n\n-   $dep$indicates the optimization **OPT$_{dep}$** where [$\\mathtt{phi}$]{} is only guessed for literals mutually depending on each other through positive recursion.\n\n-   $opt$indicates both optimizations **OPT$_{mod}$** and **OPT$_{dep}$** turned on.\n\nWe did not include optimization **OPT$_{pa}$** in our experiments, since the additional overhead for computing unfounded rules in the check programs which we have considered did not pay off (in fact, **OPT$_{pa}$** is irrelevant for QBF and Strategic Companies).\n\nAll times reported in the tables represent the execution times for finding the first answer set under the following resource constraints. We set a time limit of 10 minutes (=600 seconds) for QBFs and Strategic Companies, and of 4.000 seconds for the \u201cBomb in the Toilet\u201d instances. Furthermore, the limit on memory consumption was 256 MB (in order to avoid swapping). A dash \u2019-\u2019 in the tables indicates that one or more instances exceeded these limits.\n\n[|@[\u00a0]{}l@[\u00a0]{}|\\*[10]{}[c|]{}]{} & & & & &\\\n& AVG & MAX & AVG & MAX & AVG & MAX & AVG & MAX & AVG & MAX\\\nQBF-4 & 0.01s & 0.02s & 0.16s & 0.18s & 0.10s & 0.15s & 0.09s & 0.11s & 0.07s & 0.09s\\\nQBF-6 & 0.01s & 0.02s & 1.11s & 1.40s & 0.25s & 1.12s & 0.17s & 0.21s & 0.08s & 0.12s\\\nQBF-8 & 0.01s & 0.06s & 10.4s & 16.3s & 1.18s & 7.99s & 0.49s & 0.87s & 0.10s & 0.23s\\\nQBF-10 & 0.02s & 0.09s & 82.7s & 165s & 4.34s & 30.7s & 1.74s & 3.67s & 0.12s & 0.36s\\\nQBF-12 & 0.02s & 0.16s & - & - & - & - & - & - & 0.15s & 0.79s\\\nQBF-14 & 0.06s & 1.21s & - & - & - & - & - & - & 0.34s & 5.87s\\\nQBF-16 & 0.08s & 1.85s & - & - & - & - & - & - & 0.44s & 10.3s\\\nQBF-18 & 0.19s & 7.12s & - & - & - & - & - & - & 1.04s & 38.8s\\\nQBF-20 & 1.49s & 21.3s & - & - & - & - & - & - & 7.14s & 101s\\\n\\\n\n[|l|c|c|c|c|c|c|c|c|c|c|c|c|]{} & & & & & &\\\n& AVG & MAX & AVG & MAX & AVG & MAX & AVG & MAX & AVG & MAX & AVG & MAX\\\nSC-10 & 0.01s & 0.02s & 0.05s & 0.05s & 0.66s & 0.69s & 0.49s & 0.51s & 0.36s & 0.38s & 0.13s & 0.15s\\\nSC-15 & 0.01s & 0.02s & 0.11s & 0.13s & 1.82s & 3.23s & 1.50s & 3.12s & 0.64s & 0.68s & 0.20s & 0.22s\\\nSC-20 & 0.02s & 0.02s & 0.26 & 0.27s & 3.75s & 3.90s & 3.34s & 3.61s & 1.07s & 1.13s & 0.26s & 0.27s\\\nSC-25 & 0.02s & 0.02s & 0.51s & 0.54s & - & - & - & - & 1.63s & 1.68s & 0.33s & 0.35s\\\nSC-30 & 0.02s & 0.03s & 0.91s & 0.97s & - & - & - & - & 2.35s & 2.47s & 0.42s & 0.44s\\\nSC-35 & 0.02s & 0.03s & 1.50s & 1.60s & - & - & - & - & 3.17s & 3.27s & 0.54s & 0.56s\\\nSC-40 & 0.03s & 0.03s & 2.52s & 2.70s & - & - & - & - & 4.25s & 4.43s & 0.68s & 0.71s\\\nSC-45 & 0.03s & 0.04s & 4.503 & 4.97s & - & - & - & - & 5.46s & 5.77s & 0.84s & 0.90s\\\nSC-50 & 0.03s & 0.04s & 8.38s & 8.68s & - & - & - & - & 6.73s & 6.86s & 1.00s & 1.02s\\\nSC-60 & 0.04s & 0.05s & 22.6s & 24.3s & - & - & - & - & 10.2s & 10.6s & 1.47s & 1.53s\\\nSC-70 & 0.04s & 0.05s & 44.2s & 48.1s & - & - & - & - & 14.7s & 15.4s & 2.05s & 2.10s\\\nSC-80 & 0.04s & 0.05s & 75.9s & 82.5s & - & - & - & - & 19.7s & 21.0s & 2.78s & 3.05s\\\nSC-90 & 0.05s & 0.06s & 125s & 130s & - & - & - & - & 26.8s & 27.6s & 3.67s & 3.85s\\\nSC-100 & 0.06s & 0.08s & 196s & 208s & - & - & - & - & 34.8s & 36.3s & 4.70s & 4.80s\\\n\\\n\n[|@[\u00a0]{}l@[\u00a0]{}|c|c|c|c|c|]{} & [[`DLV`$^{\\ensuremath{\\mathcal{K}}\\xspace}$]{}]{}[@eite-etal-2001e] & $meta$ & $mod$ & $dep$ & $opt$\\\nBTC(2) & 0.01s & 1.16s & 0.80s & 0.15s & 0.08s\\\nBTC(3) & 0.11s & 9.33s & 9.25s & 8.18s & 4.95s\\\nBTC(4) & 4.68s & 71.3s & 67.8s & 333s & 256s\\\nBTUC(2) & 0.01s & 6.38s & 6.26s & 0.22s & 0.17s\\\nBTUC(3) & 1.78s & - & - & 28.1s & 13.0s\\\nBTUC(4) & 577s & - & - & - & 2322s\\\n\\\n\nThe results in Tables\u00a0\\[tab:SC\\]-\\[tab:BIT\\] show that the \u201cguess and saturate\u201d strategy in our approach benefits a lot from optimizations for all problems considered. However, we emphasize that it might depend on the structure of $\\Pi_{guess}$ and $\\Pi_{check}$ which optimizations are beneficial. We strongly believe that there is room for further improvements both on the translation and for the underlying [`DLV`]{}engine.\n\nWe note the following observations:\n\n-   Interestingly, for the QBF problem, the performance of our optimized translation stays within reach of the ad hoc encoding in [@leon-etal-2002-dlv] for small instances. Overall, the performance shown in Table\u00a0\\[tab:QBF\\] is within roughly a factor of 5-6 (with few exceptions for small instances), and thus scales similarly.\n\n-   For the Strategic Companies problem, the picture in Table\u00a0\\[tab:SC\\] is even more interesting. Unsurprisingly, the automatically generated encoding is inferior to the succinct ad hoc encoding $ad hoc_1$; it is more than an order of magnitude slower and scales worse. However, while it is slower by a small factor than the ad hoc encoding $ad hoc_2$ (which is more involved) on small instances, it scales much better and quickly outperforms this encoding.\n\n-   For the planning problems, the integrated encodings tested still stay behind the interleaved calls of ${\\ensuremath{{\\texttt{\\small DLV}\\xspace}^{{\\ensuremath{\\mathcal{K}}\\xspace}}}\\xspace}$.\n\n-   In all cases, the time limit was exceeded (for smaller instances) rather than the memory limit, but especially for bigger instances of \u201cBomb in the toilet\u201d and \u201cStrategic Companies,\u201d in some cases the memory limit was exceeded before timeout (e.g.\u00a0for BTUC(5), even with the optimized version of our transformation).\n\nSummary and Conclusion {#sec:conclusion}\n======================\n\nWe have considered the problem of integrating separate \u201cguess\u201d and \u201ccheck\u201d programs for solving expressive problems in the Answer Set Programming paradigm with a 2-step approach, into a single logic program. To this end, we have first presented a polynomial-time transformation of a head-cycle free, disjunctive program $\\Pi$ into a disjunctive program ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ which is stratified and constraint-free, such that in the case where $\\Pi$ is inconsistent (i.e., has no answer set), ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ has a single designated answer set which is easy to recognize, and otherwise the answer sets of $\\Pi$ are encoded in the answer sets of ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$. We then showed how to exploit ${\\ensuremath{{\\ensuremath{tr}\\xspace}(\\Pi)}\\xspace}$ for combining a \u201cguess\u201d program $\\Pi_{solve}$ and a \u201ccheck\u201d program $\\Pi_{check}$ for solving a problem in Answer Set Programming automatically into a single disjunctive logic program, such that its answer sets encode the solutions of the problem.\n\nExperiments have shown that such a synthesized encoding has weaker performance than the two-step method or an optimal ad hoc encoding for a problem, but can also outperform (reasonably looking) ad hoc encodings. This is noticeable since in some cases, finding any arbitrary \u201cnatural\u201d (not necessarily optimal) encoding of a problem in a single logic program appears to be very difficult, such as e.g.,for conformant planning [@leon-etal-2001] or determining minimal update answer sets [@eite-etal-2002-tplp], where such encodings were not known for the general case.\n\nSeveral issues remain for being tackled in future work. The first issue concerns extending the scope of programs which can be handled. The rewriting method which we have presented here applies to propositional programs only. Thus, before transformation, the program should be instantiated. In [@leon-etal-2002-dlv] instantiations of a logic program used in [`DLV`]{}have been described, which keep the grounding small and do not necessarily ground over the whole Herbrand universe. For wider applicability and better scalability of the approach, a more efficient lifting of our method to non-ground programs is needed. Furthermore, improvements to the current transformations might be researched. Some preliminary experimental results suggest that a structural analysis of the given guess and check program might be valuable for this purpose.\n\nA further issue are alternative transformations, which are possibly tailored for certain classes of programs. The work of Ben-Eliyahu and Dechter\u00a0[-@bene-dech-94], on which we build, aimed at transforming head-cycle free disjunctive logic programs into SAT problems. It might be interesting to investigate whether related methods such as the one developed for ASSAT\u00a0[@lin-zhao-2002], which was recently generalized by Lee and Lifschitz\u00a0[-@lee-lifs-2003] to disjunctive programs, can be adapted for our approach.\n\nAcknowledgments {#acknowledgments .unnumbered}\n---------------\n\nWe thank Gerald Pfeifer for his help on experimental evaluation and fruitful discussions. We are also grateful to the reviewers of the paper as well as the reviewers of the preliminary conference versions for their comments and constructive suggestions for improvement.\n\nIntegrated Program for Conformant Planning {#app:planning}\n==========================================\n\nThe integrated program for the planning problem in Section\u00a0\\[sec:conformant\\], $\\mathit{Bomb_{plan}} = \\mathit{Bomb_{guess}} \\cup\n\\mathit{Bomb_{check}}'$, is given below. It has a single answer set $S = \\{$ `dunk(0)`, `-flush(0)`, `flush(1)`, `-dunk(1)`, \u2026$\\}$ which corresponds to the single conformant plan $P$= `dunk`, `flush` as desired.\n\n`%%%%\u00a0GUESS\u00a0PART`\\\n\\\n`%\u00a0Timestamps:`\\\n`\u00a0\u00a0time(0).\u00a0time(1).`\\\n\\\n`%\u00a0Guess\u00a0a\u00a0plan:`\\\n`\u00a0\u00a0dunk(T)\u00a0v\u00a0-dunk(T)\u00a0:-\u00a0time(T).`\\\n`\u00a0\u00a0flush(T)\u00a0v\u00a0-flush(T)\u00a0:-\u00a0time(T).`\\\n`\u00a0\u00a0:-\u00a0flush(T),\u00a0dunk(T).`\\\n\\\n`%%%%\u00a0REWRITTEN\u00a0CHECK\u00a0PART\u00a0(after\u00a0grounding)`\\\n`%%\u00a01.\u00a0Create\u00a0dynamically\u00a0the\u00a0facts\u00a0for\u00a0the\u00a0program:`\\\n\\\n`%\u00a0armed(0)\u00a0v\u00a0-armed(0).`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`armed(0)`\u201d`,1).\u00a0atom(`\u201c`armed(0)`\u201d`,`\u201c`armed(0)`\u201d`).`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`-armed(0)`\u201d`,1).\u00a0atom(`\u201c`-armed(0)`\u201d`,`\u201c`armed(0)`\u201d`).`\\\n\\\n`%\u00a0armed(T1)\u00a0:-\u00a0armed(T),\u00a0not\u00a0-armed(T1),\u00a0time(T),\u00a0T1=T+1.`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`armed(1)`\u201d`,2)\u00a0:-\u00a0time(0).\u00a0atom(`\u201c`armed(1)`\u201d`,`\u201c`armed(1)`\u201d`).`\\\n`\u00a0\u00a0\u00a0lit(p,`\u201c`armed(0)`\u201d`,2)\u00a0:-\u00a0time(0).`\\\n`\u00a0\u00a0\u00a0lit(n,`\u201c`-armed(1)`\u201d`,2)\u00a0:-\u00a0time(0).`\\\n\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`armed(2)`\u201d`,3)\u00a0:-\u00a0time(1).\u00a0\u00a0atom(`\u201c`armed(2)`\u201d`,`\u201c`armed(2)`\u201d`).`\\\n`\u00a0\u00a0\u00a0lit(p,`\u201c`armed(1)`\u201d`,3)\u00a0:-\u00a0time(1).`\\\n`\u00a0\u00a0\u00a0lit(n,`\u201c`-armed(2)`\u201d`,3)\u00a0:-\u00a0time(1).`\\\n\\\n`%\u00a0dunked(T1)\u00a0:-\u00a0dunked(T),\u00a0T1=T+1.`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`dunked(1)`\u201d`,4).\u00a0\u00a0atom(`\u201c`dunked(1)`\u201d`,`\u201c`dunked(1)`\u201d`).`\\\n`\u00a0\u00a0\u00a0lit(p,`\u201c`dunked(0)`\u201d`,4).`\\\n\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`dunked(2)`\u201d`,5).\u00a0atom(`\u201c`dunked(2)`\u201d`,`\u201c`dunked(2)`\u201d`).`\\\n`\u00a0\u00a0\u00a0lit(p,`\u201c`dunked(1)`\u201d`,5).`\\\n\\\n`%\u00a0dunked(T1)\u00a0:-\u00a0dunk(T),\u00a0T1=T+1.`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`dunked(1)`\u201d`,6)\u00a0:-\u00a0dunk(0).`\\\n\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`dunked(2)`\u201d`,7)\u00a0:-\u00a0dunk(1).`\\\n\\\n`%\u00a0armed(T1)\u00a0v\u00a0-armed(T1)\u00a0:-\u00a0dunk(T),\u00a0armed(T),\u00a0T1=T+1.`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`armed(1)`\u201d`,8)\u00a0:-\u00a0dunk(0).`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`-armed(1)`\u201d`,8)\u00a0:-\u00a0dunk(0).\u00a0atom(`\u201c`-armed(1)`\u201d`,`\u201c`armed(1)`\u201d`).`\\\n`\u00a0\u00a0\u00a0lit(p,`\u201c`armed(0)`\u201d`,8)\u00a0:-\u00a0dunk(0).`\\\n\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`armed(2)`\u201d`,9)\u00a0:-\u00a0dunk(1).`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`-armed(2)`\u201d`,9)\u00a0:-\u00a0dunk(1).\u00a0atom(`\u201c`-armed(2)`\u201d`,`\u201c`armed(2)`\u201d`).`\\\n`\u00a0\u00a0\u00a0lit(p,`\u201c`armed(1)`\u201d`,9)\u00a0:-\u00a0dunk(1).`\\\n\\\n`%\u00a0-armed(T1)\u00a0:-\u00a0flush(1),\u00a0dunked(T),T1=T+1.`\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`-armed(1)`\u201d`,10)\u00a0:-\u00a0flush(0).\u00a0lit(p,`\u201c`dunked(0)`\u201d`,10)\u00a0:-\u00a0flush(0).`\\\n\\\n`\u00a0\u00a0\u00a0lit(h,`\u201c`-armed(2)`\u201d`,11)\u00a0:-\u00a0flush(1).\u00a0lit(p,`\u201c`dunked(1)`\u201d`,11)\u00a0:-\u00a0flush(1).`\\\n\\\n`%\u00a0:-\u00a0not\u00a0armed(2).`\\\n\\\n`%%\u00a02.\u00a0Optimized\u00a0meta-interpreter`\\\n\\\n`%%\u00a02.1\u00a0\u2013\u00a0program\u00a0dependent\u00a0part`\\\n\\\n`\u00a0\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`armed(0)`\u201d`),\u00a0ninS(`\u201c`-armed(0)`\u201d`).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`armed(1)`\u201d`)\u00a0:-\u00a0inS(`\u201c`armed(0)`\u201d`),\u00a0ninS(`\u201c`-armed(1)`\u201d`),\u00a0time(0).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`armed(2)`\u201d`)\u00a0:-\u00a0inS(`\u201c`armed(1)`\u201d`),\u00a0ninS(`\u201c`-armed(2)`\u201d`),\u00a0time(1).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`dunked(1)`\u201d`)\u00a0:-\u00a0inS(`\u201c`dunked(0)`\u201d`).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`dunked(2)`\u201d`)\u00a0:-\u00a0inS(`\u201c`dunked(1)`\u201d`).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`dunked(1)`\u201d`)\u00a0:-\u00a0dunk(0).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`dunked(2)`\u201d`)\u00a0:-\u00a0dunk(1).`\\\n`\u00a0\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`armed(1)`\u201d`),ninS(`\u201c`-armed(1)`\u201d`),\u00a0inS(`\u201c`armed(0)`\u201d`),\u00a0dunk(0).`\\\n`\u00a0\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`armed(2)`\u201d`),ninS(`\u201c`-armed(2)`\u201d`),inS(`\u201c`armed(1)`\u201d`),\u00a0dunk(1).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`-armed(1)`\u201d`)\u00a0:-\u00a0inS(`\u201c`dunked(0)`\u201d`),\u00a0flush(0).`\\\n`\u00a0\u00a0\u00a0inS(`\u201c`-armed(2)`\u201d`)\u00a0:-\u00a0inS(`\u201c`dunked(1)`\u201d`),\u00a0flush(1).`\\\n`\u00a0\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`armed(2)`\u201d`).`\\\n\\\n`%%\u00a02.2\u00a0\u2013\u00a0fixed\u00a0rules`\\\n\\\n`%\u00a0Skipped,\u00a0see\u00a0QBF\u00a0Encoding`\\\n\\\n`%%%\u00a03.\u00a0constraint`\\\n`\u00a0\u00a0\u00a0:-\u00a0not\u00a0notok.`\n\nIntegrated Program for Strategic Companies {#app:stratcomp}\n==========================================\n\nThe integrated program for the strategic companies problem instance in Section\u00a0\\[sec:strategic\\], $\\mathit{SC_{strategic}}$ = $\\mathit{SC_{guess}} \\cup\n\\mathit{SC_{check}}'$, is given below. It has two answer sets $S_1$ = {`strat(barilla)`, `strat(saiwa)`, `strat(frutto)`, \u2026} and $S_2$ = {`strat(barilla)`, `strat(panino)`, \u2026} which correspond to the strategic sets as identified above.\n\n`%%%%\u00a0GUESS\u00a0PART`\\\n`\u00a0\u00a0company(barilla).\u00a0company(saiwa).\u00a0company(frutto).\u00a0company(panino).`\\\n`\u00a0\u00a0prod_by(pasta,barilla,saiwa).\u00a0\u00a0prod_by(tomatoes,frutto,barilla).`\\\n`\u00a0\u00a0prod_by(wine,barilla,barilla).\u00a0prod_by(bread,saiwa,panino).`\\\n`\u00a0\u00a0contr_by(frutto,barilla,saiwa,barilla).`\\\n\\\n`%%\u00a0Guess\u00a0Program:\u00a0Not\u00a0necessarily\u00a0minimal`\\\n\\\n`\u00a0\u00a0strat(X)\u00a0v\u00a0-strat(X)\u00a0:-\u00a0company(X).`\\\n`\u00a0\u00a0\u00a0:-\u00a0\u00a0prod_by(X,Y,Z),\u00a0not\u00a0strat(Y),\u00a0not\u00a0strat(Z).`\\\n`\u00a0\u00a0\u00a0:-\u00a0\u00a0contr_by(W,X,Y,Z),\u00a0not\u00a0strat(W),`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strat(X),\u00a0strat(Y),\u00a0strat(Z).`\\\n\\\n`%%%%\u00a0REWRITTEN\u00a0CHECK\u00a0PART\u00a0(after\u00a0grounding)`\\\n`%%\u00a01.\u00a0Create\u00a0dynamically\u00a0the\u00a0facts\u00a0for\u00a0the\u00a0program:`\\\n\\\n`%\u00a0smaller\u00a0:-\u00a0-strat1(X).`\\\n`\u00a0\u00a0lit(h,`\u201c`smaller`\u201d`,1).\u00a0atom(`\u201c`smaller`\u201d`,`\u201c`smaller`\u201d`).`\\\n`\u00a0\u00a0lit(p,`\u201c`-strat1(saiwa)`\u201d`,1).`\\\n`\u00a0\u00a0lit(h,`\u201c`smaller`\u201d`,2).\u00a0atom(`\u201c`smaller`\u201d`,`\u201c`smaller`\u201d`).`\\\n`\u00a0\u00a0lit(p,`\u201c`-strat1(panino)`\u201d`,2).`\\\n`\u00a0\u00a0lit(h,`\u201c`smaller`\u201d`,3).\u00a0atom(`\u201c`smaller`\u201d`,`\u201c`smaller`\u201d`).`\\\n`\u00a0\u00a0lit(p,`\u201c`-strat1(frutto)`\u201d`,3).`\\\n`\u00a0\u00a0lit(h,`\u201c`smaller`\u201d`,4).\u00a0atom(`\u201c`smaller`\u201d`,`\u201c`smaller`\u201d`).`\\\n`\u00a0\u00a0lit(p,`\u201c`-strat1(barilla)`\u201d`,4).`\\\n\\\n`%\u00a0strat1(X)\u00a0v\u00a0-strat1(X)\u00a0:-\u00a0strat(X).`\\\n`\u00a0\u00a0lit(h,`\u201c`strat1(saiwa)`\u201d`,5)\u00a0:-\u00a0strat(saiwa).\u00a0\u00a0\u00a0\u00a0atom(`\u201c`strat1(saiwa)`\u201d`,`\u201c`strat1(saiwa)`\u201d`).`\\\n`\u00a0\u00a0lit(h,`\u201c`-strat1(saiwa)`\u201d`,5)\u00a0:-\u00a0strat(saiwa).\u00a0\u00a0\u00a0atom(`\u201c`-strat1(saiwa)`\u201d`,`\u201c`strat1(saiwa)`\u201d`).`\\\n`\u00a0\u00a0lit(h,`\u201c`strat1(panino)`\u201d`,6)\u00a0:-\u00a0strat(panino).\u00a0\u00a0atom(`\u201c`strat1(panino)`\u201d`,`\u201c`strat1(panino)`\u201d`).`\\\n`\u00a0\u00a0lit(h,`\u201c`-strat1(panino)`\u201d`,6)\u00a0:-\u00a0strat(panino).\u00a0atom(`\u201c`-strat1(panino)`\u201d`,`\u201c`strat1(panino)`\u201d`).`\\\n`lit(h,`\u201c`strat1(frutto)`\u201d`,7)\u00a0:-\u00a0strat(frutto).\u00a0\u00a0\u00a0\u00a0atom(`\u201c`strat1(frutto)`\u201d`,`\u201c`strat1(frutto)`\u201d`).`\\\n`lit(h,`\u201c`-strat1(frutto)`\u201d`,7)\u00a0:-\u00a0strat(frutto).\u00a0\u00a0\u00a0atom(`\u201c`-strat1(frutto)`\u201d`,`\u201c`strat1(frutto)`\u201d`).`\\\n`lit(h,`\u201c`strat1(barilla)`\u201d`,8)\u00a0:-\u00a0strat(barilla).\u00a0\u00a0atom(`\u201c`strat1(barilla)`\u201d`,`\u201c`strat1(barilla)`\u201d`).`\\\n`lit(h,`\u201c`-strat1(barilla)`\u201d`,8)\u00a0:-\u00a0strat(barilla).\u00a0atom(`\u201c`-strat1(barilla)`\u201d`,`\u201c`strat1(barilla)`\u201d`).`\n\n`% For constraints, critical negative literals need to be represented (cf.` **OPT$_{mod}$**`)`\n\n`%\u00a0:-\u00a0prod_by(X,Y,Z),\u00a0not\u00a0strat1(Y),\u00a0not\u00a0strat1(Z).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(saiwa)`\u201d`,10)\u00a0:-\u00a0prod_by(bread,saiwa,panino).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(panino)`\u201d`,10)\u00a0:-\u00a0prod_by(bread,saiwa,panino).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(frutto)`\u201d`,11)\u00a0:-\u00a0prod_by(tomatoes,frutto,\u00a0barilla).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(barilla)`\u201d`,11)\u00a0:-\u00a0prod_by(tomatoes,frutto,\u00a0barilla).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(barilla)`\u201d`,12)\u00a0:-\u00a0prod_by(wine,barilla,barilla).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(barilla)`\u201d`,13)\u00a0:-\u00a0prod_by(pasta,barilla,saiwa).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(saiwa)`\u201d`,13)\u00a0:-\u00a0prod_by(pasta,barilla,saiwa).`\\\n\\\n`%\u00a0:-\u00a0contr_by(W,X,Y,Z),\u00a0not\u00a0strat1(W),\u00a0strat1(X),\u00a0strat1(Y),\u00a0strat1(Z).`\\\n`\u00a0\u00a0lit(n,`\u201c`strat1(frutto)`\u201d`,14)\u00a0:-\u00a0contr_by(frutto,barilla,saiwa,saiwa).`\\\n\\\n`%%\u00a02.\u00a0Optimized\u00a0meta-interpreter`\\\n\\\n`%%\u00a02.1\u00a0\u2013\u00a0program\u00a0dependent\u00a0part`\\\n`\u00a0\u00a0inS(`\u201c`smaller`\u201d`)\u00a0:-\u00a0inS(`\u201c`-strat1(saiwa)`\u201d`).`\\\n`\u00a0\u00a0inS(`\u201c`smaller`\u201d`)\u00a0:-\u00a0inS(`\u201c`-strat1(panino)`\u201d`).`\\\n`\u00a0\u00a0inS(`\u201c`smaller`\u201d`)\u00a0:-\u00a0inS(`\u201c`-strat1(frutto)`\u201d`).`\\\n`\u00a0\u00a0inS(`\u201c`smaller`\u201d`)\u00a0:-\u00a0inS(`\u201c`-strat1(barilla)`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(saiwa)`\u201d`),ninS(`\u201c`-strat1(saiwa)`\u201d`),strat(saiwa).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(panino)`\u201d`),ninS(`\u201c`-strat1(panino)`\u201d`),strat(panino).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(frutto)`\u201d`),ninS(`\u201c`-strat1(frutto)`\u201d`),strat(frutto).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(barilla)`\u201d`),ninS(`\u201c`-strat1(barilla)`\u201d`),strat(barilla).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`smaller`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(saiwa)`\u201d`),ninS(`\u201c`strat1(panino)`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(frutto)`\u201d`),ninS(`\u201c`strat1(barilla)`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(barilla)`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0ninS(`\u201c`strat1(barilla)`\u201d`),ninS(`\u201c`strat1(saiwa)`\u201d`).`\\\n`\u00a0\u00a0notok\u00a0:-\u00a0inS(`\u201c`strat1(barilla)`\u201d`),inS(`\u201c`strat1(saiwa)`\u201d`),ninS(`\u201c`strat1(frutto)`\u201d`).`\\\n\\\n`%%\u00a02.2\u00a0\u2013\u00a0fixed\u00a0rules`\\\n\\\n`%\u00a0Skipped,\u00a0see\u00a0QBF\u00a0Encoding`\\\n\\\n`%%%\u00a03.\u00a0constraint`\\\n`\u00a0\u00a0\u00a0:-\u00a0not\u00a0notok.`\n\nAd Hoc Encoding for Quantified Boolean Formulas {#app:adhoc-qbf}\n===============================================\n\nThe ad hoc encoding in [@leon-etal-2002-dlv] for evaluating a QBF of form $F = \\exists x_1 \\cdots \\exists x_m \\forall y_1 \\cdots\n\\forall y_n\\,\\Phi$, where $\\Phi = c_1 \\vee \\cdots \\vee c_k $ is a propositional formula over $x_1,\\ldots,x_m, y_1,\\ldots,y_n$ in 3DNF, i.e. each $c_i = a_{i,1} \\wedge \\cdots \\wedge a_{i,3}$ and $|a_{i,j}| \\in\n\\{x_1,\\ldots,$ $x_m,$ $y_1\\ldots,$ $y_n\\}$, represents $F$ by the following facts:\n\n-   `exists(x_i).` for each existential variable $x_i$;\n\n-   `forall(y_j).` for each universal variable $y_j$; and\n\n-   `term(p_1, p_2, p_3, q_1, q_2, q_3).` for each disjunct $c_j = l_{i,1} \\land l_{i,2} \\land l_{i,3}$ in $\\Phi$, where (i) if $l_{i,j}$ is a positive atom $v_k$, then $p_j = v_k$, otherwise $p_j$= $\\mathtt{true}$, and (ii) if $l_{i,j}$ is a negated atom $\\neg v_k$, then $q_i=v_k$, otherwise $q_i$ = $\\mathtt{false}$. For example, $term(x_1,\\mathtt{true}, y_4,\n    \\mathtt{false}, y_2, \\mathtt{false})$, encodes the term $x_1\\land \\neg y_2\n    \\land y_4$.\n\nFor instance, our sample instance from Section\u00a0\\[sec:QBF\\] $$\\exists x_0x_1\\forall y_0y_1\n({\\ensuremath{\\neg}}{x_0} \\wedge {\\ensuremath{\\neg}}{y_0}) \\vee\n(y_0 \\wedge {\\ensuremath{\\neg}}{x_0}) \\vee\n(y_1 \\wedge x_0 \\wedge {\\ensuremath{\\neg}}{y_0}) \\vee\n(y_0 \\wedge {\\ensuremath{\\neg}}{x_1} \\wedge {\\ensuremath{\\neg}}{y_0})$$ would be encoded by the following facts:\n\n`\u00a0\u00a0\u00a0exists(x0).\u00a0\u00a0exists(x1).\u00a0\u00a0forall(y1).\u00a0\u00a0forall(y2).`\\\n`\u00a0\u00a0\u00a0term(true,true,true,x0,y0,false).`\\\n`\u00a0\u00a0\u00a0term(y0,true,true,x0,false,false).`\\\n`\u00a0\u00a0\u00a0term(y1,x0,true,y0,false,false).`\\\n`\u00a0\u00a0\u00a0term(y0,true,true,x1,y0,false).`\n\nThese facts are conjoined with the following facts and rules:\n\n`\u00a0\u00a0\u00a0t(true).\u00a0f(false).`\\\n`\u00a0\u00a0\u00a0t(X)\u00a0\u00a0f(X)\u00a0:-\u00a0exists(X).`\\\n`\u00a0\u00a0\u00a0t(Y)\u00a0\u00a0f(Y)\u00a0:-\u00a0forall(Y).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w\u00a0:-\u00a0term(X,Y,Z,Na,Nb,Nc),t(X),t(Y),t(Z),`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0f(Na),f(Nb),f(Nc).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t(Y)\u00a0:-\u00a0w,\u00a0forall(Y).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0f(Y)\u00a0:-\u00a0w,\u00a0forall(Y).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0:-\u00a0not\u00a0w.`\n\nThe guessing part \u201cinitializes\u201d the logical constants $\\mathtt{true}$ and $\\mathtt{false}$ and chooses a witnessing assignment $\\sigma$ to the variables in $X$, which leads to an answer set $M_G$ for this part. The more tricky checking part then tests whether $\\phi[X/ \\sigma(X)]$ is a tautology, using a saturation technique similar to our meta-interpreter.\n\nAd Hoc Encodings for Strategic Companies {#app:adhoc-sc}\n========================================\n\nThe first ad hoc encoding for Strategic Companies in [@eite-etal-2000c], $ad hoc_1$, solves the problem in a surprisingly elegant way by the following two rules conjoined to the facts representing the $\\mathit{prod\\_by}$ and $\\mathit{contr\\_by}$ relations:\n\n`\u00a0\u00a0\u00a0strat(Y)\u00a0\u00a0strat(Z)\u00a0:-\u00a0prod_by(X,Y,Z).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strat(W)\u00a0:-\u00a0contr_by(W,X,Y,Z),\u00a0strat(X),`\\\n`strat(Y),`\\\n`strat(Z).`\n\nHere, the minimality of answer sets plays together with the first rule generating candidate strategic sets and the second rule enforcing the constraint on the controls relation. It constitutes a sophisticated example of intermingled guess and check. Howewer, this succinct encoding relies very much on the fixed number of producing and controlling companies; an extension to arbitrarily many producers and controllers seems not to be as easy as in our separate guess and check programs from Section\u00a0\\[sec:strategic\\].\n\nThe second ad hoc encoding from [@eite-etal-2000c], $ad hoc_2$, strictly separates the guess and checking parts, and uses the following rules and constraints:\n\n`\u00a0\u00a0\u00a0strat(X)\u00a0\u00a0-strat(X)\u00a0:-\u00a0company(X).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0:-\u00a0prod_by(X,Y,Z),\u00a0not\u00a0strat(Y),\u00a0not\u00a0strat(Z).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0:-\u00a0contr_by(W,X,Y,Z),\u00a0not\u00a0strat(W),\u00a0strat(X),\u00a0strat(Y),\u00a0strat(Z).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0:-\u00a0not\u00a0min(X),\u00a0strat(X).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0:-\u00a0strat\u2019(X,Y),\u00a0-strat(Y).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0:-\u00a0strat\u2019(X,X).`\\\n`\u00a0\u00a0\u00a0min(X)\u00a0\u00a0strat\u2019(X,Y)\u00a0\u00a0strat\u2019(X,Z)\u00a0:-\u00a0prod_by(G,Y,Z),strat(X).`\\\n`\u00a0\u00a0\u00a0min(X)\u00a0\u00a0strat\u2019(X,C)\u00a0:-\u00a0contr_by(C,W,Y,Z),\u00a0strat(X),`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strat\u2019(X,W),\u00a0strat\u2019(X,Y),\u00a0strat\u2019(X,Z).`\\\n`\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strat\u2019(X,Y)\u00a0:-\u00a0min(X),\u00a0strat(X),\u00a0strat(Y),\u00a0X`[[$\\mathtt{\\,!\\!\\!=}\\,$]{}]{}`Y.`\n\nInformally, the first rule and the first two constraints generate a candidate strategic set, whose minimality is checked by the remainder of the program. For a detailed explanation, we refer to [@eite-etal-2000c].\n\n[10]{}\n\nMarcello Balduccini and Michael Gelfond. . , 3:425\u2013461, July/September 2003.\n\nChitta Baral. . Cambridge University Press, 2002.\n\nR.\u00a0Ben-Eliyahu and R.\u00a0Dechter. . , 12:53\u201387, 1994.\n\nMarco Cadoli, Thomas Eiter, and Georg Gottlob. . , 9(3):448\u2013463, May/June 1997.\n\nA.\u00a0Cimatti and M.\u00a0Roveri. . \u00a0[*13*]{}, 305\u2013338, 2000.\n\nEvgeny Dantsin, Thomas Eiter, Georg Gottlob, and Andrei Voronkov. . , 33(3):374\u2013425, 2001.\n\nJim Delgrande, Torsten Schaub, and Hans Tompits. . In Thomas Eiter, Wolfgang Faber, and Miros[\u0142]{}aw Truszczy[\u0144]{}ski, editors, [*[Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-01)]{}*]{}, number 2173 in LNCS, pages 411\u2013415. Springer, 2001.\n\nThomas Eiter, Wolfgang Faber, Nicola Leone, and Gerald Pfeifer. . In Jack Minker, editor, [*[Logic-Based Artificial Intelligence]{}*]{}, pages 79\u2013103. Kluwer Academic Publishers, 2000.\n\nThomas Eiter, Wolfgang Faber, Nicola Leone, and Gerald Pfeifer. . , 3:463\u2013498, July/September 2003.\n\nThomas Eiter, Wolfgang Faber, Nicola Leone, Gerald Pfeifer, and Axel Polleres. . , 144(1\u20132):157\u2013211, March 2003.\n\nThomas Eiter, Wolfgang Faber, Nicola Leone, Gerald Pfeifer, and Axel Polleres. . , 5(2), April 2004.\n\nThomas Eiter, Michael Fink, Giuliana Sabbatini, and Hans Tompits. . , 2(6):721\u2013777, 2002.\n\nThomas Eiter, Georg Gottlob, and Heikki Mannila. . , 22(3):364\u2013418, September 1997.\n\nWolfgang Faber and Gerald Pfeifer. homepage, [since 1996]{}. <http://www.dlvsystem.com/>.\n\nM.\u00a0Gelfond and V.\u00a0Lifschitz. . , 9:365\u2013385, 1991.\n\nMichael Gelfond. . In Antonis\u00a0C. Kakas and Fariba Sadri, editors, [*[Computational Logic. Logic Programming and Beyond]{}*]{}, number 2408 in LNCS, pages 413\u2013451. Springer, 2002.\n\nR.\u00a0Goldman and M.\u00a0Boddy. . In [*[Proceedings AIPS-96]{}*]{}, pages 110\u2013117. AAAI Press, 1996.\n\nG.\u00a0Greco, S.\u00a0Greco, and E.\u00a0Zumpano. A logic programming approach to the integration, repairing and querying of inconsistent databases. In [*Proceedings 17th International Conference on Logic Programming (ICLP 2001)*]{}, number 2237 in [Lecture Notes in AI (LNAI)]{}, pages 348\u2013364. Springer Verlag, 2001.\n\nTomi Janhunen. Comparing the expressive powers of some syntactically restricted classes of logic porgrams. In John Lloyd, Veronica Dahl, Ulrich Furbach, Manfred Kerber, Kung-Kiu Lau, Catuscia Palamidessi, Lu[\u00ed]{}s\u00a0Moniz Pereira, Yehoshua Sagiv, and Peter\u00a0J. Stuckey, editors, [*Computational Logic - CL 2000, First International Conference, Proceedings*]{}, number 1861 in [Lecture Notes in AI (LNAI)]{}, pages 852\u2013866, London, UK, July 2000. Springer Verlag.\n\nTomi Janhunen. On the effect of default negation on the expressiveness of disjunctive rules. In Thomas Eiter, Wolfgang Faber, and Miros[\u0142]{}aw Truszczy\u0144ski, editors, [*[Logic Programming and Nonmonotonic Reasoning \u2014 6th International Conference, LPNMR\u201901, Vienna, Austria, September 2001, Proceedings]{}*]{}, number 2173 in [Lecture Notes in AI (LNAI)]{}, pages 93\u2013106. Springer Verlag, September 2001.\n\nTomi Janhunen, Ilkka Niemel[\u00e4]{}, Patrik Simons, and Jia-Huai You. . In Anthony\u00a0G. Cohn, Fausto Giunchiglia, and Bart Selman, editors, [*[Proceedings of the Seventh International Conference on Principles of Knowledge Representation and Reasoning (KR\u00a02000), April 12-15, Breckenridge, Colorado, USA]{}*]{}, pages 411\u2013419. Morgan Kaufmann Publishers, Inc., 2000.\n\nJoohyung Lee and Vladimir Lifschitz. . In [*Proceedings of the Nineteenth International Conference on Logic Programming (ICLP-03)*]{}. Springer Verlag, December 2003.\n\nNicola Leone, Gerald Pfeifer, Wolfgang Faber, Thomas Eiter, Georg Gottlob, Simona Perri, and Francesco Scarcello. , 2004. To appear. Available via <http://www.arxiv.org/ps/cs.AI/0211004>.\n\nNicola Leone, Riccardo Rosati, and Francesco Scarcello. . In Alessandro Cimatti, H[\u00e9]{}ctor Geffner, Enrico Giunchiglia, and Jussi Rintanen, editors, [*[IJCAI-01 Workshop on Planning under Uncertainty and Incomplete Information]{}*]{}, pages 33\u201342, August 2001.\n\nV.\u00a0Lifschitz and H.\u00a0Turner. . In Pascal [Van Hentenryck]{}, editor, [*[Proceedings of the 11th International Conference on Logic Programming (ICLP\u201994)]{}*]{}, pages 23\u201337, Santa Margherita Ligure, Italy, June 1994. MIT Press.\n\nVladimir Lifschitz. . , 138:39\u201354, 2002.\n\nFangzhen Lin and Yuting Zhao. . In [*[Proceedings of the Eighteenth National Conference on Artificial Intelligence (AAAI-2002)]{}*]{}, Edmonton, Alberta, Canada, 2002. AAAI Press / MIT Press.\n\nVictor\u00a0W. Marek and Jeffrey\u00a0B. Remmel. . , 3:551\u2013567, November 2003.\n\nVictor\u00a0W. Marek and Miros[\u0142]{}aw Truszczy[\u0144]{}ski. . In K.\u00a0Apt, V.\u00a0W. Marek, M.\u00a0Truszczy[\u0144]{}ski, and D.\u00a0S. Warren, editors, [*[The Logic Programming Paradigm \u2013 A 25-Year Perspective]{}*]{}, pages 375\u2013398. Springer Verlag, 1999.\n\nDrew McDermott. . , 3:151\u2013237, 1987. Cited in [@cima-rove-2000].\n\nIlkka Niemel[\u00e4]{}. . , 25(3\u20134):241\u2013273, 1999.\n\nChristos\u00a0H. Papadimitriou. A note on the expressive power of prolog. , 26:21\u201323, 1985.\n\nChristos\u00a0H. Papadimitriou. . Addison-Wesley, 1994.\n\nAxel Polleres. . PhD thesis, [Institut f[\u00fc]{}r Informationssysteme, Technische Universit[\u00e4]{}t Wien]{}, [Wien, [\u00d6]{}sterreich]{}, 2003.\n\nAlessandro Provetti and Son\u00a0Tran Cao, editors. , Stanford, CA, March 2001. AAAI Press.\n\nT.\u00a0Przymusinski. . , 5(2):167\u2013205, 1989.\n\nTeodor\u00a0C. Przymusinski. . , 9:401\u2013424, 1991.\n\nChiaki Sakama and Katsumi Inoue. . , 3:671\u2013713, November 2003.\n\nJ.S. Schlipf. . , 51(1):64\u201386, 1995. Abstract in Proc.\u00a0PODS 90, pp.\u00a0196\u2013204.\n\nHudson Turner. . In Sergio Flesca, Sergio Greco, Giovambattista Ianni, and Nicola Leone, editors, [*Proceedings of the 8th European Conference on Logics in Artificial Intelligence (JELIA)*]{}, number 2424 in [Lecture Notes in Computer Science]{}, pages 111\u2013124, Cosenza, Italy, September 2002. Springer.\n\n[^1]: We disregard a possible inconsistent answer set, which is not of much interest for our concerns.\n\n[^2]: Similarly, in\u00a0[@bene-dech-94] $\\phi: Lit(\\Pi) \\rightarrow \\{1, \\ldots, r\\}$ is only defined for a range $r$ bound by the longest acyclic path in any strongly connected component of the program.\n\n[^3]: Here, for any program $\\Pi$, we write ${\\ensuremath{H(\\Pi)}}= \\bigcup_{r \\in \\Pi} {\\ensuremath{H(r)}}$.\n\n[^4]: [[GnT]{}]{}, available from <http://www.tcs.hut.fi/Software/gnt/>, is an extension of [[Smodels]{}]{}solving DLPs by interleaved calls of [[Smodels]{}]{}, which itself is only capable of solving normal LPs.\n\n[^5]: Respective ground instances have been produced with the command `dlv -OR- -instantiate`, (cf.\u00a0the [`DLV`]{}-Manual [@dlv-web]), which turns off most of the grounding optimizations.\n"
}