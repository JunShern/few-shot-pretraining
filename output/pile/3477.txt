{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 11 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "3477",
    "text": "/*\n * This file is part of the CmBacktrace Library.\n *\n * Copyright (c) 2016-2017, Armink, <armink.ztl@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Function: Initialize function and other general function.\n * Created on: 2016-12-15\n */\n\n#include \"utils/debug/CmBacktrace/cm_backtrace.h\"\n#include <stdbool.h>\n#include <string.h>\n#include <stdio.h>\n\n#if __STDC_VERSION__ < 199901L\n    #error \"must be C99 or higher. try to add '-std=c99' to compile parameters\"\n#endif\n\n#if defined(__CC_ARM)\n    #define SECTION_START(_name_)                _name_##$$Base\n    #define SECTION_END(_name_)                  _name_##$$Limit\n    #define IMAGE_SECTION_START(_name_)          Image$$##_name_##$$Base\n    #define IMAGE_SECTION_END(_name_)            Image$$##_name_##$$Limit\n    #define CSTACK_BLOCK_START(_name_)           SECTION_START(_name_)\n    #define CSTACK_BLOCK_END(_name_)             SECTION_END(_name_)\n    #define CODE_SECTION_START(_name_)           IMAGE_SECTION_START(_name_)\n    #define CODE_SECTION_END(_name_)             IMAGE_SECTION_END(_name_)\n\n    extern const int CSTACK_BLOCK_START(CMB_CSTACK_BLOCK_NAME);\n    extern const int CSTACK_BLOCK_END(CMB_CSTACK_BLOCK_NAME);\n    extern const int CODE_SECTION_START(CMB_CODE_SECTION_NAME);\n    extern const int CODE_SECTION_END(CMB_CODE_SECTION_NAME);\n#elif defined(__ICCARM__)\n    #pragma section=CMB_CSTACK_BLOCK_NAME\n    #pragma section=CMB_CODE_SECTION_NAME\n#elif defined(__GNUC__)\n    extern const int CMB_CSTACK_BLOCK_START;\n    extern const int CMB_CSTACK_BLOCK_END;\n    extern const int CMB_CODE_SECTION_START;\n    extern const int CMB_CODE_SECTION_END;\n#else\n    #error \"not supported compiler\"\n#endif\n\nenum {\n    PRINT_FIRMWARE_INFO,\n    PRINT_ASSERT_ON_THREAD,\n    PRINT_ASSERT_ON_HANDLER,\n    PRINT_THREAD_STACK_INFO,\n    PRINT_MAIN_STACK_INFO,\n    PRINT_THREAD_STACK_OVERFLOW,\n    PRINT_MAIN_STACK_OVERFLOW,\n    PRINT_CALL_STACK_INFO,\n    PRINT_CALL_STACK_ERR,\n    PRINT_FAULT_ON_THREAD,\n    PRINT_FAULT_ON_HANDLER,\n    PRINT_REGS_TITLE,\n    PRINT_HFSR_VECTBL,\n    PRINT_MFSR_IACCVIOL,\n    PRINT_MFSR_DACCVIOL,\n    PRINT_MFSR_MUNSTKERR,\n    PRINT_MFSR_MSTKERR,\n    PRINT_MFSR_MLSPERR,\n    PRINT_BFSR_IBUSERR,\n    PRINT_BFSR_PRECISERR,\n    PRINT_BFSR_IMPREISERR,\n    PRINT_BFSR_UNSTKERR,\n    PRINT_BFSR_STKERR,\n    PRINT_BFSR_LSPERR,\n    PRINT_UFSR_UNDEFINSTR,\n    PRINT_UFSR_INVSTATE,\n    PRINT_UFSR_INVPC,\n    PRINT_UFSR_NOCP,\n    PRINT_UFSR_UNALIGNED,\n    PRINT_UFSR_DIVBYZERO0,\n    PRINT_DFSR_HALTED,\n    PRINT_DFSR_BKPT,\n    PRINT_DFSR_DWTTRAP,\n    PRINT_DFSR_VCATCH,\n    PRINT_DFSR_EXTERNAL,\n    PRINT_MMAR,\n    PRINT_BFAR,\n};\n\nstatic const char * const print_info[] = {\n#if (CMB_PRINT_LANGUAGE == CMB_PRINT_LANGUAGE_ENGLISH)\n        [PRINT_FIRMWARE_INFO]         = \"Firmware name: %s, hardware version: %s, software version: %s\",\n        [PRINT_ASSERT_ON_THREAD]      = \"Assert on thread %s\",\n        [PRINT_ASSERT_ON_HANDLER]     = \"Assert on interrupt or bare metal(no OS) environment\",\n        [PRINT_THREAD_STACK_INFO]     = \"===== Thread stack information =====\",\n        [PRINT_MAIN_STACK_INFO]       = \"====== Main stack information ======\",\n        [PRINT_THREAD_STACK_OVERFLOW] = \"Error: Thread stack(%08x) was overflow\",\n        [PRINT_MAIN_STACK_OVERFLOW]   = \"Error: Main stack(%08x) was overflow\",\n        [PRINT_CALL_STACK_INFO]       = \"Show more call stack info by run: addr2line -e %s%s -a -f %.*s\",\n        [PRINT_CALL_STACK_ERR]        = \"Dump call stack has an error\",\n        [PRINT_FAULT_ON_THREAD]       = \"Fault on thread %s\",\n        [PRINT_FAULT_ON_HANDLER]      = \"Fault on interrupt or bare metal(no OS) environment\",\n        [PRINT_REGS_TITLE]            = \"=================== Registers information ====================\",\n        [PRINT_HFSR_VECTBL]           = \"Hard fault is caused by failed vector fetch\",\n        [PRINT_MFSR_IACCVIOL]         = \"Memory management fault is caused by instruction access violation\",\n        [PRINT_MFSR_DACCVIOL]         = \"Memory management fault is caused by data access violation\",\n        [PRINT_MFSR_MUNSTKERR]        = \"Memory management fault is caused by unstacking error\",\n        [PRINT_MFSR_MSTKERR]          = \"Memory management fault is caused by stacking error\",\n        [PRINT_MFSR_MLSPERR]          = \"Memory management fault is caused by floating-point lazy state preservation\",\n        [PRINT_BFSR_IBUSERR]          = \"Bus fault is caused by instruction access violation\",\n        [PRINT_BFSR_PRECISERR]        = \"Bus fault is caused by precise data access violation\",\n        [PRINT_BFSR_IMPREISERR]       = \"Bus fault is caused by imprecise data access violation\",\n        [PRINT_BFSR_UNSTKERR]         = \"Bus fault is caused by unstacking error\",\n        [PRINT_BFSR_STKERR]           = \"Bus fault is caused by stacking error\",\n        [PRINT_BFSR_LSPERR]           = \"Bus fault is caused by floating-point lazy state preservation\",\n        [PRINT_UFSR_UNDEFINSTR]       = \"Usage fault is caused by attempts to execute an undefined instruction\",\n        [PRINT_UFSR_INVSTATE]         = \"Usage fault is caused by attempts to switch to an invalid state (e.g., ARM)\",\n        [PRINT_UFSR_INVPC]            = \"Usage fault is caused by attempts to do an exception with a bad value in the EXC_RETURN number\",\n        [PRINT_UFSR_NOCP]             = \"Usage fault is caused by attempts to execute a coprocessor instruction\",\n        [PRINT_UFSR_UNALIGNED]        = \"Usage fault is caused by indicates that an unaligned access fault has taken place\",\n        [PRINT_UFSR_DIVBYZERO0]       = \"Usage fault is caused by Indicates a divide by zero has taken place (can be set only if DIV_0_TRP is set)\",\n        [PRINT_DFSR_HALTED]           = \"Debug fault is caused by halt requested in NVIC\",\n        [PRINT_DFSR_BKPT]             = \"Debug fault is caused by BKPT instruction executed\",\n        [PRINT_DFSR_DWTTRAP]          = \"Debug fault is caused by DWT match occurred\",\n        [PRINT_DFSR_VCATCH]           = \"Debug fault is caused by Vector fetch occurred\",\n        [PRINT_DFSR_EXTERNAL]         = \"Debug fault is caused by EDBGRQ signal asserted\",\n        [PRINT_MMAR]                  = \"The memory management fault occurred address is %08x\",\n        [PRINT_BFAR]                  = \"The bus fault occurred address is %08x\",\n#elif (CMB_PRINT_LANGUAGE == CMB_PRINT_LANGUAGE_CHINESE)\n        [PRINT_FIRMWARE_INFO]         = \"\u56fa\u4ef6\u540d\u79f0\uff1a%s\uff0c\u786c\u4ef6\u7248\u672c\u53f7\uff1a%s\uff0c\u8f6f\u4ef6\u7248\u672c\u53f7\uff1a%s\",\n        [PRINT_ASSERT_ON_THREAD]      = \"\u5728\u7ebf\u7a0b(%s)\u4e2d\u53d1\u751f\u65ad\u8a00\",\n        [PRINT_ASSERT_ON_HANDLER]     = \"\u5728\u4e2d\u65ad\u6216\u88f8\u673a\u73af\u5883\u4e0b\u53d1\u751f\u65ad\u8a00\",\n        [PRINT_THREAD_STACK_INFO]     = \"=========== \u7ebf\u7a0b\u5806\u6808\u4fe1\u606f ===========\",\n        [PRINT_MAIN_STACK_INFO]       = \"============ \u4e3b\u5806\u6808\u4fe1\u606f ============\",\n        [PRINT_THREAD_STACK_OVERFLOW] = \"\u9519\u8bef\uff1a\u7ebf\u7a0b\u6808(%08x)\u53d1\u751f\u6ea2\u51fa\",\n        [PRINT_MAIN_STACK_OVERFLOW]   = \"\u9519\u8bef\uff1a\u4e3b\u6808(%08x)\u53d1\u751f\u6ea2\u51fa\",\n        [PRINT_CALL_STACK_INFO]       = \"\u67e5\u770b\u66f4\u591a\u51fd\u6570\u8c03\u7528\u6808\u4fe1\u606f\uff0c\u8bf7\u8fd0\u884c\uff1aaddr2line -e %s%s -a -f %.*s\",\n        [PRINT_CALL_STACK_ERR]        = \"\u83b7\u53d6\u51fd\u6570\u8c03\u7528\u6808\u5931\u8d25\",\n        [PRINT_FAULT_ON_THREAD]       =  \"\u5728\u7ebf\u7a0b(%s)\u4e2d\u53d1\u751f\u9519\u8bef\u5f02\u5e38\",\n        [PRINT_FAULT_ON_HANDLER]      = \"\u5728\u4e2d\u65ad\u6216\u88f8\u673a\u73af\u5883\u4e0b\u53d1\u751f\u9519\u8bef\u5f02\u5e38\",\n        [PRINT_REGS_TITLE]            = \"========================= \u5bc4\u5b58\u5668\u4fe1\u606f =========================\",\n        [PRINT_HFSR_VECTBL]           = \"\u53d1\u751f\u786c\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u53d6\u4e2d\u65ad\u5411\u91cf\u65f6\u51fa\u9519\",\n        [PRINT_MFSR_IACCVIOL]         = \"\u53d1\u751f\u5b58\u50a8\u5668\u7ba1\u7406\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u4f01\u56fe\u4ece\u4e0d\u5141\u8bb8\u8bbf\u95ee\u7684\u533a\u57df\u53d6\u6307\u4ee4\",\n        [PRINT_MFSR_DACCVIOL]         = \"\u53d1\u751f\u5b58\u50a8\u5668\u7ba1\u7406\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u4f01\u56fe\u4ece\u4e0d\u5141\u8bb8\u8bbf\u95ee\u7684\u533a\u57df\u8bfb\u3001\u5199\u6570\u636e\",\n        [PRINT_MFSR_MUNSTKERR]        = \"\u53d1\u751f\u5b58\u50a8\u5668\u7ba1\u7406\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u51fa\u6808\u65f6\u4f01\u56fe\u8bbf\u95ee\u4e0d\u88ab\u5141\u8bb8\u7684\u533a\u57df\",\n        [PRINT_MFSR_MSTKERR]          = \"\u53d1\u751f\u5b58\u50a8\u5668\u7ba1\u7406\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u5165\u6808\u65f6\u4f01\u56fe\u8bbf\u95ee\u4e0d\u88ab\u5141\u8bb8\u7684\u533a\u57df\",\n        [PRINT_MFSR_MLSPERR]          = \"\u53d1\u751f\u5b58\u50a8\u5668\u7ba1\u7406\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u60f0\u6027\u4fdd\u5b58\u6d6e\u70b9\u72b6\u6001\u65f6\u53d1\u751f\u9519\u8bef\",\n        [PRINT_BFSR_IBUSERR]          = \"\u53d1\u751f\u603b\u7ebf\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u6307\u4ee4\u603b\u7ebf\u9519\u8bef\",\n        [PRINT_BFSR_PRECISERR]        = \"\u53d1\u751f\u603b\u7ebf\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u7cbe\u786e\u7684\u6570\u636e\u603b\u7ebf\u9519\u8bef\",\n        [PRINT_BFSR_IMPREISERR]       = \"\u53d1\u751f\u603b\u7ebf\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u4e0d\u7cbe\u786e\u7684\u6570\u636e\u603b\u7ebf\u9519\u8bef\",\n        [PRINT_BFSR_UNSTKERR]         = \"\u53d1\u751f\u603b\u7ebf\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u51fa\u6808\u65f6\u53d1\u751f\u9519\u8bef\",\n        [PRINT_BFSR_STKERR]           = \"\u53d1\u751f\u603b\u7ebf\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u5165\u6808\u65f6\u53d1\u751f\u9519\u8bef\",\n        [PRINT_BFSR_LSPERR]           = \"\u53d1\u751f\u603b\u7ebf\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u60f0\u6027\u4fdd\u5b58\u6d6e\u70b9\u72b6\u6001\u65f6\u53d1\u751f\u9519\u8bef\",\n        [PRINT_UFSR_UNDEFINSTR]       = \"\u53d1\u751f\u7528\u6cd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u4f01\u56fe\u6267\u884c\u672a\u5b9a\u4e49\u6307\u4ee4\",\n        [PRINT_UFSR_INVSTATE]         = \"\u53d1\u751f\u7528\u6cd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u8bd5\u56fe\u5207\u6362\u5230 ARM \u72b6\u6001\",\n        [PRINT_UFSR_INVPC]            = \"\u53d1\u751f\u7528\u6cd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u65e0\u6548\u7684\u5f02\u5e38\u8fd4\u56de\u7801\",\n        [PRINT_UFSR_NOCP]             = \"\u53d1\u751f\u7528\u6cd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u4f01\u56fe\u6267\u884c\u534f\u5904\u7406\u5668\u6307\u4ee4\",\n        [PRINT_UFSR_UNALIGNED]        = \"\u53d1\u751f\u7528\u6cd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u4f01\u56fe\u6267\u884c\u975e\u5bf9\u9f50\u8bbf\u95ee\",\n        [PRINT_UFSR_DIVBYZERO0]       = \"\u53d1\u751f\u7528\u6cd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u4f01\u56fe\u6267\u884c\u9664 0 \u64cd\u4f5c\",\n        [PRINT_DFSR_HALTED]           = \"\u53d1\u751f\u8c03\u8bd5\u9519\u8bef\uff0c\u539f\u56e0\uff1aNVIC \u505c\u673a\u8bf7\u6c42\",\n        [PRINT_DFSR_BKPT]             = \"\u53d1\u751f\u8c03\u8bd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u6267\u884c BKPT \u6307\u4ee4\",\n        [PRINT_DFSR_DWTTRAP]          = \"\u53d1\u751f\u8c03\u8bd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u6570\u636e\u76d1\u6d4b\u70b9\u5339\u914d\",\n        [PRINT_DFSR_VCATCH]           = \"\u53d1\u751f\u8c03\u8bd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u53d1\u751f\u5411\u91cf\u6355\u83b7\",\n        [PRINT_DFSR_EXTERNAL]         = \"\u53d1\u751f\u8c03\u8bd5\u9519\u8bef\uff0c\u539f\u56e0\uff1a\u5916\u90e8\u8c03\u8bd5\u8bf7\u6c42\",\n        [PRINT_MMAR]                  = \"\u53d1\u751f\u5b58\u50a8\u5668\u7ba1\u7406\u9519\u8bef\u7684\u5730\u5740\uff1a%08x\",\n        [PRINT_BFAR]                  = \"\u53d1\u751f\u603b\u7ebf\u9519\u8bef\u7684\u5730\u5740\uff1a%08x\",\n#else\n    #error \"CMB_PRINT_LANGUAGE defined error in 'cmb_cfg.h'\"\n#endif\n};\n\nstatic char fw_name[CMB_NAME_MAX] = {0};\nstatic char hw_ver[CMB_NAME_MAX] = {0};\nstatic char sw_ver[CMB_NAME_MAX] = {0};\nstatic uint32_t main_stack_start_addr = 0;\nstatic size_t main_stack_size = 0;\nstatic uint32_t code_start_addr = 0;\nstatic size_t code_size = 0;\nstatic bool init_ok = false;\nstatic char call_stack_info[CMB_CALL_STACK_MAX_DEPTH * (8 + 1)] = { 0 };\nstatic bool on_fault = false;\nstatic bool stack_is_overflow = false;\nstatic struct cmb_hard_fault_regs regs;\n\n#if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7)\nstatic bool statck_has_fpu_regs = false;\n#endif\n\nstatic bool on_thread_before_fault = false;\n\n/**\n * library initialize\n */\nvoid cm_backtrace_init(const char *firmware_name, const char *hardware_ver, const char *software_ver) {\n    strncpy(fw_name, firmware_name, CMB_NAME_MAX);\n    strncpy(hw_ver, hardware_ver, CMB_NAME_MAX);\n    strncpy(sw_ver, software_ver, CMB_NAME_MAX);\n\n#if defined(__CC_ARM)\n    main_stack_start_addr = (uint32_t)&CSTACK_BLOCK_START(CMB_CSTACK_BLOCK_NAME);\n    main_stack_size = (uint32_t)&CSTACK_BLOCK_END(CMB_CSTACK_BLOCK_NAME) - main_stack_start_addr;\n    code_start_addr = (uint32_t)&CODE_SECTION_START(CMB_CODE_SECTION_NAME);\n    code_size = (uint32_t)&CODE_SECTION_END(CMB_CODE_SECTION_NAME) - code_start_addr;\n#elif defined(__ICCARM__)\n    main_stack_start_addr = (uint32_t)__section_begin(CMB_CSTACK_BLOCK_NAME);\n    main_stack_size = (uint32_t)__section_end(CMB_CSTACK_BLOCK_NAME) - main_stack_start_addr;\n    code_start_addr = (uint32_t)__section_begin(CMB_CODE_SECTION_NAME);\n    code_size = (uint32_t)__section_end(CMB_CODE_SECTION_NAME) - code_start_addr;\n#elif defined(__GNUC__)\n    main_stack_start_addr = (uint32_t)(&CMB_CSTACK_BLOCK_START);\n    main_stack_size = (uint32_t)(&CMB_CSTACK_BLOCK_END) - main_stack_start_addr;\n    code_start_addr = (uint32_t)(&CMB_CODE_SECTION_START);\n    code_size = (uint32_t)(&CMB_CODE_SECTION_END) - code_start_addr;\n#else\n    #error \"not supported compiler\"\n#endif\n\n    init_ok = true;\n}\n\n/**\n * print firmware information, such as: firmware name, hardware version, software version\n */\nvoid cm_backtrace_firmware_info(void) {\n    cmb_println(print_info[PRINT_FIRMWARE_INFO], fw_name, hw_ver, sw_ver);\n}\n\n#ifdef CMB_USING_OS_PLATFORM\n/**\n * Get current thread stack information\n *\n * @param sp stack current pointer\n * @param start_addr stack start address\n * @param size stack size\n */\nstatic void get_cur_thread_stack_info(uint32_t sp, uint32_t *start_addr, size_t *size) {\n    CMB_ASSERT(start_addr);\n    CMB_ASSERT(size);\n\n#if (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_RTT)\n    *start_addr = (uint32_t) rt_thread_self()->stack_addr;\n    *size = rt_thread_self()->stack_size;\n#elif (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_UCOSII)\n    extern OS_TCB *OSTCBCur;\n\n    *start_addr = (uint32_t) OSTCBCur->OSTCBStkBottom;\n    *size = OSTCBCur->OSTCBStkSize * sizeof(OS_STK);\n#elif (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_UCOSIII)\n    extern OS_TCB *OSTCBCurPtr; \n    \n    *start_addr = (uint32_t) OSTCBCurPtr->StkBasePtr;\n    *size = OSTCBCurPtr->StkSize * sizeof(CPU_STK_SIZE);\n#elif (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_FREERTOS)   \n    *start_addr = (uint32_t)vTaskStackAddr();\n    *size = vTaskStackSize() * sizeof( StackType_t );\n#endif\n}\n\n/**\n * Get current thread name\n */\nstatic const char *get_cur_thread_name(void) {\n#if (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_RTT)\n    return rt_thread_self()->name;\n#elif (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_UCOSII)\n    extern OS_TCB *OSTCBCur;\n\n#if OS_TASK_NAME_SIZE > 0 || OS_TASK_NAME_EN > 0\n        return (const char *)OSTCBCur->OSTCBTaskName;\n#else\n        return NULL;\n#endif /* OS_TASK_NAME_SIZE > 0 || OS_TASK_NAME_EN > 0 */\n\n#elif (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_UCOSIII)\n    extern OS_TCB *OSTCBCurPtr; \n    \n    return (const char *)OSTCBCurPtr->NamePtr;\n#elif (CMB_OS_PLATFORM_TYPE == CMB_OS_PLATFORM_FREERTOS)\n    return vTaskName();\n#endif\n}\n\n#endif /* CMB_USING_OS_PLATFORM */\n\n#ifdef CMB_USING_DUMP_STACK_INFO\n/**\n * dump current stack information\n */\nstatic void dump_stack(uint32_t stack_start_addr, size_t stack_size, uint32_t *stack_pointer) {\n    if (stack_is_overflow) {\n        if (on_thread_before_fault) {\n            cmb_println(print_info[PRINT_THREAD_STACK_OVERFLOW], stack_pointer);\n        } else {\n            cmb_println(print_info[PRINT_MAIN_STACK_OVERFLOW], stack_pointer);\n        }\n        if ((uint32_t) stack_pointer < stack_start_addr) {\n            stack_pointer = (uint32_t *) stack_start_addr;\n        } else if ((uint32_t) stack_pointer > stack_start_addr + stack_size) {\n            stack_pointer = (uint32_t *) (stack_start_addr + stack_size);\n        }\n    }\n    cmb_println(print_info[PRINT_THREAD_STACK_INFO]);\n    for (; (uint32_t) stack_pointer < stack_start_addr + stack_size; stack_pointer++) {\n        cmb_println(\"  addr: %08x    data: %08x\", stack_pointer, *stack_pointer);\n    }\n    cmb_println(\"====================================\");\n}\n#endif /* CMB_USING_DUMP_STACK_INFO */\n\n/**\n * backtrace function call stack\n *\n * @param buffer call stack buffer\n * @param size buffer size\n * @param sp stack pointer\n *\n * @return depth\n */\nsize_t cm_backtrace_call_stack(uint32_t *buffer, size_t size, uint32_t sp) {\n    uint32_t stack_start_addr = main_stack_start_addr, pc;\n    size_t depth = 0, stack_size = main_stack_size;\n    bool regs_saved_lr_is_valid = false;\n\n    if (on_fault) {\n        if (!stack_is_overflow) {\n            /* first depth is PC */\n            buffer[depth++] = regs.saved.pc;\n            /* second depth is from LR, so need decrease a word to PC */\n            pc = regs.saved.lr - sizeof(size_t);\n            if ((pc >= code_start_addr) && (pc <= code_start_addr + code_size) && (depth < CMB_CALL_STACK_MAX_DEPTH)\n                    && (depth < size)) {\n                buffer[depth++] = pc;\n                regs_saved_lr_is_valid = true;\n            }\n        }\n\n#ifdef CMB_USING_OS_PLATFORM\n        /* program is running on thread before fault */\n        if (on_thread_before_fault) {\n            get_cur_thread_stack_info(sp, &stack_start_addr, &stack_size);\n        }\n    } else {\n        /* OS environment */\n        if (cmb_get_sp() == cmb_get_psp()) {\n            get_cur_thread_stack_info(sp, &stack_start_addr, &stack_size);\n        }\n#endif /* CMB_USING_OS_PLATFORM */\n\n    }\n\n    if (stack_is_overflow) {\n        if (sp < stack_start_addr) {\n            sp = stack_start_addr;\n        } else if (sp > stack_start_addr + stack_size) {\n            sp = stack_start_addr + stack_size;\n        }\n    }\n\n    /* copy called function address */\n    for (; sp < stack_start_addr + stack_size; sp += sizeof(size_t)) {\n        /* the *sp value may be LR, so need decrease a word to PC */\n        pc = *((uint32_t *) sp) - sizeof(size_t);\n        /* the Cortex-M using thumb instruction, so the pc must be an odd number */\n        if (pc % 2 == 0) {\n            continue;\n        }\n        if ((pc >= code_start_addr) && (pc <= code_start_addr + code_size) \\\n            && (depth < CMB_CALL_STACK_MAX_DEPTH) && (depth < size)) {\n            /* the second depth function may be already saved, so need ignore repeat */\n            if ((depth == 2) && regs_saved_lr_is_valid && (pc == buffer[1])) {\n                continue;\n            }\n            buffer[depth++] = pc;\n        }\n    }\n\n    return depth;\n}\n\n/**\n * dump function call stack\n *\n * @param sp stack pointer\n */\nstatic void print_call_stack(uint32_t sp) {\n    size_t i, cur_depth = 0;\n    uint32_t call_stack_buf[CMB_CALL_STACK_MAX_DEPTH] = {0};\n\n    cur_depth = cm_backtrace_call_stack(call_stack_buf, CMB_CALL_STACK_MAX_DEPTH, sp);\n\n    for (i = 0; i < cur_depth; i++) {\n        sprintf(call_stack_info + i * (8 + 1), \"%08lx\", call_stack_buf[i]);\n        call_stack_info[i * (8 + 1) + 8] = ' ';\n    }\n\n    if (cur_depth) {\n        cmb_println(print_info[PRINT_CALL_STACK_INFO], fw_name, CMB_ELF_FILE_EXTENSION_NAME, cur_depth * (8 + 1),\n                call_stack_info);\n    } else {\n        cmb_println(print_info[PRINT_CALL_STACK_ERR]);\n    }\n}\n\n/**\n * backtrace for assert\n *\n * @param sp the stack pointer when on assert occurred\n */\nvoid cm_backtrace_assert(uint32_t sp) {\n    CMB_ASSERT(init_ok);\n\n#ifdef CMB_USING_OS_PLATFORM\n    uint32_t cur_stack_pointer = cmb_get_sp();\n#endif\n\n    cmb_println(\"\");\n    cm_backtrace_firmware_info();\n\n#ifdef CMB_USING_OS_PLATFORM\n    /* OS environment */\n    if (cur_stack_pointer == cmb_get_msp()) {\n        cmb_println(print_info[PRINT_ASSERT_ON_HANDLER]);\n\n#ifdef CMB_USING_DUMP_STACK_INFO\n        dump_stack(main_stack_start_addr, main_stack_size, (uint32_t *) sp);\n#endif /* CMB_USING_DUMP_STACK_INFO */\n\n    } else if (cur_stack_pointer == cmb_get_psp()) {\n        cmb_println(print_info[PRINT_ASSERT_ON_THREAD], get_cur_thread_name());\n\n#ifdef CMB_USING_DUMP_STACK_INFO\n        uint32_t stack_start_addr;\n        size_t stack_size;\n        get_cur_thread_stack_info(sp, &stack_start_addr, &stack_size);\n        dump_stack(stack_start_addr, stack_size, (uint32_t *) sp);\n#endif /* CMB_USING_DUMP_STACK_INFO */\n\n    }\n\n#else\n\n    /* bare metal(no OS) environment */\n#ifdef CMB_USING_DUMP_STACK_INFO\n    dump_stack(main_stack_start_addr, main_stack_size, (uint32_t *) sp);\n#endif /* CMB_USING_DUMP_STACK_INFO */\n\n#endif /* CMB_USING_OS_PLATFORM */\n\n    print_call_stack(sp);\n}\n\n#if (CMB_CPU_PLATFORM_TYPE != CMB_CPU_ARM_CORTEX_M0)\n/**\n * fault diagnosis then print cause of fault\n */\nstatic void fault_diagnosis(void) {\n    if (regs.hfsr.bits.VECTBL) {\n        cmb_println(print_info[PRINT_HFSR_VECTBL]);\n    }\n    if (regs.hfsr.bits.FORCED) {\n        /* Memory Management Fault */\n        if (regs.mfsr.value) {\n            if (regs.mfsr.bits.IACCVIOL) {\n                cmb_println(print_info[PRINT_MFSR_IACCVIOL]);\n            }\n            if (regs.mfsr.bits.DACCVIOL) {\n                cmb_println(print_info[PRINT_MFSR_DACCVIOL]);\n            }\n            if (regs.mfsr.bits.MUNSTKERR) {\n                cmb_println(print_info[PRINT_MFSR_MUNSTKERR]);\n            }\n            if (regs.mfsr.bits.MSTKERR) {\n                cmb_println(print_info[PRINT_MFSR_MSTKERR]);\n            }\n\n#if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7)\n            if (regs.mfsr.bits.MLSPERR) {\n                cmb_println(print_info[PRINT_MFSR_MLSPERR]);\n            }\n#endif\n\n            if (regs.mfsr.bits.MMARVALID) {\n                if (regs.mfsr.bits.IACCVIOL || regs.mfsr.bits.DACCVIOL) {\n                    cmb_println(print_info[PRINT_MMAR], regs.mmar);\n                }\n            }\n        }\n        /* Bus Fault */\n        if (regs.bfsr.value) {\n            if (regs.bfsr.bits.IBUSERR) {\n                cmb_println(print_info[PRINT_BFSR_IBUSERR]);\n            }\n            if (regs.bfsr.bits.PRECISERR) {\n                cmb_println(print_info[PRINT_BFSR_PRECISERR]);\n            }\n            if (regs.bfsr.bits.IMPREISERR) {\n                cmb_println(print_info[PRINT_BFSR_IMPREISERR]);\n            }\n            if (regs.bfsr.bits.UNSTKERR) {\n                cmb_println(print_info[PRINT_BFSR_UNSTKERR]);\n            }\n            if (regs.bfsr.bits.STKERR) {\n                cmb_println(print_info[PRINT_BFSR_STKERR]);\n            }\n\n#if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7)\n            if (regs.bfsr.bits.LSPERR) {\n                cmb_println(print_info[PRINT_BFSR_LSPERR]);\n            }\n#endif\n\n            if (regs.bfsr.bits.BFARVALID) {\n                if (regs.bfsr.bits.PRECISERR) {\n                    cmb_println(print_info[PRINT_BFAR], regs.bfar);\n                }\n            }\n\n        }\n        /* Usage Fault */\n        if (regs.ufsr.value) {\n            if (regs.ufsr.bits.UNDEFINSTR) {\n                cmb_println(print_info[PRINT_UFSR_UNDEFINSTR]);\n            }\n            if (regs.ufsr.bits.INVSTATE) {\n                cmb_println(print_info[PRINT_UFSR_INVSTATE]);\n            }\n            if (regs.ufsr.bits.INVPC) {\n                cmb_println(print_info[PRINT_UFSR_INVPC]);\n            }\n            if (regs.ufsr.bits.NOCP) {\n                cmb_println(print_info[PRINT_UFSR_NOCP]);\n            }\n            if (regs.ufsr.bits.UNALIGNED) {\n                cmb_println(print_info[PRINT_UFSR_UNALIGNED]);\n            }\n            if (regs.ufsr.bits.DIVBYZERO0) {\n                cmb_println(print_info[PRINT_UFSR_DIVBYZERO0]);\n            }\n        }\n    }\n    /* Debug Fault */\n    if (regs.hfsr.bits.DEBUGEVT) {\n        if (regs.dfsr.value) {\n            if (regs.dfsr.bits.HALTED) {\n                cmb_println(print_info[PRINT_DFSR_HALTED]);\n            }\n            if (regs.dfsr.bits.BKPT) {\n                cmb_println(print_info[PRINT_DFSR_BKPT]);\n            }\n            if (regs.dfsr.bits.DWTTRAP) {\n                cmb_println(print_info[PRINT_DFSR_DWTTRAP]);\n            }\n            if (regs.dfsr.bits.VCATCH) {\n                cmb_println(print_info[PRINT_DFSR_VCATCH]);\n            }\n            if (regs.dfsr.bits.EXTERNAL) {\n                cmb_println(print_info[PRINT_DFSR_EXTERNAL]);\n            }\n        }\n    }\n}\n#endif /* (CMB_CPU_PLATFORM_TYPE != CMB_CPU_ARM_CORTEX_M0) */\n\n#if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7)\nstatic uint32_t statck_del_fpu_regs(uint32_t fault_handler_lr, uint32_t sp) {\n    statck_has_fpu_regs = (fault_handler_lr & (1UL << 4)) == 0 ? true : false;\n\n    /* the stack has S0~S15 and FPSCR registers when statck_has_fpu_regs is true, double word align */\n    return statck_has_fpu_regs == true ? sp + sizeof(size_t) * 18 : sp;\n}\n#endif\n\n/**\n * backtrace for fault\n * @note only call once\n *\n * @param fault_handler_lr the LR register value on fault handler\n * @param fault_handler_sp the stack pointer on fault handler\n */\nvoid cm_backtrace_fault(uint32_t fault_handler_lr, uint32_t fault_handler_sp) {\n    uint32_t stack_pointer = fault_handler_sp, saved_regs_addr = stack_pointer;\n    const char *regs_name[] = { \"R0 \", \"R1 \", \"R2 \", \"R3 \", \"R12\", \"LR \", \"PC \", \"PSR\" };\n\n#ifdef CMB_USING_DUMP_STACK_INFO\n    uint32_t stack_start_addr = main_stack_start_addr;\n    size_t stack_size = main_stack_size;\n#endif\n\n    CMB_ASSERT(init_ok);\n    /* only call once */\n    CMB_ASSERT(!on_fault);\n\n    on_fault = true;\n\n    cmb_println(\"\");\n    cm_backtrace_firmware_info();\n\n#ifdef CMB_USING_OS_PLATFORM\n    on_thread_before_fault = fault_handler_lr & (1UL << 2);\n    /* check which stack was used before (MSP or PSP) */\n    if (on_thread_before_fault) {\n        cmb_println(print_info[PRINT_FAULT_ON_THREAD], get_cur_thread_name() != NULL ? get_cur_thread_name() : \"NO_NAME\");\n        saved_regs_addr = stack_pointer = cmb_get_psp();\n\n#ifdef CMB_USING_DUMP_STACK_INFO\n        get_cur_thread_stack_info(stack_pointer, &stack_start_addr, &stack_size);\n#endif /* CMB_USING_DUMP_STACK_INFO */\n\n    } else {\n        cmb_println(print_info[PRINT_FAULT_ON_HANDLER]);\n    }\n#else\n    /* bare metal(no OS) environment */\n    cmb_println(print_info[PRINT_FAULT_ON_HANDLER]);\n#endif /* CMB_USING_OS_PLATFORM */\n\n    /* delete saved R0~R3, R12, LR,PC,xPSR registers space */\n    stack_pointer += sizeof(size_t) * 8;\n\n#if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7)\n    stack_pointer = statck_del_fpu_regs(fault_handler_lr, stack_pointer);\n#endif /* (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7) */\n\n#ifdef CMB_USING_DUMP_STACK_INFO\n    /* check stack overflow */\n    if (stack_pointer < stack_start_addr || stack_pointer > stack_start_addr + stack_size) {\n        stack_is_overflow = true;\n    }\n    /* dump stack information */\n    dump_stack(stack_start_addr, stack_size, (uint32_t *) stack_pointer);\n#endif /* CMB_USING_DUMP_STACK_INFO */\n\n    /* the stack frame may be get failed when it is overflow  */\n    if (!stack_is_overflow) {\n        /* dump register */\n        cmb_println(print_info[PRINT_REGS_TITLE]);\n\n        regs.saved.r0        = ((uint32_t *)saved_regs_addr)[0];  // Register R0\n        regs.saved.r1        = ((uint32_t *)saved_regs_addr)[1];  // Register R1\n        regs.saved.r2        = ((uint32_t *)saved_regs_addr)[2];  // Register R2\n        regs.saved.r3        = ((uint32_t *)saved_regs_addr)[3];  // Register R3\n        regs.saved.r12       = ((uint32_t *)saved_regs_addr)[4];  // Register R12\n        regs.saved.lr        = ((uint32_t *)saved_regs_addr)[5];  // Link register LR\n        regs.saved.pc        = ((uint32_t *)saved_regs_addr)[6];  // Program counter PC\n        regs.saved.psr.value = ((uint32_t *)saved_regs_addr)[7];  // Program status word PSR\n\n        cmb_println(\"  %s: %08x  %s: %08x  %s: %08x  %s: %08x\", regs_name[0], regs.saved.r0,\n                                                                regs_name[1], regs.saved.r1,\n                                                                regs_name[2], regs.saved.r2,\n                                                                regs_name[3], regs.saved.r3);\n        cmb_println(\"  %s: %08x  %s: %08x  %s: %08x  %s: %08x\", regs_name[4], regs.saved.r12,\n                                                                regs_name[5], regs.saved.lr,\n                                                                regs_name[6], regs.saved.pc,\n                                                                regs_name[7], regs.saved.psr.value);\n        cmb_println(\"==============================================================\");\n    }\n\n    /* the Cortex-M0 is not support fault diagnosis */\n#if (CMB_CPU_PLATFORM_TYPE != CMB_CPU_ARM_CORTEX_M0)\n    regs.syshndctrl.value = CMB_SYSHND_CTRL;  // System Handler Control and State Register\n    regs.mfsr.value       = CMB_NVIC_MFSR;    // Memory Fault Status Register\n    regs.mmar             = CMB_NVIC_MMAR;    // Memory Management Fault Address Register\n    regs.bfsr.value       = CMB_NVIC_BFSR;    // Bus Fault Status Register\n    regs.bfar             = CMB_NVIC_BFAR;    // Bus Fault Manage Address Register\n    regs.ufsr.value       = CMB_NVIC_UFSR;    // Usage Fault Status Register\n    regs.hfsr.value       = CMB_NVIC_HFSR;    // Hard Fault Status Register\n    regs.dfsr.value       = CMB_NVIC_DFSR;    // Debug Fault Status Register\n    regs.afsr             = CMB_NVIC_AFSR;    // Auxiliary Fault Status Register\n\n    fault_diagnosis();\n#endif\n\n    print_call_stack(stack_pointer);\n}\n"
}