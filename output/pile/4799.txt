{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "4799",
    "text": "Q:\n\nPlease explain how this wake-on-LAN script works\n\nI found this PowerShell code on a blog a couple months ago. It sends wake-on-LAN signals to the MAC address of your choice without using external programs. I commented on the blog post and asked the author to describe the logic behind the script because I was curious about it. I went back to the blog post at a later date to see if the author replied to my comment. I was surprised to see that I was redirected to a page where the author said he lost his blog due to a crash. I can't remember the details of it, but I don't think I have that blog bookmarked anymore.\nSo now I would like to request to have the brilliant minds at Stack Overflow look at this code and explain its logic to me. A comment for each line would be fantastic. I'm quite curious to know how this works. It appears to be more robust than other scripts that I've found in that it works across subnets. I don't know much about networking, though.\nOne of the things I'm most curious about is the for loop at the end. Why send the signal multiple times? And why on different ports? But I really would like to know the logic behind the entire script.\nThe code:\nparam (\n    $targetMac,\n    $network = [net.ipaddress]::Broadcast,\n    $subnet = [net.ipaddress]::Broadcast\n)\ntry {\n    if($network.gettype().equals([string])) {\n        $network = [net.ipaddress]::Parse($network);\n    }\n    if($subnet.gettype().equals([string])) {\n        $subnet = [net.ipaddress]::Parse($subnet);\n    }\n    $broadcast = new-object net.ipaddress (([system.net.ipaddress]::parse(\"255.255.255.255\").address -bxor $subnet.address -bor $network.address))\n\n    $mac = [Net.NetworkInformation.PhysicalAddress]::Parse($targetMac.toupper().replace(\".\",\"\"))\n\n    $u = New-Object net.sockets.udpclient\n    $ep = New-Object net.ipendpoint $broadcast, 0\n    $ep2 = New-Object net.ipendpoint $broadcast, 7\n    $ep3 = New-Object net.ipendpoint $broadcast, 9\n\n    $payload = [byte[]]@(255,255,255, 255,255,255);\n    $payload += ($mac.GetAddressBytes()*16)\n\n    for($i = 0; $i -lt 10; $i++) {\n        $u.Send($payload, $payload.Length, $ep) | Out-Null\n        $u.Send($payload, $payload.Length, $ep2) | Out-Null\n        $u.Send($payload, $payload.Length, $ep3) | Out-Null\n        sleep 1;\n    }\n} catch {\n    $Error | Write-Error;\n}\n\nA:\n\n#These are the parameters to the script. The only mandatory param here is the mac address\n#[net.ipaddress]::Broadcast will resolve to something like 255.255.255.255\nparam (\n    $targetMac,\n    $network = [net.ipaddress]::Broadcast,\n    $subnet = [net.ipaddress]::Broadcast\n)\n\n#We start the try, catch error handling here.\n#if something in try block fails, the catch block will write the error\ntry {\n\n#This will evaludate to False. Hence, $network will have whatever was passed through params or the default value\n#in this case the default value is 255.255.255.255\n    if($network.gettype().equals([string])) {\n        $network = [net.ipaddress]::Parse($network);\n    }\n\n#This will evaludate to False. Hence, $network will have whatever was passed through params or the default value\n#in this case the default value is 255.255.255.255    \n    if($subnet.gettype().equals([string])) {\n        $subnet = [net.ipaddress]::Parse($subnet);\n    }\n\n    #Not sure if this is really required here. But, assuming that the default value for both $network and $subet is 255.255.255.255,\n    #this will result in $broadcast set to 255.255.255.255\n    $broadcast = new-object net.ipaddress (([system.net.ipaddress]::parse(\"255.255.255.255\").address -bxor $subnet.address -bor $network.address))\n\n#This again assumes that you had given . as the delimeter in MAC address and removes that from MAC address    \n    $mac = [Net.NetworkInformation.PhysicalAddress]::Parse($targetMac.toupper().replace(\".\",\"\"))\n\n#Create a new object of type net.sockets.udpclient\n    $u = New-Object net.sockets.udpclient\n\n#WOL magic packet can be sent on port 0, 7, or 9    \n#Create a end point for the broadcast address at port 0    \n    $ep = New-Object net.ipendpoint $broadcast, 0\n\n#Create a end point for the broadcast address at port 7    \n    $ep2 = New-Object net.ipendpoint $broadcast, 7\n\n#Create a end point for the broadcast address at port 9    \n    $ep3 = New-Object net.ipendpoint $broadcast, 9\n\n#Create a payload packet\n#First, create a byte array\n    $payload = [byte[]]@(255,255,255, 255,255,255);\n\n#add the mac address to the above byte array    \n    $payload += ($mac.GetAddressBytes()*16)\n\n#Send 10 magic packets for each port number or end point created above.\n#one is more than enough. If everything is congfigured properly\n    for($i = 0; $i -lt 10; $i++) {\n        $u.Send($payload, $payload.Length, $ep) | Out-Null\n        $u.Send($payload, $payload.Length, $ep2) | Out-Null\n        $u.Send($payload, $payload.Length, $ep3) | Out-Null\n        sleep 1;\n    }\n} catch {\n#catch block catches any error from try block\n    $Error | Write-Error;\n}\n\n"
}