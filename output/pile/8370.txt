{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains Here are some."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "8370",
    "text": "/*\n * Maxim MAX77620 MFD Driver\n *\n * Copyright (C) 2016 NVIDIA CORPORATION. All rights reserved.\n *\n * Author:\n *\tLaxman Dewangan <ldewangan@nvidia.com>\n *\tChaitanya Bandi <bandik@nvidia.com>\n *\tMallikarjun Kasoju <mkasoju@nvidia.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n/****************** Teminology used in driver ********************\n * Here are some terminology used from datasheet for quick reference:\n * Flexible Power Sequence (FPS):\n * The Flexible Power Sequencer (FPS) allows each regulator to power up under\n * hardware or software control. Additionally, each regulator can power on\n * independently or among a group of other regulators with an adjustable\n * power-up and power-down delays (sequencing). GPIO1, GPIO2, and GPIO3 can\n * be programmed to be part of a sequence allowing external regulators to be\n * sequenced along with internal regulators. 32KHz clock can be programmed to\n * be part of a sequence.\n * There is 3 FPS confguration registers and all resources are configured to\n * any of these FPS or no FPS.\n */\n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/max77620.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstatic struct resource gpio_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_TOP_GPIO),\n};\n\nstatic struct resource power_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_LBT_MBATLOW),\n};\n\nstatic struct resource rtc_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_TOP_RTC),\n};\n\nstatic struct resource thermal_resources[] = {\n\tDEFINE_RES_IRQ(MAX77620_IRQ_LBT_TJALRM1),\n\tDEFINE_RES_IRQ(MAX77620_IRQ_LBT_TJALRM2),\n};\n\nstatic const struct regmap_irq max77620_top_irqs[] = {\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_GLBL, 0, MAX77620_IRQ_TOP_GLBL_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_SD, 0, MAX77620_IRQ_TOP_SD_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_LDO, 0, MAX77620_IRQ_TOP_LDO_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_GPIO, 0, MAX77620_IRQ_TOP_GPIO_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_RTC, 0, MAX77620_IRQ_TOP_RTC_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_32K, 0, MAX77620_IRQ_TOP_32K_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_TOP_ONOFF, 0, MAX77620_IRQ_TOP_ONOFF_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_LBT_MBATLOW, 1, MAX77620_IRQ_LBM_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_LBT_TJALRM1, 1, MAX77620_IRQ_TJALRM1_MASK),\n\tREGMAP_IRQ_REG(MAX77620_IRQ_LBT_TJALRM2, 1, MAX77620_IRQ_TJALRM2_MASK),\n};\n\nstatic const struct mfd_cell max77620_children[] = {\n\t{ .name = \"max77620-pinctrl\", },\n\t{ .name = \"max77620-clock\", },\n\t{ .name = \"max77620-pmic\", },\n\t{ .name = \"max77620-watchdog\", },\n\t{\n\t\t.name = \"max77620-gpio\",\n\t\t.resources = gpio_resources,\n\t\t.num_resources = ARRAY_SIZE(gpio_resources),\n\t}, {\n\t\t.name = \"max77620-rtc\",\n\t\t.resources = rtc_resources,\n\t\t.num_resources = ARRAY_SIZE(rtc_resources),\n\t}, {\n\t\t.name = \"max77620-power\",\n\t\t.resources = power_resources,\n\t\t.num_resources = ARRAY_SIZE(power_resources),\n\t}, {\n\t\t.name = \"max77620-thermal\",\n\t\t.resources = thermal_resources,\n\t\t.num_resources = ARRAY_SIZE(thermal_resources),\n\t},\n};\n\nstatic const struct mfd_cell max20024_children[] = {\n\t{ .name = \"max20024-pinctrl\", },\n\t{ .name = \"max77620-clock\", },\n\t{ .name = \"max20024-pmic\", },\n\t{ .name = \"max77620-watchdog\", },\n\t{\n\t\t.name = \"max77620-gpio\",\n\t\t.resources = gpio_resources,\n\t\t.num_resources = ARRAY_SIZE(gpio_resources),\n\t}, {\n\t\t.name = \"max77620-rtc\",\n\t\t.resources = rtc_resources,\n\t\t.num_resources = ARRAY_SIZE(rtc_resources),\n\t}, {\n\t\t.name = \"max20024-power\",\n\t\t.resources = power_resources,\n\t\t.num_resources = ARRAY_SIZE(power_resources),\n\t},\n};\n\nstatic struct regmap_irq_chip max77620_top_irq_chip = {\n\t.name = \"max77620-top\",\n\t.irqs = max77620_top_irqs,\n\t.num_irqs = ARRAY_SIZE(max77620_top_irqs),\n\t.num_regs = 2,\n\t.status_base = MAX77620_REG_IRQTOP,\n\t.mask_base = MAX77620_REG_IRQTOPM,\n};\n\nstatic const struct regmap_range max77620_readable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_DVSSD4),\n};\n\nstatic const struct regmap_access_table max77620_readable_table = {\n\t.yes_ranges = max77620_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77620_readable_ranges),\n};\n\nstatic const struct regmap_range max20024_readable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_DVSSD4),\n\tregmap_reg_range(MAX20024_REG_MAX_ADD, MAX20024_REG_MAX_ADD),\n};\n\nstatic const struct regmap_access_table max20024_readable_table = {\n\t.yes_ranges = max20024_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max20024_readable_ranges),\n};\n\nstatic const struct regmap_range max77620_writable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_CNFGGLBL1, MAX77620_REG_DVSSD4),\n};\n\nstatic const struct regmap_access_table max77620_writable_table = {\n\t.yes_ranges = max77620_writable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77620_writable_ranges),\n};\n\nstatic const struct regmap_range max77620_cacheable_ranges[] = {\n\tregmap_reg_range(MAX77620_REG_SD0_CFG, MAX77620_REG_LDO_CFG3),\n\tregmap_reg_range(MAX77620_REG_FPS_CFG0, MAX77620_REG_FPS_SD3),\n};\n\nstatic const struct regmap_access_table max77620_volatile_table = {\n\t.no_ranges = max77620_cacheable_ranges,\n\t.n_no_ranges = ARRAY_SIZE(max77620_cacheable_ranges),\n};\n\nstatic const struct regmap_config max77620_regmap_config = {\n\t.name = \"power-slave\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX77620_REG_DVSSD4 + 1,\n\t.cache_type = REGCACHE_RBTREE,\n\t.rd_table = &max77620_readable_table,\n\t.wr_table = &max77620_writable_table,\n\t.volatile_table = &max77620_volatile_table,\n};\n\nstatic const struct regmap_config max20024_regmap_config = {\n\t.name = \"power-slave\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX20024_REG_MAX_ADD + 1,\n\t.cache_type = REGCACHE_RBTREE,\n\t.rd_table = &max20024_readable_table,\n\t.wr_table = &max77620_writable_table,\n\t.volatile_table = &max77620_volatile_table,\n};\n\n/* max77620_get_fps_period_reg_value:  Get FPS bit field value from\n *\t\t\t\t       requested periods.\n * MAX77620 supports the FPS period of 40, 80, 160, 320, 540, 1280, 2560\n * and 5120 microseconds. MAX20024 supports the FPS period of 20, 40, 80,\n * 160, 320, 540, 1280 and 2560 microseconds.\n * The FPS register has 3 bits field to set the FPS period as\n * bits\t\tmax77620\t\tmax20024\n * 000\t\t40\t\t\t20\n * 001\t\t80\t\t\t40\n * :::\n*/\nstatic int max77620_get_fps_period_reg_value(struct max77620_chip *chip,\n\t\t\t\t\t     int tperiod)\n{\n\tint fps_min_period;\n\tint i;\n\n\tswitch (chip->chip_id) {\n\tcase MAX20024:\n\t\tfps_min_period = MAX20024_FPS_PERIOD_MIN_US;\n\t\tbreak;\n\tcase MAX77620:\n\t\tfps_min_period = MAX77620_FPS_PERIOD_MIN_US;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 7; i++) {\n\t\tif (fps_min_period >= tperiod)\n\t\t\treturn i;\n\t\tfps_min_period *= 2;\n\t}\n\n\treturn i;\n}\n\n/* max77620_config_fps: Configure FPS configuration registers\n *\t\t\tbased on platform specific information.\n */\nstatic int max77620_config_fps(struct max77620_chip *chip,\n\t\t\t       struct device_node *fps_np)\n{\n\tstruct device *dev = chip->dev;\n\tunsigned int mask = 0, config = 0;\n\tu32 fps_max_period;\n\tu32 param_val;\n\tint tperiod, fps_id;\n\tint ret;\n\tchar fps_name[10];\n\n\tswitch (chip->chip_id) {\n\tcase MAX20024:\n\t\tfps_max_period = MAX20024_FPS_PERIOD_MAX_US;\n\t\tbreak;\n\tcase MAX77620:\n\t\tfps_max_period = MAX77620_FPS_PERIOD_MAX_US;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (fps_id = 0; fps_id < MAX77620_FPS_COUNT; fps_id++) {\n\t\tsprintf(fps_name, \"fps%d\", fps_id);\n\t\tif (!strcmp(fps_np->name, fps_name))\n\t\t\tbreak;\n\t}\n\n\tif (fps_id == MAX77620_FPS_COUNT) {\n\t\tdev_err(dev, \"FPS node name %s is not valid\\n\", fps_np->name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(fps_np, \"maxim,shutdown-fps-time-period-us\",\n\t\t\t\t   &param_val);\n\tif (!ret) {\n\t\tmask |= MAX77620_FPS_TIME_PERIOD_MASK;\n\t\tchip->shutdown_fps_period[fps_id] = min(param_val,\n\t\t\t\t\t\t\tfps_max_period);\n\t\ttperiod = max77620_get_fps_period_reg_value(chip,\n\t\t\t\tchip->shutdown_fps_period[fps_id]);\n\t\tconfig |= tperiod << MAX77620_FPS_TIME_PERIOD_SHIFT;\n\t}\n\n\tret = of_property_read_u32(fps_np, \"maxim,suspend-fps-time-period-us\",\n\t\t\t\t   &param_val);\n\tif (!ret)\n\t\tchip->suspend_fps_period[fps_id] = min(param_val,\n\t\t\t\t\t\t       fps_max_period);\n\n\tret = of_property_read_u32(fps_np, \"maxim,fps-event-source\",\n\t\t\t\t   &param_val);\n\tif (!ret) {\n\t\tif (param_val > 2) {\n\t\t\tdev_err(dev, \"FPS%d event-source invalid\\n\", fps_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmask |= MAX77620_FPS_EN_SRC_MASK;\n\t\tconfig |= param_val << MAX77620_FPS_EN_SRC_SHIFT;\n\t\tif (param_val == 2) {\n\t\t\tmask |= MAX77620_FPS_ENFPS_SW_MASK;\n\t\t\tconfig |= MAX77620_FPS_ENFPS_SW;\n\t\t}\n\t}\n\n\tif (!chip->sleep_enable && !chip->enable_global_lpm) {\n\t\tret = of_property_read_u32(fps_np,\n\t\t\t\t\"maxim,device-state-on-disabled-event\",\n\t\t\t\t&param_val);\n\t\tif (!ret) {\n\t\t\tif (param_val == 0)\n\t\t\t\tchip->sleep_enable = true;\n\t\t\telse if (param_val == 1)\n\t\t\t\tchip->enable_global_lpm = true;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_FPS_CFG0 + fps_id,\n\t\t\t\t mask, config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update FPS CFG: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_initialise_fps(struct max77620_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tstruct device_node *fps_np, *fps_child;\n\tu8 config;\n\tint fps_id;\n\tint ret;\n\n\tfor (fps_id = 0; fps_id < MAX77620_FPS_COUNT; fps_id++) {\n\t\tchip->shutdown_fps_period[fps_id] = -1;\n\t\tchip->suspend_fps_period[fps_id] = -1;\n\t}\n\n\tfps_np = of_get_child_by_name(dev->of_node, \"fps\");\n\tif (!fps_np)\n\t\tgoto skip_fps;\n\n\tfor_each_child_of_node(fps_np, fps_child) {\n\t\tret = max77620_config_fps(chip, fps_child);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tconfig = chip->enable_global_lpm ? MAX77620_ONOFFCNFG2_SLP_LPM_MSK : 0;\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_SLP_LPM_MSK, config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update SLP_LPM: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nskip_fps:\n\t/* Enable wake on EN0 pin */\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update WK_EN0: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* For MAX20024, SLPEN will be POR reset if CLRSE is b11 */\n\tif ((chip->chip_id == MAX20024) && chip->sleep_enable) {\n\t\tconfig = MAX77620_ONOFFCNFG1_SLPEN | MAX20024_ONOFFCNFG1_CLRSE;\n\t\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG1,\n\t\t\t\t\t config, config);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to update SLPEN: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_read_es_version(struct max77620_chip *chip)\n{\n\tunsigned int val;\n\tu8 cid_val[6];\n\tint i;\n\tint ret;\n\n\tfor (i = MAX77620_REG_CID0; i <= MAX77620_REG_CID5; i++) {\n\t\tret = regmap_read(chip->rmap, i, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"Failed to read CID: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(chip->dev, \"CID%d: 0x%02x\\n\",\n\t\t\ti - MAX77620_REG_CID0, val);\n\t\tcid_val[i - MAX77620_REG_CID0] = val;\n\t}\n\n\t/* CID4 is OTP Version  and CID5 is ES version */\n\tdev_info(chip->dev, \"PMIC Version OTP:0x%02X and ES:0x%X\\n\",\n\t\t cid_val[4], MAX77620_CID5_DIDM(cid_val[5]));\n\n\treturn ret;\n}\n\nstatic int max77620_probe(struct i2c_client *client,\n\t\t\t  const struct i2c_device_id *id)\n{\n\tconst struct regmap_config *rmap_config;\n\tstruct max77620_chip *chip;\n\tconst struct mfd_cell *mfd_cells;\n\tint n_mfd_cells;\n\tint ret;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\tchip->dev = &client->dev;\n\tchip->irq_base = -1;\n\tchip->chip_irq = client->irq;\n\tchip->chip_id = (enum max77620_chip_id)id->driver_data;\n\n\tswitch (chip->chip_id) {\n\tcase MAX77620:\n\t\tmfd_cells = max77620_children;\n\t\tn_mfd_cells = ARRAY_SIZE(max77620_children);\n\t\trmap_config = &max77620_regmap_config;\n\t\tbreak;\n\tcase MAX20024:\n\t\tmfd_cells = max20024_children;\n\t\tn_mfd_cells = ARRAY_SIZE(max20024_children);\n\t\trmap_config = &max20024_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev, \"ChipID is invalid %d\\n\", chip->chip_id);\n\t\treturn -EINVAL;\n\t}\n\n\tchip->rmap = devm_regmap_init_i2c(client, rmap_config);\n\tif (IS_ERR(chip->rmap)) {\n\t\tret = PTR_ERR(chip->rmap);\n\t\tdev_err(chip->dev, \"Failed to intialise regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = max77620_read_es_version(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_regmap_add_irq_chip(chip->dev, chip->rmap, client->irq,\n\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t       chip->irq_base, &max77620_top_irq_chip,\n\t\t\t\t       &chip->top_irq_data);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to add regmap irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = max77620_initialise_fps(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =  devm_mfd_add_devices(chip->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t    mfd_cells, n_mfd_cells, NULL, 0,\n\t\t\t\t    regmap_irq_get_domain(chip->top_irq_data));\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to add MFD children: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int max77620_set_fps_period(struct max77620_chip *chip,\n\t\t\t\t   int fps_id, int time_period)\n{\n\tint period = max77620_get_fps_period_reg_value(chip, time_period);\n\tint ret;\n\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_FPS_CFG0 + fps_id,\n\t\t\t\t MAX77620_FPS_TIME_PERIOD_MASK,\n\t\t\t\t period << MAX77620_FPS_TIME_PERIOD_SHIFT);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to update FPS period: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77620_i2c_suspend(struct device *dev)\n{\n\tstruct max77620_chip *chip = dev_get_drvdata(dev);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tunsigned int config;\n\tint fps;\n\tint ret;\n\n\tfor (fps = 0; fps < MAX77620_FPS_COUNT; fps++) {\n\t\tif (chip->suspend_fps_period[fps] < 0)\n\t\t\tcontinue;\n\n\t\tret = max77620_set_fps_period(chip, fps,\n\t\t\t\t\t      chip->suspend_fps_period[fps]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * For MAX20024: No need to configure SLPEN on suspend as\n\t * it will be configured on Init.\n\t */\n\tif (chip->chip_id == MAX20024)\n\t\tgoto out;\n\n\tconfig = (chip->sleep_enable) ? MAX77620_ONOFFCNFG1_SLPEN : 0;\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG1,\n\t\t\t\t MAX77620_ONOFFCNFG1_SLPEN,\n\t\t\t\t config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to configure sleep in suspend: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t/* Disable WK_EN0 */\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to configure WK_EN in suspend: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nout:\n\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int max77620_i2c_resume(struct device *dev)\n{\n\tstruct max77620_chip *chip = dev_get_drvdata(dev);\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint ret;\n\tint fps;\n\n\tfor (fps = 0; fps < MAX77620_FPS_COUNT; fps++) {\n\t\tif (chip->shutdown_fps_period[fps] < 0)\n\t\t\tcontinue;\n\n\t\tret = max77620_set_fps_period(chip, fps,\n\t\t\t\t\t      chip->shutdown_fps_period[fps]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * For MAX20024: No need to configure WKEN0 on resume as\n\t * it is configured on Init.\n\t */\n\tif (chip->chip_id == MAX20024)\n\t\tgoto out;\n\n\t/* Enable WK_EN0 */\n\tret = regmap_update_bits(chip->rmap, MAX77620_REG_ONOFFCNFG2,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0,\n\t\t\t\t MAX77620_ONOFFCNFG2_WK_EN0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to configure WK_EN0 n resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nout:\n\tenable_irq(client->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct i2c_device_id max77620_id[] = {\n\t{\"max77620\", MAX77620},\n\t{\"max20024\", MAX20024},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, max77620_id);\n\nstatic const struct dev_pm_ops max77620_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(max77620_i2c_suspend, max77620_i2c_resume)\n};\n\nstatic struct i2c_driver max77620_driver = {\n\t.driver = {\n\t\t.name = \"max77620\",\n\t\t.pm = &max77620_pm_ops,\n\t},\n\t.probe = max77620_probe,\n\t.id_table = max77620_id,\n};\n\nmodule_i2c_driver(max77620_driver);\n\nMODULE_DESCRIPTION(\"MAX77620/MAX20024 Multi Function Device Core Driver\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_AUTHOR(\"Chaitanya Bandi <bandik@nvidia.com>\");\nMODULE_AUTHOR(\"Mallikarjun Kasoju <mkasoju@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n"
}