{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": true,
            "reason": "Text contains SAT."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": true,
            "reason": "Text contains ['SAT', 'SAT']."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9683",
    "text": "Q:\n\nReduce 0-1 knapsack prob. to a SAT prob\n\nIs there any way to reduce the 0-1 knapsack problem to a SAT problem in Conjunctive Norm Form?\n\nA:\n\nYou could always work out the digital circuits necessary to implement adders and comparators and then turn the result of that into conjunctive normal form. You can get circuits into CNF form without expanding them exponentially by making up intermediate variables which represent the outputs of small sections of circuit.\nEach node of a circuit amounts to a=f(b, c) where a is the output, b and c the input, and f is some simple function like & or |. You can create a CNF function that is true only when a really is the result of f(b, c) and it can't be too unwieldy, because it is a function on only three variables.\nYou can rewrite any circuit into a large number of terms of the form a=f(b, c) and all you have to do with the CNF versions of these is to AND them all together. Assuming you want to solve for the output being true, you then just stick on the output variable as the final component of that big AND.\n\n"
}