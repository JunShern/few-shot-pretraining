{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "1236",
    "text": "Q:\n\nIs there an inbuilt function to expand ipv6 addresses?\n\nI'm working on a project where I need to expand IPv6 addresses. Is there an inbuilt function in Go?\nWhat I'm currently doing is\nipv6 := \"fe80:01::af0\"\naddr := net.ParseIP(ipv6)\nfmt.Println(addr.String())\n\nbut this still prints\nfe80:01::af0\n\nWhat I actually need is\nfe80:0001:0000:0000:0000:0000:0000:0af0\n\nA:\n\nThere's nothing in the standard library to do this, but it's easy to write your own function. One possible approach (of many):\nfunc FullIPv6(ip net.IP) string {\n    dst := make([]byte, hex.EncodedLen(len(ip)))\n    _ = hex.Encode(dst, ip)\n    return string(dst[0:4]) + \":\" +\n        string(dst[4:8]) + \":\" +\n        string(dst[8:12]) + \":\" +\n        string(dst[12:16]) + \":\" +\n        string(dst[16:20]) + \":\" +\n        string(dst[20:24]) + \":\" +\n        string(dst[24:28]) + \":\" +\n        string(dst[28:])\n}\n\nPlayground\n\n"
}