{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9890",
    "text": "Q:\n\nConvert from and to messagepack\n\nSo I'm trying to get the string representation of a JSON message in Golang. I just want to receive the messagepack encoded JSON, modify some values and send it back.\nI haven't found an easy way to do it. Most of the times, I can't know in advance what is the structure of the JSON (apart from having JSON structure), so want I want to do is to receive the binary message. Decode it as a JSON, print it as a string to the standard output, modify the content, convert it to MessagePack again and send it back.\nI've been looking at these two packages, but I don't know how to properly use them for a simple task like that:\n\nhttps://godoc.org/github.com/vmihailenco/msgpack\nhttps://godoc.org/github.com/ugorji/go/codec\n\nSo I will receive something like this:\nDF 00 00 00 01 A7 6D 65 73 73 61 67 65 A3 48 69 21\n\nI want to print this:\n{\"message\": \"Hi!\"}\n\nModify the \"Hi!\":\n{\"message\": \"Hello Sir!\"}\n\nSend it as messagepack:\nDF 00 00 00 01 A7 6D 65 73 73 61 67 65 AA 48 65 6C 6C 6F 20 53 69 72 21\n\nCurrent Python code I'm trying to port to Golang:\ndef decode_msgpack(jsonData):\n    packedStuff = 0\n    for key in jsonData.keys():\n        if type(jsonData[key]) is bytes:\n            packedStuff += 1\n            try:\n                jsonData[key] = umsgpack.unpackb(jsonData[key])\n            except umsgpack.InvalidStringException:\n                try:\n                    jsonData[key] = umsgpack.unpackb(jsonData[key], allow_invalid_utf8=True)\n                except umsgpack.InsufficientDataException:\n                    print(\"[!] InsufficientDataException\")\n                    jsonData[key] = base64.b64encode(jsonData[key]).decode('utf-8')\n                else:\n                    jsonData[key] = base64.b64encode(jsonData[key]).decode('utf-8')\n\n    if packedStuff > 0:\n        return decode_msgpack(jsonData)\n    else:\n        return jsonData\n\nA:\n\nUsing the codec library and assuming that {\"message\": \"Hi\"} is a map, the code would look something like this.\npackage main\n\nimport (\n        \"fmt\"\n\n        \"github.com/ugorji/go/codec\"\n)\n\nfunc main() {\n        var data []byte\n        original := map[string]string{\"message\": \"Hi!\"}\n        enc := codec.NewEncoderBytes(&data, new(codec.MsgpackHandle))\n        if err := enc.Encode(&original); err != nil {\n                panic(err)\n        }\n        fmt.Printf(\"Encoded: \")\n        for _, b := range data {\n                fmt.Printf(\"%X \", b)\n        }\n        fmt.Printf(\"\\n\")\n        decoded := make(map[string]string)\n        dec := codec.NewDecoderBytes(data, new(codec.MsgpackHandle))\n        if err := dec.Decode(&decoded); err != nil {\n                panic(err)\n        }\n        fmt.Printf(\"Decoded: %v\\n\", decoded)\n        decoded[\"message\"] = \"Hello Sir!\"\n        /* reinitialize the encoder */\n        enc = codec.NewEncoderBytes(&data, new(codec.MsgpackHandle))\n        if err := enc.Encode(&decoded); err != nil {\n                panic(err)\n        }\n        fmt.Printf(\"Encoded: \")\n        for _, b := range data {\n                fmt.Printf(\"%X \", b)\n        }\n        fmt.Printf(\"\\n\")\n}\n\nThat said, if you get {\"message\": \"Hi\"} as a JSON string, you can use codec to decode the JSON into a map, update the map and then re-encode it as msgpack.\n\n"
}