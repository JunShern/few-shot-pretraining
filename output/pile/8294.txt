{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": true,
            "reason": "Text contains GRE."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['         back to curves, because they are in a list with other (0.183)', \"   For example, consider the top of a capital `C' (this is in cmss20): (0.193)\", '/* There are four possible cases for knees, one for each of the four (0.170)']."
        }
    ],
    "doc_id": "8294",
    "text": "/* fit.c: turn a bitmap representation of a curve into a list of splines.\n    Some of the ideas, but not the code, comes from the Phoenix thesis.\n   See README for the reference.\n\n   The code was partially derived from limn.\n\n   Copyright (C) 1992 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* Def: HAVE_CONFIG_H */\n\n#include \"autotrace.h\"\n#include \"fit.h\"\n#include \"logreport.h\"\n#include \"spline.h\"\n#include \"vector.h\"\n#include \"curve.h\"\n#include \"pxl-outline.h\"\n#include \"epsilon-equal.h\"\n#include \"xstd.h\"\n#include <math.h>\n#ifndef FLT_MAX\n#include <limits.h>\n#include <float.h>\n#endif\n#ifndef FLT_MIN\n#include <limits.h>\n#include <float.h>\n#endif\n#include <string.h>\n#include <assert.h>\n\n#define SQUARE(x) ((x) * (x))\n#define CUBE(x) ((x) * (x) * (x))\n\n/* We need to manipulate lists of array indices.  */\n\ntypedef struct index_list {\n  unsigned *data;\n  unsigned length;\n} index_list_type;\n\n/* The usual accessor macros.  */\n#define GET_INDEX(i_l, n)  ((i_l).data[n])\n#define INDEX_LIST_LENGTH(i_l)  ((i_l).length)\n#define GET_LAST_INDEX(i_l)  ((i_l).data[INDEX_LIST_LENGTH (i_l) - 1])\n\nstatic void append_index(index_list_type *, unsigned);\nstatic void free_index_list(index_list_type *);\nstatic index_list_type new_index_list(void);\nstatic void remove_adjacent_corners(index_list_type *, unsigned, gboolean, at_exception_type * exception);\nstatic void change_bad_lines(spline_list_type *, fitting_opts_type *);\nstatic void filter(curve_type, fitting_opts_type *);\nstatic void find_vectors(unsigned, pixel_outline_type, vector_type *, vector_type *, unsigned);\nstatic index_list_type find_corners(pixel_outline_type, fitting_opts_type *, at_exception_type * exception);\nstatic gfloat find_error(curve_type, spline_type, unsigned *, at_exception_type * exception);\nstatic vector_type find_half_tangent(curve_type, gboolean start, unsigned *, unsigned);\nstatic void find_tangent(curve_type, gboolean, gboolean, unsigned);\nstatic spline_type fit_one_spline(curve_type, at_exception_type * exception);\nstatic spline_list_type *fit_curve(curve_type, fitting_opts_type *, at_exception_type * exception);\nstatic spline_list_type fit_curve_list(curve_list_type, fitting_opts_type *, at_distance_map *, at_exception_type * exception);\nstatic spline_list_type *fit_with_least_squares(curve_type, fitting_opts_type *, at_exception_type * exception);\nstatic spline_list_type *fit_with_line(curve_type);\nstatic void remove_knee_points(curve_type, gboolean);\nstatic void set_initial_parameter_values(curve_type);\nstatic gboolean spline_linear_enough(spline_type *, curve_type, fitting_opts_type *);\nstatic curve_list_array_type split_at_corners(pixel_outline_list_type, fitting_opts_type *, at_exception_type * exception);\nstatic at_coord real_to_int_coord(at_real_coord);\nstatic gfloat distance(at_real_coord, at_real_coord);\n\n/* Get a new set of fitting options */\nfitting_opts_type new_fitting_opts(void)\n{\n  fitting_opts_type fitting_opts;\n\n  fitting_opts.background_color = NULL;\n  fitting_opts.charcode = 0;\n  fitting_opts.color_count = 0;\n  fitting_opts.corner_always_threshold = (gfloat) 60.0;\n  fitting_opts.corner_surround = 4;\n  fitting_opts.corner_threshold = (gfloat) 100.0;\n  fitting_opts.error_threshold = (gfloat) 2.0;\n  fitting_opts.filter_iterations = 4;\n  fitting_opts.line_reversion_threshold = (gfloat) .01;\n  fitting_opts.line_threshold = (gfloat) 1.0;\n  fitting_opts.remove_adjacent_corners = FALSE;\n  fitting_opts.tangent_surround = 3;\n  fitting_opts.despeckle_level = 0;\n  fitting_opts.despeckle_tightness = 2.0;\n  fitting_opts.noise_removal = (gfloat) 0.99;\n  fitting_opts.centerline = FALSE;\n  fitting_opts.preserve_width = FALSE;\n  fitting_opts.width_weight_factor = 6.0;\n\n  return (fitting_opts);\n}\n\n/* The top-level call that transforms the list of pixels in the outlines\n   of the original character to a list of spline lists fitted to those\n   pixels.  */\n\nspline_list_array_type fitted_splines(pixel_outline_list_type pixel_outline_list, fitting_opts_type * fitting_opts, at_distance_map * dist, unsigned short width, unsigned short height, at_exception_type * exception, at_progress_func notify_progress, gpointer progress_data, at_testcancel_func test_cancel, gpointer testcancel_data)\n{\n  unsigned this_list;\n\n  spline_list_array_type char_splines = new_spline_list_array();\n  curve_list_array_type curve_array = split_at_corners(pixel_outline_list,\n                                                       fitting_opts,\n                                                       exception);\n\n  char_splines.centerline = fitting_opts->centerline;\n  char_splines.preserve_width = fitting_opts->preserve_width;\n  char_splines.width_weight_factor = fitting_opts->width_weight_factor;\n\n  if (fitting_opts->background_color)\n    char_splines.background_color = at_color_copy(fitting_opts->background_color);\n  else\n    char_splines.background_color = NULL;\n  /* Set dummy values. Real value is set in upper context. */\n  char_splines.width = width;\n  char_splines.height = height;\n\n  for (this_list = 0; this_list < CURVE_LIST_ARRAY_LENGTH(curve_array); this_list++) {\n    spline_list_type curve_list_splines;\n    curve_list_type curves = CURVE_LIST_ARRAY_ELT(curve_array, this_list);\n\n    if (notify_progress)\n      notify_progress((((gfloat) this_list) / ((gfloat) CURVE_LIST_ARRAY_LENGTH(curve_array) * (gfloat) 3.0) + (gfloat) 0.333), progress_data);\n    if (test_cancel && test_cancel(testcancel_data))\n      goto cleanup;\n\n    LOG(\"\\nFitting curve list #%u:\\n\", this_list);\n\n    curve_list_splines = fit_curve_list(curves, fitting_opts, dist, exception);\n    if (at_exception_got_fatal(exception)) {\n      if (char_splines.background_color)\n        at_color_free(char_splines.background_color);\n      goto cleanup;\n    }\n    curve_list_splines.clockwise = curves.clockwise;\n\n    memcpy(&(curve_list_splines.color), &(O_LIST_OUTLINE(pixel_outline_list, this_list).color), sizeof(at_color));\n    append_spline_list(&char_splines, curve_list_splines);\n  }\ncleanup:\n  free_curve_list_array(&curve_array, notify_progress, progress_data);\n\n  return char_splines;\n}\n\n/* Fit the list of curves CURVE_LIST to a list of splines, and return\n   it.  CURVE_LIST represents a single closed paths, e.g., either the\n   inside or outside outline of an `o'.  */\n\nstatic spline_list_type fit_curve_list(curve_list_type curve_list, fitting_opts_type * fitting_opts, at_distance_map * dist, at_exception_type * exception)\n{\n  curve_type curve;\n  unsigned this_curve, this_spline;\n  unsigned curve_list_length = CURVE_LIST_LENGTH(curve_list);\n  spline_list_type curve_list_splines = empty_spline_list();\n\n  curve_list_splines.open = curve_list.open;\n\n  /* Remove the extraneous ``knee'' points before filtering.  Since the\n     corners have already been found, we don't need to worry about\n     removing a point that should be a corner.  */\n\n  LOG(\"\\nRemoving knees:\\n\");\n  for (this_curve = 0; this_curve < curve_list_length; this_curve++) {\n    LOG(\"#%u:\", this_curve);\n    remove_knee_points(CURVE_LIST_ELT(curve_list, this_curve), CURVE_LIST_CLOCKWISE(curve_list));\n  }\n\n  if (dist != NULL) {\n    unsigned this_point;\n    unsigned height = dist->height;\n    for (this_curve = 0; this_curve < curve_list_length; this_curve++) {\n      curve = CURVE_LIST_ELT(curve_list, this_curve);\n      for (this_point = 0; this_point < CURVE_LENGTH(curve); this_point++) {\n        unsigned x, y;\n        float width, w;\n        at_real_coord *coord = &CURVE_POINT(curve, this_point);\n        x = (unsigned)(coord->x);\n        y = height - (unsigned)(coord->y) - 1;\n\n        /* Each (x, y) is a point on the skeleton of the curve, which\n           might be offset from the TRUE centerline, where the width\n           is maximal.  Therefore, use as the local line width the\n           maximum distance over the neighborhood of (x, y).  */\n        width = dist->d[y][x];\n        if (y >= 1) {\n          if ((w = dist->d[y - 1][x]) > width)\n            width = w;\n          if (x >= 1) {\n            if ((w = dist->d[y][x - 1]) > width)\n              width = w;\n            if ((w = dist->d[y - 1][x - 1]) > width)\n              width = w;\n          }\n          if (x + 1 < dist->width) {\n            if ((w = dist->d[y][x + 1]) > width)\n              width = w;\n            if ((w = dist->d[y - 1][x + 1]) > width)\n              width = w;\n          }\n        }\n        if (y + 1 < height) {\n          if ((w = dist->d[y + 1][x]) > width)\n            width = w;\n          if (x >= 1 && (w = dist->d[y + 1][x - 1]) > width)\n            width = w;\n          if (x + 1 < dist->width && (w = dist->d[y + 1][x + 1]) > width)\n            width = w;\n        }\n        coord->z = width * (fitting_opts->width_weight_factor);\n      }\n    }\n  }\n\n  /* We filter all the curves in CURVE_LIST at once; otherwise, we would\n     look at an unfiltered curve when computing tangents.  */\n\n  LOG(\"\\nFiltering curves:\\n\");\n  for (this_curve = 0; this_curve < curve_list.length; this_curve++) {\n    LOG(\"#%u: \", this_curve);\n    filter(CURVE_LIST_ELT(curve_list, this_curve), fitting_opts);\n  }\n\n  /* Make the first point in the first curve also be the last point in\n     the last curve, so the fit to the whole curve list will begin and\n     end at the same point.  This may cause slight errors in computing\n     the tangents and t values, but it's worth it for the continuity.\n     Of course we don't want to do this if the two points are already\n     the same, as they are if the curve is cyclic.  (We don't append it\n     earlier, in `split_at_corners', because that confuses the\n     filtering.)  Finally, we can't append the point if the curve is\n     exactly three points long, because we aren't adding any more data,\n     and three points isn't enough to determine a spline.  Therefore,\n     the fitting will fail.  */\n  curve = CURVE_LIST_ELT(curve_list, 0);\n  if (CURVE_CYCLIC(curve) == TRUE)\n    append_point(curve, CURVE_POINT(curve, 0));\n\n  /* Finally, fit each curve in the list to a list of splines.  */\n  for (this_curve = 0; this_curve < curve_list_length; this_curve++) {\n    spline_list_type *curve_splines;\n    curve_type current_curve = CURVE_LIST_ELT(curve_list, this_curve);\n\n    LOG(\"\\nFitting curve #%u:\\n\", this_curve);\n\n    curve_splines = fit_curve(current_curve, fitting_opts, exception);\n    if (at_exception_got_fatal(exception))\n      goto cleanup;\n    else if (curve_splines == NULL) {\n      LOG(\"Could not fit curve #%u\", this_curve);\n      at_exception_warning(exception, \"Could not fit curve\");\n    } else {\n      LOG(\"Fitted splines for curve #%u:\\n\", this_curve);\n      for (this_spline = 0; this_spline < SPLINE_LIST_LENGTH(*curve_splines); this_spline++) {\n        LOG(\"  %u: \", this_spline);\n        if (logging)\n          print_spline(SPLINE_LIST_ELT(*curve_splines, this_spline));\n      }\n\n      /* After fitting, we may need to change some would-be lines\n         back to curves, because they are in a list with other\n         curves.  */\n      change_bad_lines(curve_splines, fitting_opts);\n\n      concat_spline_lists(&curve_list_splines, *curve_splines);\n      free_spline_list(*curve_splines);\n      free(curve_splines);\n    }\n  }\n\n  if (logging) {\n    LOG(\"\\nFitted splines are:\\n\");\n    for (this_spline = 0; this_spline < SPLINE_LIST_LENGTH(curve_list_splines); this_spline++) {\n      LOG(\"  %u: \", this_spline);\n      print_spline(SPLINE_LIST_ELT(curve_list_splines, this_spline));\n    }\n  }\ncleanup:\n  return curve_list_splines;\n}\n\n/* Transform a set of locations to a list of splines (the fewer the\n   better).  We are guaranteed that CURVE does not contain any corners.\n   We return NULL if we cannot fit the points at all.  */\n\nstatic spline_list_type *fit_curve(curve_type curve, fitting_opts_type * fitting_opts, at_exception_type * exception)\n{\n  spline_list_type *fittedsplines;\n\n  if (CURVE_LENGTH(curve) < 2) {\n    LOG(\"Tried to fit curve with less than two points\");\n    at_exception_warning(exception, \"Tried to fit curve with less than two points\");\n    return NULL;\n  }\n\n  /* Do we have enough points to fit with a spline?  */\n  fittedsplines = CURVE_LENGTH(curve) < 4 ? fit_with_line(curve)\n      : fit_with_least_squares(curve, fitting_opts, exception);\n\n  return fittedsplines;\n}\n\n/* As mentioned above, the first step is to find the corners in\n   PIXEL_LIST, the list of points.  (Presumably we can't fit a single\n   spline around a corner.)  The general strategy is to look through all\n   the points, remembering which we want to consider corners.  Then go\n   through that list, producing the curve_list.  This is dictated by the\n   fact that PIXEL_LIST does not necessarily start on a corner---it just\n   starts at the character's first outline pixel, going left-to-right,\n   top-to-bottom.  But we want all our splines to start and end on real\n   corners.\n\n   For example, consider the top of a capital `C' (this is in cmss20):\n                     x\n                     ***********\n                  ******************\n\n   PIXEL_LIST will start at the pixel below the `x'.  If we considered\n   this pixel a corner, we would wind up matching a very small segment\n   from there to the end of the line, probably as a straight line, which\n   is certainly not what we want.\n\n   PIXEL_LIST has one element for each closed outline on the character.\n   To preserve this information, we return an array of curve_lists, one\n   element (which in turn consists of several curves, one between each\n   pair of corners) for each element in PIXEL_LIST.  */\n\nstatic curve_list_array_type split_at_corners(pixel_outline_list_type pixel_list, fitting_opts_type * fitting_opts, at_exception_type * exception)\n{\n  unsigned this_pixel_o;\n  curve_list_array_type curve_array = new_curve_list_array();\n\n  LOG(\"\\nFinding corners:\\n\");\n\n  for (this_pixel_o = 0; this_pixel_o < O_LIST_LENGTH(pixel_list); this_pixel_o++) {\n    curve_type curve, first_curve;\n    index_list_type corner_list;\n    unsigned p, this_corner;\n    curve_list_type curve_list = new_curve_list();\n    pixel_outline_type pixel_o = O_LIST_OUTLINE(pixel_list, this_pixel_o);\n\n    CURVE_LIST_CLOCKWISE(curve_list) = O_CLOCKWISE(pixel_o);\n    curve_list.open = pixel_o.open;\n\n    LOG(\"#%u:\", this_pixel_o);\n\n    /* If the outline does not have enough points, we can't do\n       anything.  The endpoints of the outlines are automatically\n       corners.  We need at least `corner_surround' more pixels on\n       either side of a point before it is conceivable that we might\n       want another corner.  */\n    if (O_LENGTH(pixel_o) > fitting_opts->corner_surround * 2 + 2)\n      corner_list = find_corners(pixel_o, fitting_opts, exception);\n\n    else {\n      int surround;\n      if ((surround = (int)(O_LENGTH(pixel_o) - 3) / 2) >= 2) {\n        unsigned save_corner_surround = fitting_opts->corner_surround;\n        fitting_opts->corner_surround = surround;\n        corner_list = find_corners(pixel_o, fitting_opts, exception);\n        fitting_opts->corner_surround = save_corner_surround;\n      } else {\n        corner_list.length = 0;\n        corner_list.data = NULL;\n      }\n    }\n\n    /* Remember the first curve so we can make it be the `next' of the\n       last one.  (And vice versa.)  */\n    first_curve = new_curve();\n\n    curve = first_curve;\n\n    if (corner_list.length == 0) {  /* No corners.  Use all of the pixel outline as the curve.  */\n      for (p = 0; p < O_LENGTH(pixel_o); p++)\n        append_pixel(curve, O_COORDINATE(pixel_o, p));\n\n      if (curve_list.open == TRUE)\n        CURVE_CYCLIC(curve) = FALSE;\n      else\n        CURVE_CYCLIC(curve) = TRUE;\n    } else {                    /* Each curve consists of the points between (inclusive) each pair\n                                   of corners.  */\n      for (this_corner = 0; this_corner < corner_list.length - 1; this_corner++) {\n        curve_type previous_curve = curve;\n        unsigned corner = GET_INDEX(corner_list, this_corner);\n        unsigned next_corner = GET_INDEX(corner_list, this_corner + 1);\n\n        for (p = corner; p <= next_corner; p++)\n          append_pixel(curve, O_COORDINATE(pixel_o, p));\n\n        append_curve(&curve_list, curve);\n        curve = new_curve();\n        NEXT_CURVE(previous_curve) = curve;\n        PREVIOUS_CURVE(curve) = previous_curve;\n      }\n\n      /* The last curve is different.  It consists of the points\n         (inclusive) between the last corner and the end of the list,\n         and the beginning of the list and the first corner.  */\n      for (p = GET_LAST_INDEX(corner_list); p < O_LENGTH(pixel_o); p++)\n        append_pixel(curve, O_COORDINATE(pixel_o, p));\n\n      if (!pixel_o.open) {\n        for (p = 0; p <= GET_INDEX(corner_list, 0); p++)\n          append_pixel(curve, O_COORDINATE(pixel_o, p));\n      } else {\n        curve_type last_curve = PREVIOUS_CURVE(curve);\n        PREVIOUS_CURVE(first_curve) = NULL;\n        if (last_curve)\n          NEXT_CURVE(last_curve) = NULL;\n      }\n    }\n\n    LOG(\" [%u].\\n\", corner_list.length);\n    free_index_list(&corner_list);\n\n    /* Add `curve' to the end of the list, updating the pointers in\n       the chain.  */\n    append_curve(&curve_list, curve);\n    NEXT_CURVE(curve) = first_curve;\n    PREVIOUS_CURVE(first_curve) = curve;\n\n    /* And now add the just-completed curve list to the array.  */\n    append_curve_list(&curve_array, curve_list);\n  }                             /* End of considering each pixel outline.  */\n\n  return curve_array;\n}\n\n/* We consider a point to be a corner if (1) the angle defined by the\n   `corner_surround' points coming into it and going out from it is less\n   than `corner_threshold' degrees, and no point within\n   `corner_surround' points has a smaller angle; or (2) the angle is less\n   than `corner_always_threshold' degrees.\n\n   Because of the different cases, it is convenient to have the\n   following macro to append a corner on to the list we return.  The\n   character argument C is simply so that the different cases can be\n   distinguished in the log file.  */\n\n#define APPEND_CORNER(index, angle, c)\t\t\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      append_index (&corner_list, index);\t\t\\\n      LOG (\" (%d,%d)%c%.3f\",\t\t\t\t\\\n            O_COORDINATE (pixel_outline, index).x,\t\\\n            O_COORDINATE (pixel_outline, index).y,\t\\\n            c, angle);\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n\nstatic index_list_type find_corners(pixel_outline_type pixel_outline, fitting_opts_type * fitting_opts, at_exception_type * exception)\n{\n  unsigned p, start_p, end_p;\n  index_list_type corner_list = new_index_list();\n\n  start_p = 0;\n  end_p = O_LENGTH(pixel_outline) - 1;\n  if (pixel_outline.open) {\n    if (end_p <= fitting_opts->corner_surround * 2)\n      return corner_list;\n    APPEND_CORNER(0, 0.0, '@');\n    start_p += fitting_opts->corner_surround;\n    end_p -= fitting_opts->corner_surround;\n  }\n\n  /* Consider each pixel on the outline in turn.  */\n  for (p = start_p; p <= end_p; p++) {\n    gfloat corner_angle;\n    vector_type in_vector, out_vector;\n\n    /* Check if the angle is small enough.  */\n    find_vectors(p, pixel_outline, &in_vector, &out_vector, fitting_opts->corner_surround);\n    corner_angle = Vangle(in_vector, out_vector, exception);\n    if (at_exception_got_fatal(exception))\n      goto cleanup;\n\n    if (fabs(corner_angle) <= fitting_opts->corner_threshold) {\n      /* We want to keep looking, instead of just appending the\n         first pixel we find with a small enough angle, since there\n         might be another corner within `corner_surround' pixels, with\n         a smaller angle.  If that is the case, we want that one.  */\n      gfloat best_corner_angle = corner_angle;\n      unsigned best_corner_index = p;\n      index_list_type equally_good_list = new_index_list();\n      /* As we come into the loop, `p' is the index of the point\n         that has an angle less than `corner_angle'.  We use `i' to\n         move through the pixels next to that, and `q' for moving\n         through the adjacent pixels to each `p'.  */\n      unsigned q = p;\n      unsigned i = p + 1;\n\n      while (TRUE) {\n        /* Perhaps the angle is sufficiently small that we want to\n           consider this a corner, even if it's not the best\n           (unless we've already wrapped around in the search,\n           i.e., `q<i', in which case we have already added the\n           corner, and we don't want to add it again).  We want to\n           do this check on the first candidate we find, as well\n           as the others in the loop, hence this comes before the\n           stopping condition.  */\n        if (corner_angle <= fitting_opts->corner_always_threshold && q >= p)\n          APPEND_CORNER(q, corner_angle, '\\\\');\n\n        /* Exit the loop if we've looked at `corner_surround'\n           pixels past the best one we found, or if we've looked\n           at all the pixels.  */\n        if (i >= best_corner_index + fitting_opts->corner_surround || i >= O_LENGTH(pixel_outline))\n          break;\n\n        /* Check the angle.  */\n        q = i % O_LENGTH(pixel_outline);\n        find_vectors(q, pixel_outline, &in_vector, &out_vector, fitting_opts->corner_surround);\n        corner_angle = Vangle(in_vector, out_vector, exception);\n        if (at_exception_got_fatal(exception))\n          goto cleanup;\n\n        /* If we come across a corner that is just as good as the\n           best one, we should make it a corner, too.  This\n           happens, for example, at the points on the `W' in some\n           typefaces, where the ``points'' are flat.  */\n        if (epsilon_equal(corner_angle, best_corner_angle))\n          append_index(&equally_good_list, q);\n\n        else if (corner_angle < best_corner_angle) {\n          best_corner_angle = corner_angle;\n          /* We want to check `corner_surround' pixels beyond the\n             new best corner.  */\n          i = best_corner_index = q;\n          free_index_list(&equally_good_list);\n          equally_good_list = new_index_list();\n        }\n\n        i++;\n      }\n\n      /* After we exit the loop, `q' is the index of the last point\n         we checked.  We have already added the corner if\n         `best_corner_angle' is less than `corner_always_threshold'.\n         Again, if we've already wrapped around, we don't want to\n         add the corner again.  */\n      if (best_corner_angle > fitting_opts->corner_always_threshold && best_corner_index >= p) {\n        unsigned j;\n\n        APPEND_CORNER(best_corner_index, best_corner_angle, '/');\n\n        for (j = 0; j < INDEX_LIST_LENGTH(equally_good_list); j++)\n          APPEND_CORNER(GET_INDEX(equally_good_list, j), best_corner_angle, '@');\n      }\n      free_index_list(&equally_good_list);\n\n      /* If we wrapped around in our search, we're done; otherwise,\n         we don't want the outer loop to look at the pixels that we\n         already looked at in searching for the best corner.  */\n      p = (q < p) ? O_LENGTH(pixel_outline) : q;\n    }                           /* End of searching for the best corner.  */\n  }                             /* End of considering each pixel.  */\n\n  if (INDEX_LIST_LENGTH(corner_list) > 0)\n    /* We never want two corners next to each other, since the\n       only way to fit such a ``curve'' would be with a straight\n       line, which usually interrupts the continuity dreadfully.  */\n    remove_adjacent_corners(&corner_list, O_LENGTH(pixel_outline) - (pixel_outline.open ? 2 : 1), fitting_opts->remove_adjacent_corners, exception);\ncleanup:\n  return corner_list;\n}\n\n/* Return the difference vectors coming in and going out of the outline\n   OUTLINE at the point whose index is TEST_INDEX.  In Phoenix,\n   Schneider looks at a single point on either side of the point we're\n   considering.  That works for him because his points are not touching.\n   But our points *are* touching, and so we have to look at\n   `corner_surround' points on either side, to get a better picture of\n   the outline's shape.  */\n\nstatic void find_vectors(unsigned test_index, pixel_outline_type outline, vector_type * in, vector_type * out, unsigned corner_surround)\n{\n  int i;\n  unsigned n_done;\n  at_coord candidate = O_COORDINATE(outline, test_index);\n\n  in->dx = in->dy = in->dz = 0.0;\n  out->dx = out->dy = out->dz = 0.0;\n\n  /* Add up the differences from p of the `corner_surround' points\n     before p.  */\n  for (i = O_PREV(outline, test_index), n_done = 0; n_done < corner_surround; i = O_PREV(outline, i), n_done++)\n    *in = Vadd(*in, IPsubtract(O_COORDINATE(outline, i), candidate));\n\n  /* And the points after p.  */\n  for (i = O_NEXT(outline, test_index), n_done = 0; n_done < corner_surround; i = O_NEXT(outline, i), n_done++)\n    *out = Vadd(*out, IPsubtract(O_COORDINATE(outline, i), candidate));\n}\n\n/* Remove adjacent points from the index list LIST.  We do this by first\n   sorting the list and then running through it.  Since these lists are\n   quite short, a straight selection sort (e.g., p.139 of the Art of\n   Computer Programming, vol.3) is good enough.  LAST_INDEX is the index\n   of the last pixel on the outline, i.e., the next one is the first\n   pixel. We need this for checking the adjacency of the last corner.\n\n   We need to do this because the adjacent corners turn into\n   two-pixel-long curves, which can only be fit by straight lines.  */\n\nstatic void remove_adjacent_corners(index_list_type * list, unsigned last_index, gboolean remove_adj_corners, at_exception_type * exception)\n{\n  unsigned j;\n  unsigned last;\n  index_list_type new_list = new_index_list();\n\n  for (j = INDEX_LIST_LENGTH(*list) - 1; j > 0; j--) {\n    unsigned search;\n    unsigned temp;\n    /* Find maximal element below `j'.  */\n    unsigned max_index = j;\n\n    for (search = 0; search < j; search++)\n      if (GET_INDEX(*list, search) > GET_INDEX(*list, max_index))\n        max_index = search;\n\n    if (max_index != j) {\n      temp = GET_INDEX(*list, j);\n      GET_INDEX(*list, j) = GET_INDEX(*list, max_index);\n      GET_INDEX(*list, max_index) = temp;\n\n      /* xx -- really have to sort?  */\n      LOG(\"needed exchange\");\n      at_exception_warning(exception, \"needed exchange\");\n    }\n  }\n\n  /* The list is sorted.  Now look for adjacent entries.  Each time\n     through the loop we insert the current entry and, if appropriate,\n     the next entry.  */\n  for (j = 0; j < INDEX_LIST_LENGTH(*list) - 1; j++) {\n    unsigned current = GET_INDEX(*list, j);\n    unsigned next = GET_INDEX(*list, j + 1);\n\n    /* We should never have inserted the same element twice.  */\n    /* assert (current != next); */\n\n    if ((remove_adj_corners) && ((next == current + 1) || (next == current)))\n      j++;\n\n    append_index(&new_list, current);\n  }\n\n  /* Don't append the last element if it is 1) adjacent to the previous\n     one; or 2) adjacent to the very first one.  */\n  last = GET_LAST_INDEX(*list);\n  if (INDEX_LIST_LENGTH(new_list) == 0 || !(last == GET_LAST_INDEX(new_list) + 1 || (last == last_index && GET_INDEX(*list, 0) == 0)))\n    append_index(&new_list, last);\n\n  free_index_list(list);\n  *list = new_list;\n}\n\n/* A ``knee'' is a point which forms a ``right angle'' with its\n   predecessor and successor.  See the documentation (the `Removing\n   knees' section) for an example and more details.\n\n   The argument CLOCKWISE tells us which direction we're moving.  (We\n   can't figure that information out from just the single segment with\n   which we are given to work.)\n\n   We should never find two consecutive knees.\n\n   Since the first and last points are corners (unless the curve is\n   cyclic), it doesn't make sense to remove those.  */\n\n/* This evaluates to TRUE if the vector V is zero in one direction and\n   nonzero in the other.  */\n#define ONLY_ONE_ZERO(v)                                                \\\n  (((v).dx == 0.0 && (v).dy != 0.0) || ((v).dy == 0.0 && (v).dx != 0.0))\n\n/* There are four possible cases for knees, one for each of the four\n   corners of a rectangle; and then the cases differ depending on which\n   direction we are going around the curve.  The tests are listed here\n   in the order of upper left, upper right, lower right, lower left.\n   Perhaps there is some simple pattern to the\n   clockwise/counterclockwise differences, but I don't see one.  */\n#define CLOCKWISE_KNEE(prev_delta, next_delta)                                                  \\\n  ((prev_delta.dx == -1.0 && next_delta.dy == 1.0)                                              \\\n   || (prev_delta.dy == 1.0 && next_delta.dx == 1.0)                                    \\\n   || (prev_delta.dx == 1.0 && next_delta.dy == -1.0)                                   \\\n   || (prev_delta.dy == -1.0 && next_delta.dx == -1.0))\n\n#define COUNTERCLOCKWISE_KNEE(prev_delta, next_delta)                                   \\\n  ((prev_delta.dy == 1.0 && next_delta.dx == -1.0)                                              \\\n   || (prev_delta.dx == 1.0 && next_delta.dy == 1.0)                                    \\\n   || (prev_delta.dy == -1.0 && next_delta.dx == 1.0)                                   \\\n   || (prev_delta.dx == -1.0 && next_delta.dy == -1.0))\n\nstatic void remove_knee_points(curve_type curve, gboolean clockwise)\n{\n  unsigned i;\n  unsigned offset = (CURVE_CYCLIC(curve) == TRUE) ? 0 : 1;\n  at_coord previous = real_to_int_coord(CURVE_POINT(curve, CURVE_PREV(curve, offset)));\n  curve_type trimmed_curve = copy_most_of_curve(curve);\n\n  if (CURVE_CYCLIC(curve) == FALSE)\n    append_pixel(trimmed_curve, real_to_int_coord(CURVE_POINT(curve, 0)));\n\n  for (i = offset; i < CURVE_LENGTH(curve) - offset; i++) {\n    at_coord current = real_to_int_coord(CURVE_POINT(curve, i));\n    at_coord next = real_to_int_coord(CURVE_POINT(curve, CURVE_NEXT(curve, i)));\n    vector_type prev_delta = IPsubtract(previous, current);\n    vector_type next_delta = IPsubtract(next, current);\n\n    if (ONLY_ONE_ZERO(prev_delta) && ONLY_ONE_ZERO(next_delta)\n        && ((clockwise && CLOCKWISE_KNEE(prev_delta, next_delta))\n            || (!clockwise && COUNTERCLOCKWISE_KNEE(prev_delta, next_delta))))\n      LOG(\" (%d,%d)\", current.x, current.y);\n    else {\n      previous = current;\n      append_pixel(trimmed_curve, current);\n    }\n  }\n\n  if (CURVE_CYCLIC(curve) == FALSE)\n    append_pixel(trimmed_curve, real_to_int_coord(LAST_CURVE_POINT(curve)));\n\n  if (CURVE_LENGTH(trimmed_curve) == CURVE_LENGTH(curve))\n    LOG(\" (none)\");\n\n  LOG(\".\\n\");\n\n  free_curve(curve);\n  *curve = *trimmed_curve;\n  free(trimmed_curve);          /* free_curve? --- Masatake */\n}\n\n/* Smooth the curve by adding in neighboring points.  Do this\n   `filter_iterations' times.  But don't change the corners.  */\n\nstatic void filter(curve_type curve, fitting_opts_type * fitting_opts)\n{\n  unsigned iteration, this_point;\n  unsigned offset = (CURVE_CYCLIC(curve) == TRUE) ? 0 : 1;\n  at_real_coord prev_new_point;\n\n  /* We must have at least three points---the previous one, the current\n     one, and the next one.  But if we don't have at least five, we will\n     probably collapse the curve down onto a single point, which means\n     we won't be able to fit it with a spline.  */\n  if (CURVE_LENGTH(curve) < 5) {\n    LOG(\"Length is %u, not enough to filter.\\n\", CURVE_LENGTH(curve));\n    return;\n  }\n\n  prev_new_point.x = FLT_MAX;\n  prev_new_point.y = FLT_MAX;\n  prev_new_point.z = FLT_MAX;\n\n  for (iteration = 0; iteration < fitting_opts->filter_iterations; iteration++) {\n    curve_type newcurve = copy_most_of_curve(curve);\n    gboolean collapsed = FALSE;\n\n    /* Keep the first point on the curve.  */\n    if (offset)\n      append_point(newcurve, CURVE_POINT(curve, 0));\n\n    for (this_point = offset; this_point < CURVE_LENGTH(curve) - offset; this_point++) {\n      vector_type in, out, sum;\n      at_real_coord new_point;\n\n      /* Calculate the vectors in and out, computed by looking at n points\n         on either side of this_point. Experimental it was found that 2 is\n         optimal. */\n\n      signed int prev, prevprev;  /* have to be signed */\n      unsigned int next, nextnext;\n      at_real_coord candidate = CURVE_POINT(curve, this_point);\n\n      prev = CURVE_PREV(curve, this_point);\n      prevprev = CURVE_PREV(curve, prev);\n      next = CURVE_NEXT(curve, this_point);\n      nextnext = CURVE_NEXT(curve, next);\n\n      /* Add up the differences from p of the `surround' points\n         before p.  */\n      in.dx = in.dy = in.dz = 0.0;\n\n      in = Vadd(in, Psubtract(CURVE_POINT(curve, prev), candidate));\n      if (prevprev >= 0)\n        in = Vadd(in, Psubtract(CURVE_POINT(curve, prevprev), candidate));\n\n      /* And the points after p.  Don't use more points after p than we\n         ended up with before it.  */\n      out.dx = out.dy = out.dz = 0.0;\n\n      out = Vadd(out, Psubtract(CURVE_POINT(curve, next), candidate));\n      if (nextnext < CURVE_LENGTH(curve))\n        out = Vadd(out, Psubtract(CURVE_POINT(curve, nextnext), candidate));\n\n      /* Start with the old point.  */\n      new_point = candidate;\n      sum = Vadd(in, out);\n      /* We added 2*n+2 points, so we have to divide the sum by 2*n+2 */\n      new_point.x += sum.dx / 6;\n      new_point.y += sum.dy / 6;\n      new_point.z += sum.dz / 6;\n      if (fabs(prev_new_point.x - new_point.x) < 0.3 && fabs(prev_new_point.y - new_point.y) < 0.3 && fabs(prev_new_point.z - new_point.z) < 0.3) {\n        collapsed = TRUE;\n        break;\n      }\n\n      /* Put the newly computed point into a separate curve, so it\n         doesn't affect future computation (on this iteration).  */\n      append_point(newcurve, prev_new_point = new_point);\n    }\n\n    if (collapsed)\n      free_curve(newcurve);\n    else {\n      /* Just as with the first point, we have to keep the last point.  */\n      if (offset)\n        append_point(newcurve, LAST_CURVE_POINT(curve));\n\n      /* Set the original curve to the newly filtered one, and go again.  */\n      free_curve(curve);\n      *curve = *newcurve;\n    }\n    free(newcurve);\n  }\n\n  if (logging)\n    log_curve(curve, FALSE);\n}\n\n/* This routine returns the curve fitted to a straight line in a very\n   simple way: make the first and last points on the curve be the\n   endpoints of the line.  This simplicity is justified because we are\n   called only on very short curves.  */\n\nstatic spline_list_type *fit_with_line(curve_type curve)\n{\n  spline_type line;\n\n  LOG(\"Fitting with straight line:\\n\");\n\n  SPLINE_DEGREE(line) = LINEARTYPE;\n  START_POINT(line) = CONTROL1(line) = CURVE_POINT(curve, 0);\n  END_POINT(line) = CONTROL2(line) = LAST_CURVE_POINT(curve);\n\n  /* Make sure that this line is never changed to a cubic.  */\n  SPLINE_LINEARITY(line) = 0;\n\n  if (logging) {\n    LOG(\"  \");\n    print_spline(line);\n  }\n\n  return new_spline_list_with_spline(line);\n}\n\n/* The least squares method is well described in Schneider's thesis.\n   Briefly, we try to fit the entire curve with one spline. If that\n   fails, we subdivide the curve.  */\n\nstatic spline_list_type *fit_with_least_squares(curve_type curve, fitting_opts_type * fitting_opts, at_exception_type * exception)\n{\n  gfloat error = 0, best_error = FLT_MAX;\n  spline_type spline, best_spline;\n  spline_list_type *spline_list = NULL;\n  unsigned worst_point = 0;\n  gfloat previous_error = FLT_MAX;\n\n  LOG(\"\\nFitting with least squares:\\n\");\n\n  /* Phoenix reduces the number of points with a ``linear spline\n     technique''.  But for fitting letterforms, that is\n     inappropriate.  We want all the points we can get.  */\n\n  /* It makes no difference whether we first set the `t' values or\n     find the tangents.  This order makes the documentation a little\n     more coherent.  */\n\n  LOG(\"Finding tangents:\\n\");\n  find_tangent(curve, /* to_start */ TRUE, /* cross_curve */ FALSE,\n               fitting_opts->tangent_surround);\n  find_tangent(curve, /* to_start */ FALSE, /* cross_curve */ FALSE,\n               fitting_opts->tangent_surround);\n\n  set_initial_parameter_values(curve);\n\n  /* Now we loop, subdividing, until CURVE has\n     been fit.  */\n  while (TRUE) {\n    spline = best_spline = fit_one_spline(curve, exception);\n    if (at_exception_got_fatal(exception))\n      goto cleanup;\n\n    if (SPLINE_DEGREE(spline) == LINEARTYPE)\n      LOG(\"  fitted to line:\\n\");\n    else\n      LOG(\"  fitted to spline:\\n\");\n\n    if (logging) {\n      LOG(\"    \");\n      print_spline(spline);\n    }\n\n    if (SPLINE_DEGREE(spline) == LINEARTYPE)\n      break;\n\n    error = find_error(curve, spline, &worst_point, exception);\n    if (error <= previous_error) {\n      best_error = error;\n      best_spline = spline;\n    }\n    break;\n  }\n\n  if (SPLINE_DEGREE(spline) == LINEARTYPE) {\n    spline_list = new_spline_list_with_spline(spline);\n    LOG(\"Accepted error of %.3f.\\n\", error);\n    return (spline_list);\n  }\n\n  /* Go back to the best fit.  */\n  spline = best_spline;\n  error = best_error;\n\n  if (error < fitting_opts->error_threshold && CURVE_CYCLIC(curve) == FALSE) {\n    /* The points were fitted with a\n       spline.  We end up here whenever a fit is accepted.  We have\n       one more job: see if the ``curve'' that was fit should really\n       be a straight line. */\n    if (spline_linear_enough(&spline, curve, fitting_opts)) {\n      SPLINE_DEGREE(spline) = LINEARTYPE;\n      LOG(\"Changed to line.\\n\");\n    }\n    spline_list = new_spline_list_with_spline(spline);\n    LOG(\"Accepted error of %.3f.\\n\", error);\n  } else {\n    /* We couldn't fit the curve acceptably, so subdivide.  */\n    unsigned subdivision_index;\n    spline_list_type *left_spline_list;\n    spline_list_type *right_spline_list;\n    curve_type left_curve = new_curve();\n    curve_type right_curve = new_curve();\n\n    /* Keep the linked list of curves intact.  */\n    NEXT_CURVE(right_curve) = NEXT_CURVE(curve);\n    PREVIOUS_CURVE(right_curve) = left_curve;\n    NEXT_CURVE(left_curve) = right_curve;\n    PREVIOUS_CURVE(left_curve) = curve;\n    NEXT_CURVE(curve) = left_curve;\n\n    LOG(\"\\nSubdividing (error %.3f):\\n\", error);\n    LOG(\"  Original point: (%.3f,%.3f), #%u.\\n\", CURVE_POINT(curve, worst_point).x, CURVE_POINT(curve, worst_point).y, worst_point);\n    subdivision_index = worst_point;\n    LOG(\"  Final point: (%.3f,%.3f), #%u.\\n\", CURVE_POINT(curve, subdivision_index).x, CURVE_POINT(curve, subdivision_index).y, subdivision_index);\n\n    /* The last point of the left-hand curve will also be the first\n       point of the right-hand curve.  */\n    CURVE_LENGTH(left_curve) = subdivision_index + 1;\n    CURVE_LENGTH(right_curve) = CURVE_LENGTH(curve) - subdivision_index;\n    left_curve->point_list = curve->point_list;\n    right_curve->point_list = curve->point_list + subdivision_index;\n\n    /* We want to use the tangents of the curve which we are\n       subdividing for the start tangent for left_curve and the\n       end tangent for right_curve.  */\n    CURVE_START_TANGENT(left_curve) = CURVE_START_TANGENT(curve);\n    CURVE_END_TANGENT(right_curve) = CURVE_END_TANGENT(curve);\n\n    /* We have to set up the two curves before finding the tangent at\n       the subdivision point.  The tangent at that point must be the\n       same for both curves, or noticeable bumps will occur in the\n       character.  But we want to use information on both sides of the\n       point to compute the tangent, hence cross_curve = true.  */\n    find_tangent(left_curve, /* to_start_point: */ FALSE,\n                 /* cross_curve: */ TRUE, fitting_opts->tangent_surround);\n    CURVE_START_TANGENT(right_curve) = CURVE_END_TANGENT(left_curve);\n\n    /* Now that we've set up the curves, we can fit them.  */\n    left_spline_list = fit_curve(left_curve, fitting_opts, exception);\n    if (at_exception_got_fatal(exception))\n      /* TODO: Memory allocated for left_curve and right_curve\n         will leak. */\n      goto cleanup;\n\n    right_spline_list = fit_curve(right_curve, fitting_opts, exception);\n    /* TODO: Memory allocated for left_curve and right_curve\n       will leak. */\n    if (at_exception_got_fatal(exception))\n      goto cleanup;\n\n    /* Neither of the subdivided curves could be fit, so fail.  */\n    if (left_spline_list == NULL && right_spline_list == NULL)\n      return NULL;\n\n    /* Put the two together (or whichever of them exist).  */\n    spline_list = new_spline_list();\n\n    if (left_spline_list == NULL) {\n      LOG(\"Could not fit spline to left curve (%lx).\\n\", (unsigned long)left_curve);\n      at_exception_warning(exception, \"Could not fit left spline list\");\n    } else {\n      concat_spline_lists(spline_list, *left_spline_list);\n      free_spline_list(*left_spline_list);\n      free(left_spline_list);\n    }\n\n    if (right_spline_list == NULL) {\n      LOG(\"Could not fit spline to right curve (%lx).\\n\", (unsigned long)right_curve);\n      at_exception_warning(exception, \"Could not fit right spline list\");\n    } else {\n      concat_spline_lists(spline_list, *right_spline_list);\n      free_spline_list(*right_spline_list);\n      free(right_spline_list);\n    }\n    if (CURVE_END_TANGENT(left_curve))\n      free(CURVE_END_TANGENT(left_curve));\n    free(left_curve);\n    free(right_curve);\n  }\ncleanup:\n  return spline_list;\n}\n\n/* Our job here is to find alpha1 (and alpha2), where t1_hat (t2_hat) is\n   the tangent to CURVE at the starting (ending) point, such that:\n\n   control1 = alpha1*t1_hat + starting point\n   control2 = alpha2*t2_hat + ending_point\n\n   and the resulting spline (starting_point .. control1 and control2 ..\n   ending_point) minimizes the least-square error from CURVE.\n\n   See pp.57--59 of the Phoenix thesis.\n\n   The B?(t) here corresponds to B_i^3(U_i) there.\n   The Bernshte\\u in polynomials of degree n are defined by\n   B_i^n(t) = { n \\choose i } t^i (1-t)^{n-i}, i = 0..n  */\n\n#define B0(t) CUBE ((gfloat) 1.0 - (t))\n#define B1(t) ((gfloat) 3.0 * (t) * SQUARE ((gfloat) 1.0 - (t)))\n#define B2(t) ((gfloat) 3.0 * SQUARE (t) * ((gfloat) 1.0 - (t)))\n#define B3(t) CUBE (t)\n\nstatic spline_type fit_one_spline(curve_type curve, at_exception_type * exception)\n{\n  /* Since our arrays are zero-based, the `C0' and `C1' here correspond\n     to `C1' and `C2' in the paper.  */\n  gfloat X_C1_det, C0_X_det, C0_C1_det;\n  gfloat alpha1, alpha2;\n  spline_type spline;\n  vector_type start_vector, end_vector;\n  unsigned i;\n  vector_type *A;\n  vector_type t1_hat = *CURVE_START_TANGENT(curve);\n  vector_type t2_hat = *CURVE_END_TANGENT(curve);\n  gfloat C[2][2] = { {0.0, 0.0}, {0.0, 0.0} };\n  gfloat X[2] = { 0.0, 0.0 };\n\n  XMALLOC(A, CURVE_LENGTH(curve) * 2 * sizeof(vector_type));  /* A dynamically allocated array. */\n\n  START_POINT(spline) = CURVE_POINT(curve, 0);\n  END_POINT(spline) = LAST_CURVE_POINT(curve);\n  start_vector = make_vector(START_POINT(spline));\n  end_vector = make_vector(END_POINT(spline));\n\n  for (i = 0; i < CURVE_LENGTH(curve); i++) {\n    A[(i << 1) + 0] = Vmult_scalar(t1_hat, B1(CURVE_T(curve, i)));\n    A[(i << 1) + 1] = Vmult_scalar(t2_hat, B2(CURVE_T(curve, i)));\n  }\n\n  for (i = 0; i < CURVE_LENGTH(curve); i++) {\n    vector_type temp, temp0, temp1, temp2, temp3;\n    vector_type *Ai = A + (i << 1);\n\n    C[0][0] += Vdot(Ai[0], Ai[0]);\n    C[0][1] += Vdot(Ai[0], Ai[1]);\n    /* C[1][0] = C[0][1] (this is assigned outside the loop)  */\n    C[1][1] += Vdot(Ai[1], Ai[1]);\n\n    /* Now the right-hand side of the equation in the paper.  */\n    temp0 = Vmult_scalar(start_vector, B0(CURVE_T(curve, i)));\n    temp1 = Vmult_scalar(start_vector, B1(CURVE_T(curve, i)));\n    temp2 = Vmult_scalar(end_vector, B2(CURVE_T(curve, i)));\n    temp3 = Vmult_scalar(end_vector, B3(CURVE_T(curve, i)));\n\n    temp = make_vector(Vsubtract_point(CURVE_POINT(curve, i), Vadd(temp0, Vadd(temp1, Vadd(temp2, temp3)))));\n\n    X[0] += Vdot(temp, Ai[0]);\n    X[1] += Vdot(temp, Ai[1]);\n  }\n  free(A);\n\n  C[1][0] = C[0][1];\n\n  X_C1_det = X[0] * C[1][1] - X[1] * C[0][1];\n  C0_X_det = C[0][0] * X[1] - C[0][1] * X[0];\n  C0_C1_det = C[0][0] * C[1][1] - C[1][0] * C[0][1];\n  if (C0_C1_det == 0.0) {\n    /* Zero determinant */\n    alpha1 = 0;\n    alpha2 = 0;\n  } else {\n    alpha1 = X_C1_det / C0_C1_det;\n    alpha2 = C0_X_det / C0_C1_det;\n  }\n  CONTROL1(spline) = Vadd_point(START_POINT(spline), Vmult_scalar(t1_hat, alpha1));\n  CONTROL2(spline) = Vadd_point(END_POINT(spline), Vmult_scalar(t2_hat, alpha2));\n  SPLINE_DEGREE(spline) = CUBICTYPE;\n\n  return spline;\n}\n\n/* Find reasonable values for t for each point on CURVE.  The method is\n   called chord-length parameterization, which is described in Plass &\n   Stone.  The basic idea is just to use the distance from one point to\n   the next as the t value, normalized to produce values that increase\n   from zero for the first point to one for the last point.  */\n\nstatic void set_initial_parameter_values(curve_type curve)\n{\n  unsigned p;\n\n  LOG(\"\\nAssigning initial t values:\\n  \");\n\n  CURVE_T(curve, 0) = 0.0;\n\n  for (p = 1; p < CURVE_LENGTH(curve); p++) {\n    at_real_coord point = CURVE_POINT(curve, p), previous_p = CURVE_POINT(curve, p - 1);\n    gfloat d = distance(point, previous_p);\n    CURVE_T(curve, p) = CURVE_T(curve, p - 1) + d;\n  }\n\n  if (LAST_CURVE_T(curve) == 0.0)\n    LAST_CURVE_T(curve) = 1.0;\n\n  for (p = 1; p < CURVE_LENGTH(curve); p++)\n    CURVE_T(curve, p) = CURVE_T(curve, p) / LAST_CURVE_T(curve);\n\n  if (logging)\n    log_entire_curve(curve);\n}\n\n/* Find an approximation to the tangent to an endpoint of CURVE (to the\n   first point if TO_START_POINT is TRUE, else the last).  If\n   CROSS_CURVE is TRUE, consider points on the adjacent curve to CURVE.\n\n   It is important to compute an accurate approximation, because the\n   control points that we eventually decide upon to fit the curve will\n   be placed on the half-lines defined by the tangents and\n   endpoints...and we never recompute the tangent after this.  */\n\nstatic void find_tangent(curve_type curve, gboolean to_start_point, gboolean cross_curve, unsigned tangent_surround)\n{\n  vector_type tangent;\n  vector_type **curve_tangent = (to_start_point == TRUE) ? &(CURVE_START_TANGENT(curve))\n      : &(CURVE_END_TANGENT(curve));\n  unsigned n_points = 0;\n\n  LOG(\"  tangent to %s: \", (to_start_point == TRUE) ? \"start\" : \"end\");\n\n  if (*curve_tangent == NULL) {\n    XMALLOC(*curve_tangent, sizeof(vector_type));\n    do {\n      tangent = find_half_tangent(curve, to_start_point, &n_points, tangent_surround);\n\n      if ((cross_curve == TRUE) || (CURVE_CYCLIC(curve) == TRUE)) {\n        curve_type adjacent_curve = (to_start_point == TRUE) ? PREVIOUS_CURVE(curve) : NEXT_CURVE(curve);\n        vector_type tangent2 = (to_start_point == FALSE) ? find_half_tangent(adjacent_curve, TRUE, &n_points,\n                                                                             tangent_surround) : find_half_tangent(adjacent_curve, TRUE, &n_points,\n                                                                                                                   tangent_surround);\n\n        LOG(\"(adjacent curve half tangent (%.3f,%.3f,%.3f)) \", tangent2.dx, tangent2.dy, tangent2.dz);\n        tangent = Vadd(tangent, tangent2);\n      }\n      tangent_surround--;\n\n    }\n    while (tangent.dx == 0.0 && tangent.dy == 0.0);\n\n    assert(n_points > 0);\n    **curve_tangent = Vmult_scalar(tangent, (gfloat) (1.0 / n_points));\n    if ((CURVE_CYCLIC(curve) == TRUE) && CURVE_START_TANGENT(curve))\n      *CURVE_START_TANGENT(curve) = **curve_tangent;\n    if ((CURVE_CYCLIC(curve) == TRUE) && CURVE_END_TANGENT(curve))\n      *CURVE_END_TANGENT(curve) = **curve_tangent;\n  } else\n    LOG(\"(already computed) \");\n\n  LOG(\"(%.3f,%.3f,%.3f).\\n\", (*curve_tangent)->dx, (*curve_tangent)->dy, (*curve_tangent)->dz);\n}\n\n/* Find the change in y and change in x for `tangent_surround' (a global)\n   points along CURVE.  Increment N_POINTS by the number of points we\n   actually look at.  */\n\nstatic vector_type find_half_tangent(curve_type c, gboolean to_start_point, unsigned *n_points, unsigned tangent_surround)\n{\n  unsigned p;\n  int factor = to_start_point ? 1 : -1;\n  unsigned tangent_index = to_start_point ? 0 : c->length - 1;\n  at_real_coord tangent_point = CURVE_POINT(c, tangent_index);\n  vector_type tangent = { 0.0, 0.0 };\n  unsigned int surround;\n\n  if ((surround = CURVE_LENGTH(c) / 2) > tangent_surround)\n    surround = tangent_surround;\n\n  for (p = 1; p <= surround; p++) {\n    int this_index = p * factor + tangent_index;\n    at_real_coord this_point;\n\n    if (this_index < 0 || this_index >= (int)c->length)\n      break;\n\n    this_point = CURVE_POINT(c, p * factor + tangent_index);\n\n    /* Perhaps we should weight the tangent from `this_point' by some\n       factor dependent on the distance from the tangent point.  */\n    tangent = Vadd(tangent, Vmult_scalar(Psubtract(this_point, tangent_point), (gfloat) factor));\n    (*n_points)++;\n  }\n\n  return tangent;\n}\n\n/* When this routine is called, we have computed a spline representation\n   for the digitized curve.  The question is, how good is it?  If the\n   fit is very good indeed, we might have an error of zero on each\n   point, and then WORST_POINT becomes irrelevant.  But normally, we\n   return the error at the worst point, and the index of that point in\n   WORST_POINT.  The error computation itself is the Euclidean distance\n   from the original curve CURVE to the fitted spline SPLINE.  */\n\nstatic gfloat find_error(curve_type curve, spline_type spline, unsigned *worst_point, at_exception_type * exception)\n{\n  unsigned this_point;\n  gfloat total_error = 0.0;\n  gfloat worst_error = FLT_MIN;\n\n  *worst_point = CURVE_LENGTH(curve) + 1; /* A sentinel value.  */\n\n  for (this_point = 0; this_point < CURVE_LENGTH(curve); this_point++) {\n    at_real_coord curve_point = CURVE_POINT(curve, this_point);\n    gfloat t = CURVE_T(curve, this_point);\n    at_real_coord spline_point = evaluate_spline(spline, t);\n    gfloat this_error = distance(curve_point, spline_point);\n    if (this_error >= worst_error) {\n      *worst_point = this_point;\n      worst_error = this_error;\n    }\n    total_error += this_error;\n  }\n\n  if (*worst_point == CURVE_LENGTH(curve) + 1) {  /* Didn't have any ``worst point''; the error should be zero.  */\n    if (epsilon_equal(total_error, 0.0))\n      LOG(\"  Every point fit perfectly.\\n\");\n    else {\n      LOG(\"No worst point found; something is wrong\");\n      at_exception_warning(exception, \"No worst point found; something is wrong\");\n    }\n  } else {\n    if (epsilon_equal(total_error, 0.0))\n      LOG(\"  Every point fit perfectly.\\n\");\n    else {\n      LOG(\"  Worst error (at (%.3f,%.3f,%.3f), point #%u) was %.3f.\\n\", CURVE_POINT(curve, *worst_point).x, CURVE_POINT(curve, *worst_point).y, CURVE_POINT(curve, *worst_point).z, *worst_point, worst_error);\n      LOG(\"  Total error was %.3f.\\n\", total_error);\n      LOG(\"  Average error (over %u points) was %.3f.\\n\", CURVE_LENGTH(curve), total_error / CURVE_LENGTH(curve));\n    }\n  }\n\n  return worst_error;\n}\n\n/* Supposing that we have accepted the error, another question arises:\n   would we be better off just using a straight line?  */\n\nstatic gboolean spline_linear_enough(spline_type * spline, curve_type curve, fitting_opts_type * fitting_opts)\n{\n  gfloat A, B, C;\n  unsigned this_point;\n  gfloat dist = 0.0, start_end_dist, threshold;\n\n  LOG(\"Checking linearity:\\n\");\n\n  A = END_POINT(*spline).x - START_POINT(*spline).x;\n  B = END_POINT(*spline).y - START_POINT(*spline).y;\n  C = END_POINT(*spline).z - START_POINT(*spline).z;\n\n  start_end_dist = (gfloat) (SQUARE(A) + SQUARE(B) + SQUARE(C));\n  LOG(\"start_end_distance is %.3f.\\n\", sqrt(start_end_dist));\n\n  LOG(\"  Line endpoints are (%.3f, %.3f, %.3f) and \", START_POINT(*spline).x, START_POINT(*spline).y, START_POINT(*spline).z);\n  LOG(\"(%.3f, %.3f, %.3f)\\n\", END_POINT(*spline).x, END_POINT(*spline).y, END_POINT(*spline).z);\n\n  /* LOG (\"  Line is %.3fx + %.3fy + %.3f = 0.\\n\", A, B, C); */\n\n  for (this_point = 0; this_point < CURVE_LENGTH(curve); this_point++) {\n    gfloat a, b, c, w;\n    gfloat t = CURVE_T(curve, this_point);\n    at_real_coord spline_point = evaluate_spline(*spline, t);\n\n    a = spline_point.x - START_POINT(*spline).x;\n    b = spline_point.y - START_POINT(*spline).y;\n    c = spline_point.z - START_POINT(*spline).z;\n    w = (A * a + B * b + C * c) / start_end_dist;\n\n    dist += (gfloat) sqrt(SQUARE(a - A * w) + SQUARE(b - B * w) + SQUARE(c - C * w));\n  }\n  LOG(\"  Total distance is %.3f, \", dist);\n\n  dist /= (CURVE_LENGTH(curve) - 1);\n  LOG(\"which is %.3f normalized.\\n\", dist);\n\n  /* We want reversion of short curves to splines to be more likely than\n     reversion of long curves, hence the second division by the curve\n     length, for use in `change_bad_lines'.  */\n  SPLINE_LINEARITY(*spline) = dist;\n  LOG(\"  Final linearity: %.3f.\\n\", SPLINE_LINEARITY(*spline));\n  if (start_end_dist * (gfloat) 0.5 > fitting_opts->line_threshold)\n    threshold = fitting_opts->line_threshold;\n  else\n    threshold = start_end_dist * (gfloat) 0.5;\n  LOG(\"threshold is %.3f .\\n\", threshold);\n  if (dist < threshold)\n    return TRUE;\n  else\n    return FALSE;\n}\n\n/* Unfortunately, we cannot tell in isolation whether a given spline\n   should be changed to a line or not.  That can only be known after the\n   entire curve has been fit to a list of splines.  (The curve is the\n   pixel outline between two corners.)  After subdividing the curve, a\n   line may very well fit a portion of the curve just as well as the\n   spline---but unless a spline is truly close to being a line, it\n   should not be combined with other lines.  */\n\nstatic void change_bad_lines(spline_list_type * spline_list, fitting_opts_type * fitting_opts)\n{\n  unsigned this_spline;\n  gboolean found_cubic = FALSE;\n  unsigned length = SPLINE_LIST_LENGTH(*spline_list);\n\n  LOG(\"\\nChecking for bad lines (length %u):\\n\", length);\n\n  /* First see if there are any splines in the fitted shape.  */\n  for (this_spline = 0; this_spline < length; this_spline++) {\n    if (SPLINE_DEGREE(SPLINE_LIST_ELT(*spline_list, this_spline)) == CUBICTYPE) {\n      found_cubic = TRUE;\n      break;\n    }\n  }\n\n  /* If so, change lines back to splines (we haven't done anything to\n     their control points, so we only have to change the degree) unless\n     the spline is close enough to being a line.  */\n  if (found_cubic)\n    for (this_spline = 0; this_spline < length; this_spline++) {\n      spline_type s = SPLINE_LIST_ELT(*spline_list, this_spline);\n\n      if (SPLINE_DEGREE(s) == LINEARTYPE) {\n        LOG(\"  #%u: \", this_spline);\n        if (SPLINE_LINEARITY(s) > fitting_opts->line_reversion_threshold) {\n          LOG(\"reverted, \");\n          SPLINE_DEGREE(SPLINE_LIST_ELT(*spline_list, this_spline))\n              = CUBICTYPE;\n        }\n        LOG(\"linearity %.3f.\\n\", SPLINE_LINEARITY(s));\n      }\n  } else\n    LOG(\"  No lines.\\n\");\n}\n\n/* Lists of array indices (well, that is what we use it for).  */\n\nstatic index_list_type new_index_list(void)\n{\n  index_list_type index_list;\n\n  index_list.data = NULL;\n  INDEX_LIST_LENGTH(index_list) = 0;\n\n  return index_list;\n}\n\nstatic void free_index_list(index_list_type * index_list)\n{\n  if (INDEX_LIST_LENGTH(*index_list) > 0) {\n    free(index_list->data);\n    index_list->data = NULL;\n    INDEX_LIST_LENGTH(*index_list) = 0;\n  }\n}\n\nstatic void append_index(index_list_type * list, unsigned new_index)\n{\n  INDEX_LIST_LENGTH(*list)++;\n  XREALLOC(list->data, INDEX_LIST_LENGTH(*list) * sizeof(unsigned));\n  list->data[INDEX_LIST_LENGTH(*list) - 1] = new_index;\n}\n\n/* Turn an real point into a integer one.  */\n\nstatic at_coord real_to_int_coord(at_real_coord real_coord)\n{\n  at_coord int_coord;\n\n  int_coord.x = lround(real_coord.x);\n  int_coord.y = lround(real_coord.y);\n\n  return int_coord;\n}\n\n/* Return the Euclidean distance between P1 and P2.  */\n\nstatic gfloat distance(at_real_coord p1, at_real_coord p2)\n{\n  gfloat x = p1.x - p2.x, y = p1.y - p2.y, z = p1.z - p2.z;\n  return (gfloat) sqrt(SQUARE(x)\n                       + SQUARE(y) + SQUARE(z));\n}\n"
}