{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains For example."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['In this blog, we\u2019ll take a look at the different types of JavaScript errors, why they happen, and how to handle them in your application. (0.188)', 'There are many types of errors but they typically fall into one of 3 classes. (0.146)', 'One of the most common classes of error, this occurs when some value is not the type it\u2019s expected to be. (0.186)', 'Sometimes it is useful to create custom error types in addition to the ones that are already built into the JavaScript language. (0.195)', 'One possible use case for this is an application could be set up to handle different types of errors in different ways. (0.184)']."
        }
    ],
    "doc_id": "918",
    "text": "This blog is the second part in a two-part series on JavaScript error debugging. Read part one to learn about the inner workings of JavaScript source maps with code examples.\n\nIt\u2019s not a pretty sight when an application dies. Error messages can be difficult to understand, and we sometimes have to put our investigator hats on to solve the mystery and find the culprit.\n\nMost software developers spend all their time avoiding errors, but here at Bugsnag, our entire product is built around capturing and managing errors. As such, we deal a lot with the ins and outs of JavaScript errors and their related APIs. In this blog, we\u2019ll take a look at the different types of JavaScript errors, why they happen, and how to handle them in your application.\n\nAutomatically generated JS errors and why they happen\n\nThe first step to understanding JavaScript errors is to understand where they come from. Most JavaScript errors that occur in the wild are automatically generated from the JavaScript engine. There are many types of errors but they typically fall into one of 3 classes.\n\nJavaScript TypeError\n\nOne of the most common classes of error, this occurs when some value is not the type it\u2019s expected to be. Frequently this happens when calling something like a function that actually isn\u2019t a function because it is \u201cundefined\u201d or some other value.\n\nwindow.foo()\n\n### // => TypeError: window.foo is not a function\n\n[].length\n\n### // => 0\n\n[].length()\n\n### // => TypeError: array.length is not a function\n\n\n\nAnother common occurrence of TypeError is when trying to access a property on an undefined value.\n\nwindow.foo.bar\n\n### // => TypeError: Cannot read property 'bar' of undefined\n\n\n\nSyntaxError\n\nThese errors occur when the JavaScript engine is parsing a script and encounters syntactically invalid code. If a JavaScript file contains a syntax error, none of the code in the file will execute.\n\nconsole.log('hello')\n\nnotValid(\n\n\n\nNot only will this code produce an error, but the console.log before the invalid syntax won\u2019t even run.\n\nReferenceError\n\nThese occur when code refers to a value that does not exist in the current scope. For example:\n\nconsole.log(somethingMadeUp)\n\n### // => ReferenceError: somethingMadeUp is not defined\n\n\n\nManually throwing errors\n\nNot all errors are accidental. They can also be triggered intentionally. When an application isn\u2019t functioning correctly, it is preferable to fail loudly, explicitly, and clearly. Otherwise the cause of the problem could be unclear or, worse yet, not noticed by the developer at all.\n\nThe simplest way to manually trigger an error is by using a throw statement:\n\nthrow 'Invalid input';\n\n\n\nThis will automatically create an instance of an Error object with the message \u201cInvalid input\u201d, but the error instance can also be created manually and passed around.\n\nlet error = new Error('Invalid input')\n\n### // later\n\nthrow error;\n\n\n\nManually throwing JS errors is especially helpful for library authors as they can inform a developer using their library how they made a mistake. For example, when a function is called with an invalid argument.\n\nfunction sayName(name) {\n\nif(typeof name !== 'string') {\n\nthrow new Error('name must be a string, received:' + typeof name);\n\n}\n\n}\n\n\n\nIntercepting errors using try/catch\n\nIf you know that a particular bit of code is risky and might throw an error it can be wrapped in a try/catch statement.\n\ntry {\n\nsomeCrashyFunction()\n\n} catch(error) {\n\n### // display it to the user maybe\n\n### // and report it to Bugsnag\n\nBugsnag.notify(error);\n\n}\n\n\n\nTry catch blocks can also be nested inside each other. Once the error is handled, if it is desirable to pass the error higher up the call stack, it can be re-thrown.\n\ntry {\n\nsomeCrashyFunction()\n\n} catch(error) {\n\n### // Handle the error here:\n\n### // ...\n\n### // then pass it up the chain\n\nthrow error;\n\n}\n\n\n\nGotta catch \u2018em all with global error handling\n\nEven with the most diligently written code, errors can sometimes still slip through. It\u2019s okay. Mistakes happen. When they do, it\u2019s important to know about it quickly. That\u2019s where error reporting tools like Bugsnag fit in.\n\nHow global error handling works\n\nTo catch and handle all JavaScript errors that might happen in a browser session, we can hook into the window.onerror event handler. This allows setting up a global handler for any unhandled errors that might pop up. This is what the Bugsnag error reporting library hooks into for reporting uncaught errors from browser based JavaScript applications.\n\nIn a Node environment, there is no window object so the equivalent approach is to use process.on('unhandledException, callback).\n\nGlobal error handling is not a replacement for the fine grained control that can be achieved from try/catch statements. Instead, it serves as a safety net for exceptions that make it through the earlier lines of defense. By placing the error handling closer to the source of the potential problem, we will likely have a better idea of how best to deal with it and possibly recover before the user even notices a problem. And for everything that does slip through the cracks, we have peace of mind knowing our global error handler will surface the issues to us.\n\nBroken promises\n\nWith the advent of ES2015, we were given first class support for Promises in JavaScript which greatly improves the clarity of asynchronous code. One drawback of Promises is they have the tendency to swallow errors that occur in their .then() method. If there is an error generated in this method it will never bubble up to the global error handler and thus will not be reported to Bugsnag.\n\nfetch('https://my-api.endpoint')\n\n.then((response) => {\n\nresponse.thisMethodDoesNotExist() ### // this error will be swallowed\n\n\n\ndoSomethingElse() ### // this code will never run\n\n})\n\n\n\nThis is why it\u2019s always best practice to add a catch statement for all promise chains so any errors can be handled.\n\nfetch('https://my-api.endpoint')\n\n.then((response) => {\n\nresponse.thisMethodDoesNotExist()\n\ndoSomethingElse() ### // this code will never run\n\n})\n\n.catch((error) => {\n\nconsole.error(error)\n\n### // # => response.thisMethodDoesNotExist is not a function\n\nBugsnag.notify(error)\n\n### // show the error to the user\n\n});\n\n\n\nThis solves the problem of invisible errors, but it has a couple of drawbacks. First of all, it is cumbersome to write this error handling code for every promise we use. Secondly, if an error occurs in the catch statement, it will be swallowed as well and we are right back where we started. In order to get around this, we can hook into a global unhandled promise rejection handler.\n\nwindow.addEventListener(\"unhandledrejection\", (event) => {\n\nconsole.error(event.reason);\n\n// report the error here\n\n});\n\n\n\nNow any promise that fails and does not have an explicit catch handler will trigger the unhandledrejection event.\n\nIf you are using the bugsnag-js notifier, then unhandled promise rejections will automatically be caught and logged to Bugsnag so you don\u2019t have to worry about missing them.\n\nProperties of an error\n\nOnce an error has been captured, it can be inspected in order to pull useful information out of it. Most important are the name, message, and stack properties.\n\nThe first bits of useful information are the error\u2019s name and message. These fields are what get displayed for error listings in the Bugsnag inbox as well as what gets printed to the browser console.\n\nThe message of an error is set when it is initialized.\n\nlet error = new Error('This is my message')\n\nconsole.log(error.message)\n\n### // => This is my message\n\n\n\nBy default the error\u2019s name is the same as its constructor function so when an error is created using new Error('oh no!') or throw('oh no!') its name will be \u201cError\u201d. If you create an error using new TypeError('oh no!') its name would be \u201cTypeError\u201d. The name of an error can be overridden simply by setting it.\n\nlet myError = new Error('some message');\n\nmyError.name = 'ValidationError';\n\nthrow myError;\n\n\n\nHere we\u2019ve changed the error name to ValidationError, and this will be reflected in the Bugsnag dashboard; however, in some browsers (e.g. Chrome), it will still be printed to the console as \u201cError\u201d. To get around this, custom error classes can be used which we\u2019ll talk about a little later in this article.\n\nStacktraces\n\nThe Error.prototype.stack property contains the stacktrace for the error. The stacktrace is stored on the error as a simple string where each function in the stack is separated by newline characters. In the bugsnag-js library, we use a utility called error-stack-parser to parse the stacktrace into a useful data structure.\n\nIt is important to note that the stacktrace is determined by where the error was initialized, not where it was thrown. This means that if an error is created and returned from functionA and then thrown in functionB, the top of the stacktrace will be functionA.\n\nIt\u2019s likely that you\u2019ll minify your JavaScript code, and when you do, the lines in the stacktrace will not match up with the original source files. In order to find the original source, we use source maps to look up and translate the stacktrace. Learn more about how source maps work in our other blog in this series the Anatomy of source maps.\n\nCreating custom error types\n\nSometimes it is useful to create custom error types in addition to the ones that are already built into the JavaScript language. One possible use case for this is an application could be set up to handle different types of errors in different ways.\n\nFor example, in a Node application, perhaps we would have a special error class for validation errors in API requests. If a validation error is caught, the application would know to respond with an HTTP 400 status.\n\nCustom errors also allow capturing additional custom data with an error that is specific to that error class.\n\nES6 classes make the task of defining custom error types extremely trivial. For example, if we wanted to throw a specific type of error for invalid fields, we could define it like this.\n\nclass ValidationError extends Error {\n\nconstructor(field, reason) {\n\nsuper(reason);\n\nthis.field = field;\n\nthis.reason = reason;\n\n### // the next line is important so that the ValidationError constructor is not part\n\n### // of the resulting stacktrace\n\nError.captureStackTrace(this, ValidationError);\n\n}\n\n\n\n### // we can also define custom methods on this class\n\nprettyMessage() {\n\nreturn `ValidationError: [${this.fields}] reason: ${this.reason}`;\n\n### // ex: \"ValidationError: [age] reason: Must be a number\"\n\n}\n\n}\n\n\n\nThen the error handling code can make use of instanceof to determine what type of error was thrown and respond appropriately. In an Express.js application for example, custom middleware can be set up to accomplish this.\n\napp.use(function errorHandler (error, req, res, next) {\n\nif (error instance of ValidationError) {\n\n### // respond with 400 status and include relevant error details\n\nreturn res.status(400).json({\n\ntype: error.name,\n\nmessage: error.prettyMessage(),\n\nfield: error.field,\n\n});\n\n} else {\n\n### // This is some other kind of error, let the default error handler deal with it\n\nnext(error)\n\n}\n\n})\n\n\n\nAlthough this example is using Express.js middleware, a similar approach can be taken in other types of JavaScript applications using a simple try/catch.\n\ntry {\n\nsubmitForm();\n\n} catch (error) {\n\nif (error instance of ValidationError) {\n\n### // show the error to the user\n\ndisplayErrorMessage(error.prettyMessage());\n\n} else {\n\n###// pass it to the default error handler\n\nthrow error;\n\n}\n\n}\n\n\n\nWithout custom error classes, this kind of specialized error handling would be much more difficult.It would require doing something hacky, like comparing the error message or some custom property. Luckily, using the error class for comparison is much more explicit.\n\nWrapping up\n\nWhen applications fail, ideally they provide a smooth experience for the user, but for the developer, they should fail loudly and clearly so the problem can be quickly analyzed. Properly utilizing the tools the JavaScript language provides for error handling can help to clarify the opaque anomalies in an application so they can be understood quickly and addressed.\n\n\u2014\u2014\u2014\n\nTry Bugsnag\u2019s JavaScript error reporting, free for 14-days."
}