{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains For example."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "9035",
    "text": "Q:\n\nHow to find a time is one hour before and within my custom time in iOS\n\nI need to start download exactly one hour before or within my custom time. \nFor example I should start to download at 7 AM or with 8 AM (8 AM is my custom time). How I can achieve this. the following is my code,\nAppDelegate * iDelegate = (AppDelegate *)[[UIApplication sharedApplication] delegate];\n    iDelegate.mStartTime = [[NSUserDefaults standardUserDefaults] objectForKey:START_TIME];\n    int stHr = [[[iDelegate.mStartTime componentsSeparatedByString:@\":\"] objectAtIndex:0] intValue];\n    int stMin = [[[iDelegate.mStartTime componentsSeparatedByString:@\":\"] objectAtIndex:1] intValue];\n    int formStTime = (stHr*60)+stMin;\n    NSDate *today = [[[NSDate alloc] init]autorelease];\n\n    NSCalendar *gregorian = [[[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]autorelease];\n    NSDateComponents *offsetComponents = [[[NSDateComponents alloc] init]autorelease];\n    [offsetComponents setHour:+1];\n    NSDate *modifiedDate = [gregorian dateByAddingComponents:offsetComponents toDate:today options:0];\n    NSDateComponents * timecomponents = [[NSCalendar currentCalendar] components:(NSHourCalendarUnit | NSMinuteCalendarUnit) fromDate:modifiedDate];\n\n    NSInteger currentHour = [timecomponents hour];\n    NSInteger currtMin = [timecomponents minute];\n    int nowTime = (currentHour*60)+currtMin;\n    if (nowTime <= formStTime || nowTime >= formStTime)\n    {\n        // start download\n    }\n\nBut I should not download if the current time is 8 AM or after 8 AM . \nWhat is the mistake in my code ? Please suggest. Thanks. \n\nA:\n\nI have not considered in detail all your code's logic, but this struck to me:\nif (nowTime <= formStTime || nowTime >= formStTime)\n\nthis condition will be always true. This explains why your code is not working as you wish since it should always do the downloading, even after 8AM. You are after a condition link this:\nif (nowTime >= minimumTime || nowTime < maximumTime)\n\nHowever, I have not clear from your question how you define minimum and maximumTime so cannot advise further. If formStTime is your minimumTime and we assume that maximumTime is just one hour later, you could have:\nif (nowTime >= formStTime || nowTime < formStTime + 60)\n\n(If I read correctly your code.)\nEDIT: after your clarification in the comments, the condition to start the download would be:\nif (nowTime < formStTime)\n  //-- start download\n\nTo handle the second part of your requirements (stopping the download at the given maximum time) you will need a different logic altogether. One way of doing it would be starting a NSTimer when you start a download that will fire at the right time; then, you would check if the download is still going on and stop it. A NSTimer is just one of multiple possibilities you have (you could also use displatch_after), but the basic idea will not change. \nE.g.:\nif (nowTime < formStTime) {\n\n    //--= start download\n\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:(formStTime - nowTime)*60 //-- seconds\n   target:self\n   selector:@selector(timeExpired:)\n   userInfo:nil\n   repeats:NO];\n}\n\nthen in the handler function:\n- (void)timeExpired:(NSTimer*)timer {\n\n       if (downloadStillOngoing)\n         //-- stop the download\n\n}\n\nWhen your download is done, you should call [self.timer invalidate], also.\nHowever, you will need to fill a number of gaps in my sketch implementation to get to a working solution. If you need more help about stopping the download, you will need to provide more information about how you are doing the download and possibly ask a new question.\n\n"
}