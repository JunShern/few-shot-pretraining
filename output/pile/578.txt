{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "578",
    "text": "Q:\n\nIs std::move(*this) a good pattern?\n\nIn order to make this code with C++11 reference qualifiers work as expected I have to introduce a std::move(*this) that doesn't sound right.\n#include<iostream>\nstruct A{\n    void gun() const&{std::cout << \"gun const&\" << std::endl;}\n    void gun() &&{std::cout << \"gun&&\" << std::endl;}\n    void fun() const&{gun();}\n    void fun() &&{std::move(*this).gun();} // <-- is this correct? or is there a better option\n};\n\nint main(){\n    A a; a.fun(); // prints gun const&\n    A().fun(); // prints gun&&\n}\n\nSomething doesn't sound right about it. Is the std::move necessary? Is this a recommended use for it? For the moment if I don't use it I get gun const& in both cases which is not the expected result.\n(It seems that *this is implicit and lvalue reference always, which makes sense but then the only way to escape to use move)\nTested with clang 3.4 and gcc 4.8.3.\n\nEDIT: This is what I understand from @hvd answer:\n1) std::move(*this) is syntactically and conceptually correct\n2) However, if gun is not part of the desired interface, there no reason to overload the lv-ref and rv-ref version of it. And two functions with different names can do the same job. After all the ref-qualifiers matters at the interface level, which is generally only the public part.\nstruct A{\n    private:\n    void gun() const{std::cout << \"gun const&\" << std::endl;}\n    void gun_rv(){std::cout << \"gun called from fun&&\" << std::endl;}\n    public:\n    void fun() const&{gun();}\n    void fun() &&{gun_rv();} // no need for `std::move(*this)`.\n};\n\nBut again, if gun is part of the (generic) interface then std::move(*this) is necessary, but only then. And also, even if gun is not part of the interface there readability advantages in not splitting the function gun as two differently named function and the cost of this is, well..., std::move(*this).\nEDIT 2: In retrospect this is similar to the C++98 case of const and no-const overload of the same function. In some cases it makes sense to use const_cast (another form of cast) to not repeat code and have the two functions with the same name (https://stackoverflow.com/a/124209/225186)\n\nA:\n\nYes, *this is always an lvalue, no matter how a member function is called, so if you want the compiler to treat it as an rvalue, you need to use std::move or equivalent. It has to be, considering this class:\nstruct A {\n  void gun() &; // leaves object usable\n  void gun() &&; // makes object unusable\n\n  void fun() && {\n    gun();\n    gun();\n  }\n};\n\nMaking *this an rvalue would suggest that fun's first call to gun can leave the object unusable. The second call would then fail, possibly badly. This is not something that should happen implicitly.\nThis is the same reason why inside void f(T&& t), t is an lvalue. In that respect, *this is no different from any reference function parameter.\n\n"
}