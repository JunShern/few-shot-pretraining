{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "744",
    "text": "Q:\n\nRotating 3D wireframe\n\nThis code consumes a lot of CPU. Could you tell me where it is possible to improve the code or change the way rendering?\nOr it is possible to reduce the overhead of calculations? If you are using only 1 point when drawing the load on the CPU is not changed! Load 50-60%\nUbuntu 15.04 / intel\u00ae Core \u2122 i5-3230M CPU @ 2.60GHz \u00d7 4\nRun the code without rendering lines - 20-30% load. So they are quite costly... \nDemo: http://codepen.io/jonfint/full/VLYMMW\n\nvar canvas = document.getElementById(\"canvas\"),\n    ctx = canvas.getContext('2d'),\n    points = [],\n    r = 0;\n\nvar a = 50; // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u0447\u0435\u043a\nvar b = 1; // \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043f\u043e\u0432\u043e\u0440\u043e\u0442\u0430\nvar d = 20; // \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435 \u0440\u0430\u0434\u0438\u0443\u0441\u0430*\nvar minDist = 200; // ??\nvar dist; // ??\n\ncanvas.width = 500;    // Originally window.innerWidth, changed for Stack Snippet\ncanvas.height = 600;   // Originally window.innerHeight, changed for Stack Snippet\n\nfor (var i = 0; i < a; i++) {\n    var rand = Math.random() * canvas.height;\n\n    points.push({\n        cy: rand,\n        cx: rand * 0.3 + 300,\n        r: 360 / a * i,\n        p: {x: null, y: null},\n        d: Math.random() * (d + 5) + 50,\n        s: (Math.random() - 0.5) * 0.7,\n        size: Math.random() * 3 + 1,\n    })\n}\n\nfunction render(){\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    ctx.fillStyle = '#202020';\n    for (var i=0, len = points.length; i < len; i++) {\n        var p = points[i];\n\n        for (var j = i + 1; j < points.length; j++) {\n            var p2 = points[j];\n            distance(p.p.x, p.p.y, p2.p.x, p2.p.y);\n        }\n\n        p.r += p.s;\n\n        var vel = {\n            x: p.d * Math.cos(p.r * Math.PI / 180),\n            y: p.d * Math.sin(p.r * Math.PI / 180) / 2\n        };\n\n        var centx, centy;\n        centx = p.p.x - p.size * 0.5;\n        centy = p.p.y - p.size * 0.5;\n        ctx.beginPath();\n        ctx.rect(centx, centy, p.size, p.size);\n        ctx.fill();\n        ctx.closePath();\n\n        p.p.x = p.cx + vel.x;\n        p.p.y = p.cy + vel.y;\n    }\n}\n\nfunction distance(p1x, p1y, p2x, p2y) {\n    var dx = p1x - p2x;\n    var dy = p1y - p2y;\n    dist = Math.sqrt(dx*dx + dy*dy);\n      // \u041d\u0430\u0440\u0438\u0441\u043e\u0432\u0430\u0442\u044c \u043b\u0438\u043d\u0438\u044e, \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043c\u0435\u043d\u044c\u0448\u0435, \u0447\u0435\u043c minDistance\n    if (dist <= minDist) {\n        ctx.beginPath();\n        ctx.strokeStyle = 'rgba(200, 200, 200,'+ (1.0-dist/minDist) +')';\n        ctx.moveTo(p1x, p1y);\n        ctx.lineTo(p2x, p2y);\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        ctx.closePath();\n    }  \n}\n\nwindow.requestAnimFrame = (function(){\n    return  window.requestAnimationFrame   ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame    ||\n        window.oRequestAnimationFrame      ||\n        window.msRequestAnimationFrame     ||\n    function(callback) {\n        window.setTimeout(callback, 1000 / 30);\n    };\n})();\n\n(function animloop() {\n    requestAnimFrame(animloop);\n    render();\n})();\n<canvas id=\"canvas\"></canvas>\n\nA:\n\nI profiled your code and calling your render function takes 3.1-4.2 ms on my machine (i7 2.1 ghz running chrome/linux). I managed to cut that to only 0.6 ms by removing what is AFAIK the performance killer in this type of drawings using the canvas API. Check it out for yourself http://codepen.io/anon/pen/QbwQmo\nThe performance killer that I'm talking about is that you're drawing a million separate paths instead of batching them all in a single .beginPath ... .stroke. The catch is however that you can't have multiple colors (alpha levels) in the same path - so changing the color for every segment is not possible anymore. You could instead bucketize the paths - choose 10 shades of grey and add segments to these buckets; then call .stroke for each bucket (that'll amount to max 10 calls - way better than (50*50 which is what you can have)). The only way to overcome this limitation of the canvas API is to not use it in the first place :). Instead use a WebGL renderer (pixi.js, goo.js, three.js).\nThere's another thing which you can do to increase performance especially if you'll want more than 50 points. Right now you're checking every point against every other point. The number of calls to distance (not the best name btw) grows quadratically with the number of points. You can reduce the number of checks by discarding points that are too far - and you achieve this by splitting the whole space ([0...600] x [0...600]) into smaller buckets of 100 x 100 or something. You'd have to update the buckets every frame such that they contain the points that lie within their bounds. The upside is that you only need to check points in nearby buckets and not in the whole space.\n(Disclaimer: I am a dev of goo.js)\n\nA:\n\nI see these performance reducers in your code:\n\nResetting context state is modestly expensive--especially when done inside a loop. Don't needlessly reassign ctx.fillStyle = '#202020' inside your render loop. Just do it once at the start of your app.\nMath trig methods are expensive. Prebuild the Math.cos & Math.sin values you need into a lookup table. You may need to confine your p.r values to a slightly more limited set of values matching the lookup table. \nMath.sqrt is extremely expensive-especially when done within nested loops (50*50==2500 distance calculations per animation frame!). Instead, do the equally effective test on the squared values. This fix may get you \"the most bang for the buck\":\n// at the top of your app\nvar minDistSquared = minDist*minDist;\n\n// in your distance function\nvar dx = p1x - p2x;\nvar dy = p1y - p2y;\ndist = Math.sqrt(dx*dx + dy*dy);\n  // ?????????? ?????, ???? ?????????? ??????, ??? minDistance\nif (dx*dx+dy*dy <= minDistSquared) {\n    // do stuff\n}\n\nResetting context state is modestly expensive--especially when done inside a loop. You'll need to perf-test this one: Resetting the opacity using context.globalAlpha may be faster than resetting the alpha value of the context.strokeStyle. Or alternatively, confine your opacities to a smaller set and sort the points based on opacity before drawing them (again, perf-test required). \nCalling a function is slightly expensive--more so when done inside a loop (50*50==2500 times). Move your function distance calculation & drawing inside function render.\nMinor improvement--almost not worth mentioning: use while loops to iterate through points: var pointsCountdown=points.length and then while(--pointsCountdown) \n\n"
}