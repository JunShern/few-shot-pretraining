{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "6628",
    "text": "/*\n** deko3d Example 03: Cube\n** This example shows how to draw a basic rotating cube.\n** New concepts in this example:\n** - Setting up and using a depth buffer\n** - Setting up uniform buffers\n** - Basic 3D maths, including projection matrices\n** - Updating uniforms with a dynamic command buffer\n** - Adjusting resolution dynamically by recreating resources (720p handheld/1080p docked)\n** - Depth buffer discard after a barrier\n*/\n\n// Sample Framework headers\n#include \"SampleFramework/CApplication.h\"\n#include \"SampleFramework/CMemPool.h\"\n#include \"SampleFramework/CShader.h\"\n#include \"SampleFramework/CCmdMemRing.h\"\n\n// C++ standard library headers\n#include <array>\n#include <optional>\n\n// GLM headers\n#define GLM_FORCE_DEFAULT_ALIGNED_GENTYPES // Enforces GLSL std140/std430 alignment rules for glm types\n#define GLM_FORCE_INTRINSICS               // Enables usage of SIMD CPU instructions (requiring the above as well)\n#include <glm/vec3.hpp>\n#include <glm/vec4.hpp>\n#include <glm/mat4x4.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n\nnamespace\n{\n    struct Vertex\n    {\n        float position[3];\n        float color[3];\n    };\n\n    constexpr std::array VertexAttribState =\n    {\n        DkVtxAttribState{ 0, 0, offsetof(Vertex, position), DkVtxAttribSize_3x32, DkVtxAttribType_Float, 0 },\n        DkVtxAttribState{ 0, 0, offsetof(Vertex, color),    DkVtxAttribSize_3x32, DkVtxAttribType_Float, 0 },\n    };\n\n    constexpr std::array VertexBufferState =\n    {\n        DkVtxBufferState{ sizeof(Vertex), 0 },\n    };\n\n    constexpr std::array CubeVertexData =\n    {\n        // +X face\n        Vertex{ { +1.0f, +1.0f, +1.0f }, { 1.0f, 0.0f, 0.0f } },\n        Vertex{ { +1.0f, -1.0f, +1.0f }, { 0.0f, 1.0f, 0.0f } },\n        Vertex{ { +1.0f, -1.0f, -1.0f }, { 0.0f, 0.0f, 1.0f } },\n        Vertex{ { +1.0f, +1.0f, -1.0f }, { 1.0f, 1.0f, 0.0f } },\n\n        // -X face\n        Vertex{ { -1.0f, +1.0f, -1.0f }, { 1.0f, 0.0f, 0.0f } },\n        Vertex{ { -1.0f, -1.0f, -1.0f }, { 0.0f, 1.0f, 0.0f } },\n        Vertex{ { -1.0f, -1.0f, +1.0f }, { 0.0f, 0.0f, 1.0f } },\n        Vertex{ { -1.0f, +1.0f, +1.0f }, { 1.0f, 1.0f, 0.0f } },\n\n        // +Y face\n        Vertex{ { -1.0f, +1.0f, -1.0f }, { 1.0f, 0.0f, 0.0f } },\n        Vertex{ { -1.0f, +1.0f, +1.0f }, { 0.0f, 1.0f, 0.0f } },\n        Vertex{ { +1.0f, +1.0f, +1.0f }, { 0.0f, 0.0f, 1.0f } },\n        Vertex{ { +1.0f, +1.0f, -1.0f }, { 1.0f, 1.0f, 0.0f } },\n\n        // -Y face\n        Vertex{ { -1.0f, -1.0f, +1.0f }, { 1.0f, 0.0f, 0.0f } },\n        Vertex{ { -1.0f, -1.0f, -1.0f }, { 0.0f, 1.0f, 0.0f } },\n        Vertex{ { +1.0f, -1.0f, -1.0f }, { 0.0f, 0.0f, 1.0f } },\n        Vertex{ { +1.0f, -1.0f, +1.0f }, { 1.0f, 1.0f, 0.0f } },\n\n        // +Z face\n        Vertex{ { -1.0f, +1.0f, +1.0f }, { 1.0f, 0.0f, 0.0f } },\n        Vertex{ { -1.0f, -1.0f, +1.0f }, { 0.0f, 1.0f, 0.0f } },\n        Vertex{ { +1.0f, -1.0f, +1.0f }, { 0.0f, 0.0f, 1.0f } },\n        Vertex{ { +1.0f, +1.0f, +1.0f }, { 1.0f, 1.0f, 0.0f } },\n\n        // -Z face\n        Vertex{ { +1.0f, +1.0f, -1.0f }, { 1.0f, 0.0f, 0.0f } },\n        Vertex{ { +1.0f, -1.0f, -1.0f }, { 0.0f, 1.0f, 0.0f } },\n        Vertex{ { -1.0f, -1.0f, -1.0f }, { 0.0f, 0.0f, 1.0f } },\n        Vertex{ { -1.0f, +1.0f, -1.0f }, { 1.0f, 1.0f, 0.0f } },\n    };\n\n    struct Transformation\n    {\n        glm::mat4 mdlvMtx;\n        glm::mat4 projMtx;\n    };\n\n    inline float fractf(float x)\n    {\n        return x - floorf(x);\n    }\n}\n\nclass CExample03 final : public CApplication\n{\n    static constexpr unsigned NumFramebuffers = 2;\n    static constexpr unsigned StaticCmdSize = 0x10000;\n    static constexpr unsigned DynamicCmdSize = 0x10000;\n\n    dk::UniqueDevice device;\n    dk::UniqueQueue queue;\n\n    std::optional<CMemPool> pool_images;\n    std::optional<CMemPool> pool_code;\n    std::optional<CMemPool> pool_data;\n\n    dk::UniqueCmdBuf cmdbuf;\n    dk::UniqueCmdBuf dyncmd;\n    CCmdMemRing<NumFramebuffers> dynmem;\n\n    CShader vertexShader;\n    CShader fragmentShader;\n\n    Transformation transformState;\n    CMemPool::Handle transformUniformBuffer;\n\n    CMemPool::Handle vertexBuffer;\n\n    uint32_t framebufferWidth;\n    uint32_t framebufferHeight;\n\n    CMemPool::Handle depthBuffer_mem;\n    CMemPool::Handle framebuffers_mem[NumFramebuffers];\n\n    dk::Image depthBuffer;\n    dk::Image framebuffers[NumFramebuffers];\n    DkCmdList framebuffer_cmdlists[NumFramebuffers];\n    dk::UniqueSwapchain swapchain;\n\n    DkCmdList render_cmdlist;\n\npublic:\n    CExample03()\n    {\n        // Create the deko3d device\n        device = dk::DeviceMaker{}.create();\n\n        // Create the main queue\n        queue = dk::QueueMaker{device}.setFlags(DkQueueFlags_Graphics).create();\n\n        // Create the memory pools\n        pool_images.emplace(device, DkMemBlockFlags_GpuCached | DkMemBlockFlags_Image, 16*1024*1024);\n        pool_code.emplace(device, DkMemBlockFlags_CpuUncached | DkMemBlockFlags_GpuCached | DkMemBlockFlags_Code, 128*1024);\n        pool_data.emplace(device, DkMemBlockFlags_CpuUncached | DkMemBlockFlags_GpuCached, 1*1024*1024);\n\n        // Create the static command buffer and feed it freshly allocated memory\n        cmdbuf = dk::CmdBufMaker{device}.create();\n        CMemPool::Handle cmdmem = pool_data->allocate(StaticCmdSize);\n        cmdbuf.addMemory(cmdmem.getMemBlock(), cmdmem.getOffset(), cmdmem.getSize());\n\n        // Create the dynamic command buffer and allocate memory for it\n        dyncmd = dk::CmdBufMaker{device}.create();\n        dynmem.allocate(*pool_data, DynamicCmdSize);\n\n        // Load the shaders\n        vertexShader.load(*pool_code, \"romfs:/shaders/transform_vsh.dksh\");\n        fragmentShader.load(*pool_code, \"romfs:/shaders/color_fsh.dksh\");\n\n        // Create the transformation uniform buffer\n        transformUniformBuffer = pool_data->allocate(sizeof(transformState), DK_UNIFORM_BUF_ALIGNMENT);\n\n        // Load the vertex buffer\n        vertexBuffer = pool_data->allocate(sizeof(CubeVertexData), alignof(Vertex));\n        memcpy(vertexBuffer.getCpuAddr(), CubeVertexData.data(), vertexBuffer.getSize());\n    }\n\n    ~CExample03()\n    {\n        // Destroy the framebuffer resources\n        destroyFramebufferResources();\n\n        // Destroy the vertex buffer (not strictly needed in this case)\n        vertexBuffer.destroy();\n\n        // Destroy the uniform buffer (not strictly needed in this case)\n        transformUniformBuffer.destroy();\n    }\n\n    void createFramebufferResources()\n    {\n        // Create layout for the depth buffer\n        dk::ImageLayout layout_depthbuffer;\n        dk::ImageLayoutMaker{device}\n            .setFlags(DkImageFlags_UsageRender | DkImageFlags_HwCompression)\n            .setFormat(DkImageFormat_Z24S8)\n            .setDimensions(framebufferWidth, framebufferHeight)\n            .initialize(layout_depthbuffer);\n\n        // Create the depth buffer\n        depthBuffer_mem = pool_images->allocate(layout_depthbuffer.getSize(), layout_depthbuffer.getAlignment());\n        depthBuffer.initialize(layout_depthbuffer, depthBuffer_mem.getMemBlock(), depthBuffer_mem.getOffset());\n\n        // Create layout for the framebuffers\n        dk::ImageLayout layout_framebuffer;\n        dk::ImageLayoutMaker{device}\n            .setFlags(DkImageFlags_UsageRender | DkImageFlags_UsagePresent | DkImageFlags_HwCompression)\n            .setFormat(DkImageFormat_RGBA8_Unorm)\n            .setDimensions(framebufferWidth, framebufferHeight)\n            .initialize(layout_framebuffer);\n\n        // Create the framebuffers\n        std::array<DkImage const*, NumFramebuffers> fb_array;\n        uint64_t fb_size  = layout_framebuffer.getSize();\n        uint32_t fb_align = layout_framebuffer.getAlignment();\n        for (unsigned i = 0; i < NumFramebuffers; i ++)\n        {\n            // Allocate a framebuffer\n            framebuffers_mem[i] = pool_images->allocate(fb_size, fb_align);\n            framebuffers[i].initialize(layout_framebuffer, framebuffers_mem[i].getMemBlock(), framebuffers_mem[i].getOffset());\n\n            // Generate a command list that binds it\n            dk::ImageView colorTarget{ framebuffers[i] }, depthTarget{ depthBuffer };\n            cmdbuf.bindRenderTargets(&colorTarget, &depthTarget);\n            framebuffer_cmdlists[i] = cmdbuf.finishList();\n\n            // Fill in the array for use later by the swapchain creation code\n            fb_array[i] = &framebuffers[i];\n        }\n\n        // Create the swapchain using the framebuffers\n        swapchain = dk::SwapchainMaker{device, nwindowGetDefault(), fb_array}.create();\n\n        // Generate the main rendering cmdlist\n        recordStaticCommands();\n\n        // Initialize the projection matrix\n        transformState.projMtx = glm::perspectiveRH_ZO(\n            glm::radians(40.0f),\n            float(framebufferWidth)/float(framebufferHeight),\n            0.01f, 1000.0f);\n    }\n\n    void destroyFramebufferResources()\n    {\n        // Return early if we have nothing to destroy\n        if (!swapchain) return;\n\n        // Make sure the queue is idle before destroying anything\n        queue.waitIdle();\n\n        // Clear the static cmdbuf, destroying the static cmdlists in the process\n        cmdbuf.clear();\n\n        // Destroy the swapchain\n        swapchain.destroy();\n\n        // Destroy the framebuffers\n        for (unsigned i = 0; i < NumFramebuffers; i ++)\n            framebuffers_mem[i].destroy();\n\n        // Destroy the depth buffer\n        depthBuffer_mem.destroy();\n    }\n\n    void recordStaticCommands()\n    {\n        // Initialize state structs with deko3d defaults\n        dk::RasterizerState rasterizerState;\n        dk::ColorState colorState;\n        dk::ColorWriteState colorWriteState;\n        dk::DepthStencilState depthStencilState;\n\n        // Configure viewport and scissor\n        cmdbuf.setViewports(0, { { 0.0f, 0.0f, (float)framebufferWidth, (float)framebufferHeight, 0.0f, 1.0f } });\n        cmdbuf.setScissors(0, { { 0, 0, framebufferWidth, framebufferHeight } });\n\n        // Clear the color and depth buffers\n        cmdbuf.clearColor(0, DkColorMask_RGBA, 0.0f, 0.0f, 0.0f, 0.0f);\n        cmdbuf.clearDepthStencil(true, 1.0f, 0xFF, 0);\n\n        // Bind state required for drawing the cube\n        cmdbuf.bindShaders(DkStageFlag_GraphicsMask, { vertexShader, fragmentShader });\n        cmdbuf.bindUniformBuffer(DkStage_Vertex, 0, transformUniformBuffer.getGpuAddr(), transformUniformBuffer.getSize());\n        cmdbuf.bindRasterizerState(rasterizerState);\n        cmdbuf.bindColorState(colorState);\n        cmdbuf.bindColorWriteState(colorWriteState);\n        cmdbuf.bindDepthStencilState(depthStencilState);\n        cmdbuf.bindVtxBuffer(0, vertexBuffer.getGpuAddr(), vertexBuffer.getSize());\n        cmdbuf.bindVtxAttribState(VertexAttribState);\n        cmdbuf.bindVtxBufferState(VertexBufferState);\n\n        // Draw the cube\n        cmdbuf.draw(DkPrimitive_Quads, CubeVertexData.size(), 1, 0, 0);\n\n        // Fragment barrier, to make sure we finish previous work before discarding the depth buffer\n        cmdbuf.barrier(DkBarrier_Fragments, 0);\n\n        // Discard the depth buffer since we don't need it anymore\n        cmdbuf.discardDepthStencil();\n\n        // Finish off this command list\n        render_cmdlist = cmdbuf.finishList();\n    }\n\n    void render()\n    {\n        // Begin generating the dynamic command list, for commands that need to be sent only this frame specifically\n        dynmem.begin(dyncmd);\n\n        // Update the uniform buffer with the new transformation state (this data gets inlined in the command list)\n        dyncmd.pushConstants(\n            transformUniformBuffer.getGpuAddr(), transformUniformBuffer.getSize(),\n            0, sizeof(transformState), &transformState);\n\n        // Finish off the dynamic command list, and submit it to the queue\n        queue.submitCommands(dynmem.end(dyncmd));\n\n        // Acquire a framebuffer from the swapchain (and wait for it to be available)\n        int slot = queue.acquireImage(swapchain);\n\n        // Run the command list that attaches said framebuffer to the queue\n        queue.submitCommands(framebuffer_cmdlists[slot]);\n\n        // Run the main rendering command list\n        queue.submitCommands(render_cmdlist);\n\n        // Now that we are done rendering, present it to the screen\n        queue.presentImage(swapchain, slot);\n    }\n\n    void onOperationMode(AppletOperationMode mode) override\n    {\n        // Destroy the framebuffer resources\n        destroyFramebufferResources();\n\n        // Choose framebuffer size\n        chooseFramebufferSize(framebufferWidth, framebufferHeight, mode);\n\n        // Recreate the framebuffers and its associated resources\n        createFramebufferResources();\n    }\n\n    bool onFrame(u64 ns) override\n    {\n        hidScanInput();\n        u64 kDown = hidKeysDown(CONTROLLER_P1_AUTO);\n        if (kDown & KEY_PLUS)\n            return false;\n\n        float time = ns / 1000000000.0; // double precision division; followed by implicit cast to single precision\n        float tau = glm::two_pi<float>();\n\n        float period1 = fractf(time/8.0f);\n        float period2 = fractf(time/4.0f);\n\n        // Generate the model-view matrix for this frame\n        // Keep in mind that GLM transformation functions multiply to the right, so essentially we have:\n        //   mdlvMtx = Translate * RotateX * RotateY * Scale\n        // This means that the Scale operation is applied first, then RotateY, and so on.\n        transformState.mdlvMtx = glm::mat4{1.0f};\n        transformState.mdlvMtx = glm::translate(transformState.mdlvMtx, glm::vec3{0.0f, 0.0f, -3.0f});\n        transformState.mdlvMtx = glm::rotate(transformState.mdlvMtx, sinf(period2 * tau) * tau / 8.0f, glm::vec3{1.0f, 0.0f, 0.0f});\n        transformState.mdlvMtx = glm::rotate(transformState.mdlvMtx, -period1 * tau, glm::vec3{0.0f, 1.0f, 0.0f});\n        transformState.mdlvMtx = glm::scale(transformState.mdlvMtx, glm::vec3{0.5f});\n\n        render();\n        return true;\n    }\n};\n\nvoid Example03(void)\n{\n    CExample03 app;\n    app.run();\n}\n"
}