{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": true,
            "reason": "Found 6 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "8180",
    "text": "/*\n * pluto2.c - Satelco Easywatch Mobile Terrestrial Receiver [DVB-T]\n *\n * Copyright (C) 2005 Andreas Oberritter <obi@linuxtv.org>\n *\n * based on pluto2.c 1.10 - http://instinct-wp8.no-ip.org/pluto/\n * \tby Dany Salman <salmandany@yahoo.fr>\n *\tCopyright (c) 2004 TDF\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include \"demux.h\"\n#include \"dmxdev.h\"\n#include \"dvb_demux.h\"\n#include \"dvb_frontend.h\"\n#include \"dvb_net.h\"\n#include \"dvbdev.h\"\n#include \"tda1004x.h\"\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n#define DRIVER_NAME\t\t\"pluto2\"\n\n#define REG_PIDn(n)\t\t((n) << 2)\t/* PID n pattern registers */\n#define REG_PCAR\t\t0x0020\t\t/* PC address register */\n#define REG_TSCR\t\t0x0024\t\t/* TS ctrl & status */\n#define REG_MISC\t\t0x0028\t\t/* miscellaneous */\n#define REG_MMAC\t\t0x002c\t\t/* MSB MAC address */\n#define REG_IMAC\t\t0x0030\t\t/* ISB MAC address */\n#define REG_LMAC\t\t0x0034\t\t/* LSB MAC address */\n#define REG_SPID\t\t0x0038\t\t/* SPI data */\n#define REG_SLCS\t\t0x003c\t\t/* serial links ctrl/status */\n\n#define PID0_NOFIL\t\t(0x0001 << 16)\n#define PIDn_ENP\t\t(0x0001 << 15)\n#define PID0_END\t\t(0x0001 << 14)\n#define PID0_AFIL\t\t(0x0001 << 13)\n#define PIDn_PID\t\t(0x1fff <<  0)\n\n#define TSCR_NBPACKETS\t\t(0x00ff << 24)\n#define TSCR_DEM\t\t(0x0001 << 17)\n#define TSCR_DE\t\t\t(0x0001 << 16)\n#define TSCR_RSTN\t\t(0x0001 << 15)\n#define TSCR_MSKO\t\t(0x0001 << 14)\n#define TSCR_MSKA\t\t(0x0001 << 13)\n#define TSCR_MSKL\t\t(0x0001 << 12)\n#define TSCR_OVR\t\t(0x0001 << 11)\n#define TSCR_AFUL\t\t(0x0001 << 10)\n#define TSCR_LOCK\t\t(0x0001 <<  9)\n#define TSCR_IACK\t\t(0x0001 <<  8)\n#define TSCR_ADEF\t\t(0x007f <<  0)\n\n#define MISC_DVR\t\t(0x0fff <<  4)\n#define MISC_ALED\t\t(0x0001 <<  3)\n#define MISC_FRST\t\t(0x0001 <<  2)\n#define MISC_LED1\t\t(0x0001 <<  1)\n#define MISC_LED0\t\t(0x0001 <<  0)\n\n#define SPID_SPIDR\t\t(0x00ff <<  0)\n\n#define SLCS_SCL\t\t(0x0001 <<  7)\n#define SLCS_SDA\t\t(0x0001 <<  6)\n#define SLCS_CSN\t\t(0x0001 <<  2)\n#define SLCS_OVR\t\t(0x0001 <<  1)\n#define SLCS_SWC\t\t(0x0001 <<  0)\n\n#define TS_DMA_PACKETS\t\t(8)\n#define TS_DMA_BYTES\t\t(188 * TS_DMA_PACKETS)\n\n#define I2C_ADDR_TDA10046\t0x10\n#define I2C_ADDR_TUA6034\t0xc2\n#define NHWFILTERS\t\t8\n\nstruct pluto {\n\t/* pci */\n\tstruct pci_dev *pdev;\n\tu8 __iomem *io_mem;\n\n\t/* dvb */\n\tstruct dmx_frontend hw_frontend;\n\tstruct dmx_frontend mem_frontend;\n\tstruct dmxdev dmxdev;\n\tstruct dvb_adapter dvb_adapter;\n\tstruct dvb_demux demux;\n\tstruct dvb_frontend *fe;\n\tstruct dvb_net dvbnet;\n\tunsigned int full_ts_users;\n\tunsigned int users;\n\n\t/* i2c */\n\tstruct i2c_algo_bit_data i2c_bit;\n\tstruct i2c_adapter i2c_adap;\n\tunsigned int i2cbug;\n\n\t/* irq */\n\tunsigned int overflow;\n\tunsigned int dead;\n\n\t/* dma */\n\tdma_addr_t dma_addr;\n\tu8 dma_buf[TS_DMA_BYTES];\n\tu8 dummy[4096];\n};\n\nstatic inline struct pluto *feed_to_pluto(struct dvb_demux_feed *feed)\n{\n\treturn container_of(feed->demux, struct pluto, demux);\n}\n\nstatic inline struct pluto *frontend_to_pluto(struct dvb_frontend *fe)\n{\n\treturn container_of(fe->dvb, struct pluto, dvb_adapter);\n}\n\nstatic inline u32 pluto_readreg(struct pluto *pluto, u32 reg)\n{\n\treturn readl(&pluto->io_mem[reg]);\n}\n\nstatic inline void pluto_writereg(struct pluto *pluto, u32 reg, u32 val)\n{\n\twritel(val, &pluto->io_mem[reg]);\n}\n\nstatic inline void pluto_rw(struct pluto *pluto, u32 reg, u32 mask, u32 bits)\n{\n\tu32 val = readl(&pluto->io_mem[reg]);\n\tval &= ~mask;\n\tval |= bits;\n\twritel(val, &pluto->io_mem[reg]);\n}\n\nstatic void pluto_write_tscr(struct pluto *pluto, u32 val)\n{\n\t/* set the number of packets */\n\tval &= ~TSCR_ADEF;\n\tval |= TS_DMA_PACKETS / 2;\n\n\tpluto_writereg(pluto, REG_TSCR, val);\n}\n\nstatic void pluto_setsda(void *data, int state)\n{\n\tstruct pluto *pluto = data;\n\n\tif (state)\n\t\tpluto_rw(pluto, REG_SLCS, SLCS_SDA, SLCS_SDA);\n\telse\n\t\tpluto_rw(pluto, REG_SLCS, SLCS_SDA, 0);\n}\n\nstatic void pluto_setscl(void *data, int state)\n{\n\tstruct pluto *pluto = data;\n\n\tif (state)\n\t\tpluto_rw(pluto, REG_SLCS, SLCS_SCL, SLCS_SCL);\n\telse\n\t\tpluto_rw(pluto, REG_SLCS, SLCS_SCL, 0);\n\n\t/* try to detect i2c_inb() to workaround hardware bug:\n\t * reset SDA to high after SCL has been set to low */\n\tif ((state) && (pluto->i2cbug == 0)) {\n\t\tpluto->i2cbug = 1;\n\t} else {\n\t\tif ((!state) && (pluto->i2cbug == 1))\n\t\t\tpluto_setsda(pluto, 1);\n\t\tpluto->i2cbug = 0;\n\t}\n}\n\nstatic int pluto_getsda(void *data)\n{\n\tstruct pluto *pluto = data;\n\n\treturn pluto_readreg(pluto, REG_SLCS) & SLCS_SDA;\n}\n\nstatic int pluto_getscl(void *data)\n{\n\tstruct pluto *pluto = data;\n\n\treturn pluto_readreg(pluto, REG_SLCS) & SLCS_SCL;\n}\n\nstatic void pluto_reset_frontend(struct pluto *pluto, int reenable)\n{\n\tu32 val = pluto_readreg(pluto, REG_MISC);\n\n\tif (val & MISC_FRST) {\n\t\tval &= ~MISC_FRST;\n\t\tpluto_writereg(pluto, REG_MISC, val);\n\t}\n\tif (reenable) {\n\t\tval |= MISC_FRST;\n\t\tpluto_writereg(pluto, REG_MISC, val);\n\t}\n}\n\nstatic void pluto_reset_ts(struct pluto *pluto, int reenable)\n{\n\tu32 val = pluto_readreg(pluto, REG_TSCR);\n\n\tif (val & TSCR_RSTN) {\n\t\tval &= ~TSCR_RSTN;\n\t\tpluto_write_tscr(pluto, val);\n\t}\n\tif (reenable) {\n\t\tval |= TSCR_RSTN;\n\t\tpluto_write_tscr(pluto, val);\n\t}\n}\n\nstatic void pluto_set_dma_addr(struct pluto *pluto)\n{\n\tpluto_writereg(pluto, REG_PCAR, pluto->dma_addr);\n}\n\nstatic int pluto_dma_map(struct pluto *pluto)\n{\n\tpluto->dma_addr = pci_map_single(pluto->pdev, pluto->dma_buf,\n\t\t\tTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\n\n\treturn pci_dma_mapping_error(pluto->pdev, pluto->dma_addr);\n}\n\nstatic void pluto_dma_unmap(struct pluto *pluto)\n{\n\tpci_unmap_single(pluto->pdev, pluto->dma_addr,\n\t\t\tTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\n}\n\nstatic int pluto_start_feed(struct dvb_demux_feed *f)\n{\n\tstruct pluto *pluto = feed_to_pluto(f);\n\n\t/* enable PID filtering */\n\tif (pluto->users++ == 0)\n\t\tpluto_rw(pluto, REG_PIDn(0), PID0_AFIL | PID0_NOFIL, 0);\n\n\tif ((f->pid < 0x2000) && (f->index < NHWFILTERS))\n\t\tpluto_rw(pluto, REG_PIDn(f->index), PIDn_ENP | PIDn_PID, PIDn_ENP | f->pid);\n\telse if (pluto->full_ts_users++ == 0)\n\t\tpluto_rw(pluto, REG_PIDn(0), PID0_NOFIL, PID0_NOFIL);\n\n\treturn 0;\n}\n\nstatic int pluto_stop_feed(struct dvb_demux_feed *f)\n{\n\tstruct pluto *pluto = feed_to_pluto(f);\n\n\t/* disable PID filtering */\n\tif (--pluto->users == 0)\n\t\tpluto_rw(pluto, REG_PIDn(0), PID0_AFIL, PID0_AFIL);\n\n\tif ((f->pid < 0x2000) && (f->index < NHWFILTERS))\n\t\tpluto_rw(pluto, REG_PIDn(f->index), PIDn_ENP | PIDn_PID, 0x1fff);\n\telse if (--pluto->full_ts_users == 0)\n\t\tpluto_rw(pluto, REG_PIDn(0), PID0_NOFIL, 0);\n\n\treturn 0;\n}\n\nstatic void pluto_dma_end(struct pluto *pluto, unsigned int nbpackets)\n{\n\t/* synchronize the DMA transfer with the CPU\n\t * first so that we see updated contents. */\n\tpci_dma_sync_single_for_cpu(pluto->pdev, pluto->dma_addr,\n\t\t\tTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\n\n\t/* Workaround for broken hardware:\n\t * [1] On startup NBPACKETS seems to contain an uninitialized value,\n\t *     but no packets have been transferred.\n\t * [2] Sometimes (actually very often) NBPACKETS stays at zero\n\t *     although one packet has been transferred.\n\t * [3] Sometimes (actually rarely), the card gets into an erroneous\n\t *     mode where it continuously generates interrupts, claiming it\n\t *     has received nbpackets>TS_DMA_PACKETS packets, but no packet\n\t *     has been transferred. Only a reset seems to solve this\n\t */\n\tif ((nbpackets == 0) || (nbpackets > TS_DMA_PACKETS)) {\n\t\tunsigned int i = 0;\n\t\twhile (pluto->dma_buf[i] == 0x47)\n\t\t\ti += 188;\n\t\tnbpackets = i / 188;\n\t\tif (i == 0) {\n\t\t\tpluto_reset_ts(pluto, 1);\n\t\t\tdev_printk(KERN_DEBUG, &pluto->pdev->dev, \"resetting TS because of invalid packet counter\\n\");\n\t\t}\n\t}\n\n\tdvb_dmx_swfilter_packets(&pluto->demux, pluto->dma_buf, nbpackets);\n\n\t/* clear the dma buffer. this is needed to be able to identify\n\t * new valid ts packets above */\n\tmemset(pluto->dma_buf, 0, nbpackets * 188);\n\n\t/* reset the dma address */\n\tpluto_set_dma_addr(pluto);\n\n\t/* sync the buffer and give it back to the card */\n\tpci_dma_sync_single_for_device(pluto->pdev, pluto->dma_addr,\n\t\t\tTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\n}\n\nstatic irqreturn_t pluto_irq(int irq, void *dev_id)\n{\n\tstruct pluto *pluto = dev_id;\n\tu32 tscr;\n\n\t/* check whether an interrupt occurred on this device */\n\ttscr = pluto_readreg(pluto, REG_TSCR);\n\tif (!(tscr & (TSCR_DE | TSCR_OVR)))\n\t\treturn IRQ_NONE;\n\n\tif (tscr == 0xffffffff) {\n\t\tif (pluto->dead == 0)\n\t\t\tdev_err(&pluto->pdev->dev, \"card has hung or been ejected.\\n\");\n\t\t/* It's dead Jim */\n\t\tpluto->dead = 1;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t/* dma end interrupt */\n\tif (tscr & TSCR_DE) {\n\t\tpluto_dma_end(pluto, (tscr & TSCR_NBPACKETS) >> 24);\n\t\t/* overflow interrupt */\n\t\tif (tscr & TSCR_OVR)\n\t\t\tpluto->overflow++;\n\t\tif (pluto->overflow) {\n\t\t\tdev_err(&pluto->pdev->dev, \"overflow irq (%d)\\n\",\n\t\t\t\t\tpluto->overflow);\n\t\t\tpluto_reset_ts(pluto, 1);\n\t\t\tpluto->overflow = 0;\n\t\t}\n\t} else if (tscr & TSCR_OVR) {\n\t\tpluto->overflow++;\n\t}\n\n\t/* ACK the interrupt */\n\tpluto_write_tscr(pluto, tscr | TSCR_IACK);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pluto_enable_irqs(struct pluto *pluto)\n{\n\tu32 val = pluto_readreg(pluto, REG_TSCR);\n\n\t/* disable AFUL and LOCK interrupts */\n\tval |= (TSCR_MSKA | TSCR_MSKL);\n\t/* enable DMA and OVERFLOW interrupts */\n\tval &= ~(TSCR_DEM | TSCR_MSKO);\n\t/* clear pending interrupts */\n\tval |= TSCR_IACK;\n\n\tpluto_write_tscr(pluto, val);\n}\n\nstatic void pluto_disable_irqs(struct pluto *pluto)\n{\n\tu32 val = pluto_readreg(pluto, REG_TSCR);\n\n\t/* disable all interrupts */\n\tval |= (TSCR_DEM | TSCR_MSKO | TSCR_MSKA | TSCR_MSKL);\n\t/* clear pending interrupts */\n\tval |= TSCR_IACK;\n\n\tpluto_write_tscr(pluto, val);\n}\n\nstatic int pluto_hw_init(struct pluto *pluto)\n{\n\tpluto_reset_frontend(pluto, 1);\n\n\t/* set automatic LED control by FPGA */\n\tpluto_rw(pluto, REG_MISC, MISC_ALED, MISC_ALED);\n\n\t/* set data endianness */\n#ifdef __LITTLE_ENDIAN\n\tpluto_rw(pluto, REG_PIDn(0), PID0_END, PID0_END);\n#else\n\tpluto_rw(pluto, REG_PIDn(0), PID0_END, 0);\n#endif\n\t/* map DMA and set address */\n\tpluto_dma_map(pluto);\n\tpluto_set_dma_addr(pluto);\n\n\t/* enable interrupts */\n\tpluto_enable_irqs(pluto);\n\n\t/* reset TS logic */\n\tpluto_reset_ts(pluto, 1);\n\n\treturn 0;\n}\n\nstatic void pluto_hw_exit(struct pluto *pluto)\n{\n\t/* disable interrupts */\n\tpluto_disable_irqs(pluto);\n\n\tpluto_reset_ts(pluto, 0);\n\n\t/* LED: disable automatic control, enable yellow, disable green */\n\tpluto_rw(pluto, REG_MISC, MISC_ALED | MISC_LED1 | MISC_LED0, MISC_LED1);\n\n\t/* unmap DMA */\n\tpluto_dma_unmap(pluto);\n\n\tpluto_reset_frontend(pluto, 0);\n}\n\nstatic inline u32 divide(u32 numerator, u32 denominator)\n{\n\tif (denominator == 0)\n\t\treturn ~0;\n\n\treturn DIV_ROUND_CLOSEST(numerator, denominator);\n}\n\n/* LG Innotek TDTE-E001P (Infineon TUA6034) */\nstatic int lg_tdtpe001p_tuner_set_params(struct dvb_frontend *fe)\n{\n\tstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\n\tstruct pluto *pluto = frontend_to_pluto(fe);\n\tstruct i2c_msg msg;\n\tint ret;\n\tu8 buf[4];\n\tu32 div;\n\n\t// Fref = 166.667 Hz\n\t// Fref * 3 = 500.000 Hz\n\t// IF = 36166667\n\t// IF / Fref = 217\n\t//div = divide(p->frequency + 36166667, 166667);\n\tdiv = divide(p->frequency * 3, 500000) + 217;\n\tbuf[0] = (div >> 8) & 0x7f;\n\tbuf[1] = (div >> 0) & 0xff;\n\n\tif (p->frequency < 611000000)\n\t\tbuf[2] = 0xb4;\n\telse if (p->frequency < 811000000)\n\t\tbuf[2] = 0xbc;\n\telse\n\t\tbuf[2] = 0xf4;\n\n\t// VHF: 174-230 MHz\n\t// center: 350 MHz\n\t// UHF: 470-862 MHz\n\tif (p->frequency < 350000000)\n\t\tbuf[3] = 0x02;\n\telse\n\t\tbuf[3] = 0x04;\n\n\tif (p->bandwidth_hz == 8000000)\n\t\tbuf[3] |= 0x08;\n\n\tmsg.addr = I2C_ADDR_TUA6034 >> 1;\n\tmsg.flags = 0;\n\tmsg.buf = buf;\n\tmsg.len = sizeof(buf);\n\n\tif (fe->ops.i2c_gate_ctrl)\n\t\tfe->ops.i2c_gate_ctrl(fe, 1);\n\tret = i2c_transfer(&pluto->i2c_adap, &msg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == 0)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic int pluto2_request_firmware(struct dvb_frontend *fe,\n\t\t\t\t   const struct firmware **fw, char *name)\n{\n\tstruct pluto *pluto = frontend_to_pluto(fe);\n\n\treturn request_firmware(fw, name, &pluto->pdev->dev);\n}\n\nstatic struct tda1004x_config pluto2_fe_config = {\n\t.demod_address = I2C_ADDR_TDA10046 >> 1,\n\t.invert = 1,\n\t.invert_oclk = 0,\n\t.xtal_freq = TDA10046_XTAL_16M,\n\t.agc_config = TDA10046_AGC_DEFAULT,\n\t.if_freq = TDA10046_FREQ_3617,\n\t.request_firmware = pluto2_request_firmware,\n};\n\nstatic int frontend_init(struct pluto *pluto)\n{\n\tint ret;\n\n\tpluto->fe = tda10046_attach(&pluto2_fe_config, &pluto->i2c_adap);\n\tif (!pluto->fe) {\n\t\tdev_err(&pluto->pdev->dev, \"could not attach frontend\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpluto->fe->ops.tuner_ops.set_params = lg_tdtpe001p_tuner_set_params;\n\n\tret = dvb_register_frontend(&pluto->dvb_adapter, pluto->fe);\n\tif (ret < 0) {\n\t\tif (pluto->fe->ops.release)\n\t\t\tpluto->fe->ops.release(pluto->fe);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void pluto_read_rev(struct pluto *pluto)\n{\n\tu32 val = pluto_readreg(pluto, REG_MISC) & MISC_DVR;\n\tdev_info(&pluto->pdev->dev, \"board revision %d.%d\\n\",\n\t\t\t(val >> 12) & 0x0f, (val >> 4) & 0xff);\n}\n\nstatic void pluto_read_mac(struct pluto *pluto, u8 *mac)\n{\n\tu32 val = pluto_readreg(pluto, REG_MMAC);\n\tmac[0] = (val >> 8) & 0xff;\n\tmac[1] = (val >> 0) & 0xff;\n\n\tval = pluto_readreg(pluto, REG_IMAC);\n\tmac[2] = (val >> 8) & 0xff;\n\tmac[3] = (val >> 0) & 0xff;\n\n\tval = pluto_readreg(pluto, REG_LMAC);\n\tmac[4] = (val >> 8) & 0xff;\n\tmac[5] = (val >> 0) & 0xff;\n\n\tdev_info(&pluto->pdev->dev, \"MAC %pM\\n\", mac);\n}\n\nstatic int pluto_read_serial(struct pluto *pluto)\n{\n\tstruct pci_dev *pdev = pluto->pdev;\n\tunsigned int i, j;\n\tu8 __iomem *cis;\n\n\tcis = pci_iomap(pdev, 1, 0);\n\tif (!cis)\n\t\treturn -EIO;\n\n\tdev_info(&pdev->dev, \"S/N \");\n\n\tfor (i = 0xe0; i < 0x100; i += 4) {\n\t\tu32 val = readl(&cis[i]);\n\t\tfor (j = 0; j < 32; j += 8) {\n\t\t\tif ((val & 0xff) == 0xff)\n\t\t\t\tgoto out;\n\t\t\tprintk(\"%c\", val & 0xff);\n\t\t\tval >>= 8;\n\t\t}\n\t}\nout:\n\tprintk(\"\\n\");\n\tpci_iounmap(pdev, cis);\n\n\treturn 0;\n}\n\nstatic int pluto2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct pluto *pluto;\n\tstruct dvb_adapter *dvb_adapter;\n\tstruct dvb_demux *dvbdemux;\n\tstruct dmx_demux *dmx;\n\tint ret = -ENOMEM;\n\n\tpluto = kzalloc(sizeof(struct pluto), GFP_KERNEL);\n\tif (!pluto)\n\t\tgoto out;\n\n\tpluto->pdev = pdev;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0)\n\t\tgoto err_kfree;\n\n\t/* enable interrupts */\n\tpci_write_config_dword(pdev, 0x6c, 0x8000);\n\n\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\tif (ret < 0)\n\t\tgoto err_pci_disable_device;\n\n\tpci_set_master(pdev);\n\n\tret = pci_request_regions(pdev, DRIVER_NAME);\n\tif (ret < 0)\n\t\tgoto err_pci_disable_device;\n\n\tpluto->io_mem = pci_iomap(pdev, 0, 0x40);\n\tif (!pluto->io_mem) {\n\t\tret = -EIO;\n\t\tgoto err_pci_release_regions;\n\t}\n\n\tpci_set_drvdata(pdev, pluto);\n\n\tret = request_irq(pdev->irq, pluto_irq, IRQF_SHARED, DRIVER_NAME, pluto);\n\tif (ret < 0)\n\t\tgoto err_pci_iounmap;\n\n\tret = pluto_hw_init(pluto);\n\tif (ret < 0)\n\t\tgoto err_free_irq;\n\n\t/* i2c */\n\ti2c_set_adapdata(&pluto->i2c_adap, pluto);\n\tstrcpy(pluto->i2c_adap.name, DRIVER_NAME);\n\tpluto->i2c_adap.owner = THIS_MODULE;\n\tpluto->i2c_adap.dev.parent = &pdev->dev;\n\tpluto->i2c_adap.algo_data = &pluto->i2c_bit;\n\tpluto->i2c_bit.data = pluto;\n\tpluto->i2c_bit.setsda = pluto_setsda;\n\tpluto->i2c_bit.setscl = pluto_setscl;\n\tpluto->i2c_bit.getsda = pluto_getsda;\n\tpluto->i2c_bit.getscl = pluto_getscl;\n\tpluto->i2c_bit.udelay = 10;\n\tpluto->i2c_bit.timeout = 10;\n\n\t/* Raise SCL and SDA */\n\tpluto_setsda(pluto, 1);\n\tpluto_setscl(pluto, 1);\n\n\tret = i2c_bit_add_bus(&pluto->i2c_adap);\n\tif (ret < 0)\n\t\tgoto err_pluto_hw_exit;\n\n\t/* dvb */\n\tret = dvb_register_adapter(&pluto->dvb_adapter, DRIVER_NAME,\n\t\t\t\t   THIS_MODULE, &pdev->dev, adapter_nr);\n\tif (ret < 0)\n\t\tgoto err_i2c_del_adapter;\n\n\tdvb_adapter = &pluto->dvb_adapter;\n\n\tpluto_read_rev(pluto);\n\tpluto_read_serial(pluto);\n\tpluto_read_mac(pluto, dvb_adapter->proposed_mac);\n\n\tdvbdemux = &pluto->demux;\n\tdvbdemux->filternum = 256;\n\tdvbdemux->feednum = 256;\n\tdvbdemux->start_feed = pluto_start_feed;\n\tdvbdemux->stop_feed = pluto_stop_feed;\n\tdvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\n\t\t\tDMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);\n\tret = dvb_dmx_init(dvbdemux);\n\tif (ret < 0)\n\t\tgoto err_dvb_unregister_adapter;\n\n\tdmx = &dvbdemux->dmx;\n\n\tpluto->hw_frontend.source = DMX_FRONTEND_0;\n\tpluto->mem_frontend.source = DMX_MEMORY_FE;\n\tpluto->dmxdev.filternum = NHWFILTERS;\n\tpluto->dmxdev.demux = dmx;\n\n\tret = dvb_dmxdev_init(&pluto->dmxdev, dvb_adapter);\n\tif (ret < 0)\n\t\tgoto err_dvb_dmx_release;\n\n\tret = dmx->add_frontend(dmx, &pluto->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_dvb_dmxdev_release;\n\n\tret = dmx->add_frontend(dmx, &pluto->mem_frontend);\n\tif (ret < 0)\n\t\tgoto err_remove_hw_frontend;\n\n\tret = dmx->connect_frontend(dmx, &pluto->hw_frontend);\n\tif (ret < 0)\n\t\tgoto err_remove_mem_frontend;\n\n\tret = frontend_init(pluto);\n\tif (ret < 0)\n\t\tgoto err_disconnect_frontend;\n\n\tdvb_net_init(dvb_adapter, &pluto->dvbnet, dmx);\nout:\n\treturn ret;\n\nerr_disconnect_frontend:\n\tdmx->disconnect_frontend(dmx);\nerr_remove_mem_frontend:\n\tdmx->remove_frontend(dmx, &pluto->mem_frontend);\nerr_remove_hw_frontend:\n\tdmx->remove_frontend(dmx, &pluto->hw_frontend);\nerr_dvb_dmxdev_release:\n\tdvb_dmxdev_release(&pluto->dmxdev);\nerr_dvb_dmx_release:\n\tdvb_dmx_release(dvbdemux);\nerr_dvb_unregister_adapter:\n\tdvb_unregister_adapter(dvb_adapter);\nerr_i2c_del_adapter:\n\ti2c_del_adapter(&pluto->i2c_adap);\nerr_pluto_hw_exit:\n\tpluto_hw_exit(pluto);\nerr_free_irq:\n\tfree_irq(pdev->irq, pluto);\nerr_pci_iounmap:\n\tpci_iounmap(pdev, pluto->io_mem);\nerr_pci_release_regions:\n\tpci_release_regions(pdev);\nerr_pci_disable_device:\n\tpci_disable_device(pdev);\nerr_kfree:\n\tkfree(pluto);\n\tgoto out;\n}\n\nstatic void pluto2_remove(struct pci_dev *pdev)\n{\n\tstruct pluto *pluto = pci_get_drvdata(pdev);\n\tstruct dvb_adapter *dvb_adapter = &pluto->dvb_adapter;\n\tstruct dvb_demux *dvbdemux = &pluto->demux;\n\tstruct dmx_demux *dmx = &dvbdemux->dmx;\n\n\tdmx->close(dmx);\n\tdvb_net_release(&pluto->dvbnet);\n\tif (pluto->fe)\n\t\tdvb_unregister_frontend(pluto->fe);\n\n\tdmx->disconnect_frontend(dmx);\n\tdmx->remove_frontend(dmx, &pluto->mem_frontend);\n\tdmx->remove_frontend(dmx, &pluto->hw_frontend);\n\tdvb_dmxdev_release(&pluto->dmxdev);\n\tdvb_dmx_release(dvbdemux);\n\tdvb_unregister_adapter(dvb_adapter);\n\ti2c_del_adapter(&pluto->i2c_adap);\n\tpluto_hw_exit(pluto);\n\tfree_irq(pdev->irq, pluto);\n\tpci_iounmap(pdev, pluto->io_mem);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tkfree(pluto);\n}\n\n#ifndef PCI_VENDOR_ID_SCM\n#define PCI_VENDOR_ID_SCM\t0x0432\n#endif\n#ifndef PCI_DEVICE_ID_PLUTO2\n#define PCI_DEVICE_ID_PLUTO2\t0x0001\n#endif\n\nstatic struct pci_device_id pluto2_id_table[] = {\n\t{\n\t\t.vendor = PCI_VENDOR_ID_SCM,\n\t\t.device = PCI_DEVICE_ID_PLUTO2,\n\t\t.subvendor = PCI_ANY_ID,\n\t\t.subdevice = PCI_ANY_ID,\n\t}, {\n\t\t/* empty */\n\t},\n};\n\nMODULE_DEVICE_TABLE(pci, pluto2_id_table);\n\nstatic struct pci_driver pluto2_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = pluto2_id_table,\n\t.probe = pluto2_probe,\n\t.remove = pluto2_remove,\n};\n\nmodule_pci_driver(pluto2_driver);\n\nMODULE_AUTHOR(\"Andreas Oberritter <obi@linuxtv.org>\");\nMODULE_DESCRIPTION(\"Pluto2 driver\");\nMODULE_LICENSE(\"GPL\");\n"
}