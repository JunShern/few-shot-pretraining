{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['Any assistance greatly appreciated in getting the cleanest approach to this, without multiple loops of the same dataset, for example. (0.195)']."
        }
    ],
    "doc_id": "2802",
    "text": "Q:\n\njQuery / JSON sort results\n\nI have a ColdFusion method getData() which returns a query object as follows:\nCustomerCode  ServiceCode  SubscriberCode  Status    UserName\n-------------------------------------------------------------\n811101        8            gertjan         OPEN      gertjan@blah.net\n811101        8            gertjan         CLOSING   gertjan@blah.net\n811101        2            99652444        CLOSED    gertjan@blah.net\n811101        2            99655000        OPEN      gertjan@blah.net\n\nNote the first two rows - exactly the same except for Status OPEN and CLOSING respectively.\nThe following function creates a new select option for each row where ServiceCode=8 and Status is either OPEN or CLOSING, which would be the case for both the first two rows.\nThe data ultimately comes via a web service which is out of my control to change. I need to change the jQuery such that if BOTH an OPEN and CLOSING record exists for the same ServiceCode/SubscriberCode combination, which is the case for the first two rows, then only create an option for the OPEN record.\nfunction getInternetLines(){\n        var CustomerCode=global_customerCode;\n        var SessionID=global_sessionID;\n        var lines=[];\n        $.getJSON(\"/system.cfc?method=getData&returnformat=json&queryformat=column\",\n               {\"SessionID\":SessionID,\"CustomerCode\":CustomerCode}, \n               function(res,code) {\n            if(res.ROWCOUNT > 0){\n                for(var i=0; i<res.ROWCOUNT; i++) {\n                    var ServiceCode = res.DATA.ServiceCode[i];\n                    var SubscriberCode = res.DATA.SubscriberCode[i];\n                    var Status = res.DATA.Status[i];\n                    if(ServiceCode == 8 && (Status == 'OPEN' || Status == 'CLOSING')){\n                        lines.push(SubscriberCode);\n                        $('#selInternet').append(\n                            $('<option></option>').val(SubscriberCode).html(SubscriberCode)\n                        );\n                    }\n                }\n                global_internet_lines = lines;\n                if(lines.length == 0){\n                    $('#divBroadbandUsage').html('No Active Broadband Connections.');\n                }\n            }else{\n                $('#divBroadbandUsage').html('No Active Broadband Connections.');\n            }\n        });\n    }\n\nHTML\n<select name=\"selInternet\" id=\"selInternet\" style=\"width:120px\">\n</select>\n\nAny assistance greatly appreciated in getting the cleanest approach to this, without multiple loops of the same dataset, for example.\n\nA:\n\nYou would need to keep a hash as you read the data, ignoring data if an 'OPEN' was already found.  Then loop through the hash items and output the data:\nif(res.ROWCOUNT > 0){\n    var hash = {};  // Hash to store data\n    for(var i=0; i<res.ROWCOUNT; i++) {\n        var ServiceCode = res.DATA.ServiceCode[i];\n        var SubscriberCode = res.DATA.SubscriberCode[i];\n        var Status = res.DATA.Status[i];\n        if(ServiceCode == 8 && (Status == 'OPEN' || Status == 'CLOSING')){\n             if( hash[SubscriberCode] != undefined && hash[SubscriberCode].status == 'OPEN' ) {\n                 // If we already have OPEN, don't load the data\n                 continue;\n             } else {\n                 // Else override whatever data you have for this SubscriberCode\n                 hash[SubscriberCode] = { status: Status, subscriber: SubscriberCode, service: ServiceCode }; \n             }\n        }\n    }\n\n    // loop through the hash and output the options\n    for(var x in hash) {\n        lines.push(hash[x].subscriber);\n        $('#selInternet').append(\n            $('<option></option>').val(hash[x].subscriber).html(hash[x].subscriber)\n        );\n    }\n\n    global_internet_lines = lines;\n    if(lines.length == 0){\n        $('#divBroadbandUsage').html('No Active Broadband Connections.');\n    }\n}\n\nI'm not sure what your cases are, but this covers your description I believe.  I realize it is silly to have the hash key stored in the data, but for demonstration, this is how you would retrieve other data.  This code stores Status, SubscriberCode, and ServiceCode, but your example only uses SubscribercCode.  If this is really the case, it is much simpler:\nif(res.ROWCOUNT > 0){\n    var hash = {};  // Hash to store data\n    for(var i=0; i<res.ROWCOUNT; i++) {\n        var ServiceCode = res.DATA.ServiceCode[i];\n        var SubscriberCode = res.DATA.SubscriberCode[i];\n        var Status = res.DATA.Status[i];\n        if(ServiceCode == 8 && (Status == 'OPEN' || Status == 'CLOSING')){\n             // If we see the subscriber code, add it to our hash\n             hash[SubscriberCode] = 1; \n        }\n    }\n\n    // loop through the hash and output the options\n    for(var sub in hash) {\n        lines.push(sub);\n        $('#selInternet').append(\n            $('<option></option>').val(sub).html(sub)\n        );\n    }\n\n    global_internet_lines = lines;\n    if(lines.length == 0){\n        $('#divBroadbandUsage').html('No Active Broadband Connections.');\n    }\n}\n\n"
}