{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2484",
    "text": "Q:\n\nSort array of structs by a member of each\n\nI am compiling data using the following structs:\nstruct Nursing {\n\nvar leftTime: Double\nvar rightTime: Double\nvar submissionTime: Date\n\n}\n\nstruct Bottle {\n\nvar bottleQuantity: Double\nvar bottleUnits: String\nvar submissionTime: Date\n\n}\n\nstruct Puree {\n\nvar pureeQuantity: Double\nvar pureeType: String\nvar pureeUnits: String\nvar submissionTime: Date\n\n}\n\nThen I create arrays of each type using data from elsewhere in the app.\nvar nursingArray = [Nursing]()\nvar bottleArray = [Bottle]()\nvar pureeArray = [Puree]()\n\nI then filter each array for only entries that occurred in the last day.\nlet yesterday = Calendar.current.date(byAdding: .day, value: -1, to: Date())\n    var todayBottleArray = bottleArray.filter( { ( $0.submissionTime > yesterday! ) } )\n    var todayNursingArray = nursingArray.filter( { ( $0.submissionTime > yesterday! ) } )\n    var todayPureeArray = pureeArray.filter( { ( $0.submissionTime > yesterday! ) } )\n\nFinally they all get combined into a single unsorted array.\n    var unsortedTodayArray: [Any] = []\n\n    unsortedTodayArray.append(todayBottleArray)\n    unsortedTodayArray.append(todayNursingArray)\n    unsortedTodayArray.append(todayPureeArray)\n\nHere's the question...while I know they're unrelated, the submissionTime property appears in all three.  How can I sort unsortedTodayArray by submissionTime?\n\nA:\n\nYou can have your struct conform to the same protocol. Something like...\nprotocol SubmissionTimeable {\n    var submissionTime: Date { get set }\n}\n\nstruct Nursing: SubmissionTimeable {\n\n    var leftTime: Double\n    var rightTime: Double\n    var submissionTime: Date\n}\n\nstruct Bottle: SubmissionTimeable {\n\n    var bottleQuantity: Double\n    var bottleUnits: String\n    var submissionTime: Date\n}\n\nstruct Puree: SubmissionTimeable {\n\n    var pureeQuantity: Double\n    var pureeType: String\n    var pureeUnits: String\n    var submissionTime: Date\n}\n\nThen let your unsorted array be an array of the protocol.\nlet unsortedArray = [SubmissionTimeable]()\n\nThen you can sort that array with submissionTime.\n\n"
}