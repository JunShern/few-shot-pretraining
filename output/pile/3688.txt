{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "3688",
    "text": "Q:\n\nBad lighting using Phong Method\n\nI'm trying to make a cube, which is irregularly triangulated, but virtually coplanar, shade correctly.\nHere is the current result I have:\n\nWith wireframe:\n\nNormals calculated in my program:\n\nNormals calculated by meshlabjs.net:\n\nThe lighting works properly when using regular size triangles for the cube. As you can see, I'm duplicating vertices and using angle weighting.\nlighting.frag\nvec4 scene_ambient = vec4(1, 1, 1, 1.0);\n\nstruct material\n{\n  vec4 ambient;\n  vec4 diffuse;\n  vec4 specular;\n  float shininess;\n};\n\nmaterial frontMaterial = material(\n  vec4(0.25, 0.25, 0.25, 1.0),\n  vec4(0.4, 0.4, 0.4, 1.0),\n  vec4(0.774597, 0.774597, 0.774597, 1.0),\n  76\n);\n\nstruct lightSource\n{\n  vec4 position;\n  vec4 diffuse;\n  vec4 specular;\n  float constantAttenuation, linearAttenuation, quadraticAttenuation;\n  float spotCutoff, spotExponent;\n  vec3 spotDirection;\n};\n\nlightSource light0 = lightSource(\n  vec4(0.0,  0.0, 0.0, 1.0),\n  vec4(100.0,  100.0,  100.0, 100.0),\n  vec4(100.0,  100.0,  100.0, 100.0),\n  0.1, 1, 0.01,\n  180.0, 0.0,\n  vec3(0.0, 0.0, 0.0)\n);\n\nvec4 light(lightSource ls, vec3 norm, vec3 deviation, vec3 position)\n{\n  vec3 viewDirection = normalize(vec3(1.0 * vec4(0, 0, 0, 1.0) - vec4(position, 1)));\n\n  vec3 lightDirection;\n  float attenuation;\n\n  //ls.position.xyz = cameraPos;\n  ls.position.z += 50;\n\n  if (0.0 == ls.position.w) // directional light?\n  {\n    attenuation = 1.0; // no attenuation\n    lightDirection = normalize(vec3(ls.position));\n  } \n  else // point light or spotlight (or other kind of light) \n  {\n      vec3 positionToLightSource = vec3(ls.position - vec4(position, 1.0));\n    float distance = length(positionToLightSource);\n    lightDirection = normalize(positionToLightSource);\n    attenuation = 1.0 / (ls.constantAttenuation\n      + ls.linearAttenuation * distance\n      + ls.quadraticAttenuation * distance * distance);\n\n    if (ls.spotCutoff <= 90.0) // spotlight?\n    {\n      float clampedCosine = max(0.0, dot(-lightDirection, ls.spotDirection));\n      if (clampedCosine < cos(radians(ls.spotCutoff))) // outside of spotlight cone?\n      {\n        attenuation = 0.0;\n        }\n      else\n        {\n        attenuation = attenuation * pow(clampedCosine, ls.spotExponent);   \n        }\n    }\n  }\n\n  vec3 ambientLighting = vec3(scene_ambient) * vec3(frontMaterial.ambient);\n\n  vec3 diffuseReflection = attenuation \n    * vec3(ls.diffuse) * vec3(frontMaterial.diffuse)\n    * max(0.0, dot(norm, lightDirection));\n\n  vec3 specularReflection;\n  if (dot(norm, lightDirection) < 0.0) // light source on the wrong side?\n  {\n    specularReflection = vec3(0.0, 0.0, 0.0); // no specular reflection\n  }\n  else // light source on the right side\n  {\n    specularReflection = attenuation * vec3(ls.specular) * vec3(frontMaterial.specular)\n         * pow(max(0.0, dot(reflect(lightDirection, norm), viewDirection)), frontMaterial.shininess);\n  }\n\n  return vec4(ambientLighting + diffuseReflection + specularReflection, 1.0);\n}\n\nvec4 generateGlobalLighting(vec3 norm, vec3 position)\n{\n  return light(light0, norm, vec3(2,0,0), position);\n}\n\nmainmesh.frag\n#version 430\nin vec3 f_color;\nin vec3 f_normal;\nin vec3 f_position;\n\nin float f_opacity;\n\nout vec4 fragColor;\n\nvec4 generateGlobalLighting(vec3 norm, vec3 position);\n\nvoid main()\n{\n  vec3 norm = normalize(f_normal);\n  vec4 l0 = generateGlobalLighting(norm, f_position);\n\n  fragColor = vec4(f_color, f_opacity) * l0;\n}\n\nFollows the code to generate the verts, normals and faces for the painter.\nm_vertices_buf.resize(m_mesh.num_faces() * 3, 3);\nm_normals_buf.resize(m_mesh.num_faces() * 3, 3);\nm_faces_buf.resize(m_mesh.num_faces(), 3);\n\nstd::map<vertex_descriptor, std::list<Vector3d>> map;\nGLDebugging* deb = GLDebugging::getInstance();\n\nauto getAngle = [](Vector3d a, Vector3d b) {\n    double angle = 0.0;\n    angle = std::atan2(a.cross(b).norm(), a.dot(b));\n    return angle;\n};\n\nfor (const auto& f : m_mesh.faces()) {\n    auto f_hh = m_mesh.halfedge(f);\n    //auto n = PMP::compute_face_normal(f, m_mesh);\n\n    vertex_descriptor vs[3];\n    Vector3d ps[3];\n\n    int i = 0;\n    for (const auto& v : m_mesh.vertices_around_face(f_hh)) {\n        auto p = m_mesh.point(v);\n        ps[i] = Vector3d(p.x(), p.y(), p.z());\n        vs[i++] = v;\n    }\n\n    auto n = (ps[1] - ps[0]).cross(ps[2] - ps[0]).normalized();\n\n    auto a1 = getAngle((ps[1] - ps[0]).normalized(), (ps[2] - ps[0]).normalized());\n    auto a2 = getAngle((ps[2] - ps[1]).normalized(), (ps[0] - ps[1]).normalized());\n    auto a3 = getAngle((ps[0] - ps[2]).normalized(), (ps[1] - ps[2]).normalized());\n\n    auto area = PMP::face_area(f, m_mesh);\n\n    map[vs[0]].push_back(n * a1);\n    map[vs[1]].push_back(n * a2);\n    map[vs[2]].push_back(n * a3);\n\n    auto p = m_mesh.point(vs[0]);\n    deb->drawLine(Vector3d(p.x(), p.y(), p.z()), Vector3d(p.x(), p.y(), p.z()) + Vector3d(n.x(), n.y(), n.z()) * 4);\n\n    p = m_mesh.point(vs[1]);\n    deb->drawLine(Vector3d(p.x(), p.y(), p.z()), Vector3d(p.x(), p.y(), p.z()) + Vector3d(n.x(), n.y(), n.z()) * 4);\n\n    p = m_mesh.point(vs[2]);\n    deb->drawLine(Vector3d(p.x(), p.y(), p.z()), Vector3d(p.x(), p.y(), p.z()) + Vector3d(n.x(), n.y(), n.z()) * 4);\n}\n\nint j = 0;\nint i = 0;\nfor (const auto& f : m_mesh.faces()) {\n    auto f_hh = m_mesh.halfedge(f);\n    for (const auto& v : m_mesh.vertices_around_face(f_hh)) {\n        const auto& p = m_mesh.point(v);\n        m_vertices_buf.row(i) = RowVector3d(p.x(), p.y(), p.z());\n\n        Vector3d n(0, 0, 0);\n\n        //auto n = PMP::compute_face_normal(f, m_mesh);\n        Vector3d norm = Vector3d(n.x(), n.y(), n.z());\n\n        for (auto val : map[v]) {\n            norm += val;\n        }\n\n        norm.normalize();\n\n        deb->drawLine(Vector3d(p.x(), p.y(), p.z()), Vector3d(p.x(), p.y(), p.z()) + Vector3d(norm.x(), norm.y(), norm.z()) * 3,\n            Vector3d(1.0, 0, 0));\n\n        m_normals_buf.row(i++) = RowVector3d(norm.x(), norm.y(), norm.z());\n    }\n\n    m_faces_buf.row(j++) = RowVector3i(i - 3, i - 2, i - 1);\n}\n\nFollows the painter code:\nm_vertexAttrLoc = program.attributeLocation(\"v_vertex\");\nm_colorAttrLoc = program.attributeLocation(\"v_color\");\nm_normalAttrLoc = program.attributeLocation(\"v_normal\");\n\nm_mvMatrixLoc = program.uniformLocation(\"v_modelViewMatrix\");\nm_projMatrixLoc = program.uniformLocation(\"v_projectionMatrix\");\nm_normalMatrixLoc = program.uniformLocation(\"v_normalMatrix\");\n//m_relativePosLoc = program.uniformLocation(\"v_relativePos\");\nm_opacityLoc = program.uniformLocation(\"v_opacity\");\nm_colorMaskLoc = program.uniformLocation(\"v_colorMask\");\n\n//bool for unmapping depth color\nm_useDepthMap = program.uniformLocation(\"v_useDepthMap\");\nprogram.setUniformValue(m_mvMatrixLoc, modelView);\n\n//uniform used for Color map to regular model switch\nprogram.setUniformValue(m_useDepthMap, (m_showColorMap &&\n    (m_showProblemAreas || m_showPrepMap || m_showDepthMap || m_showMockupMap)));\n\nQMatrix3x3 normalMatrix = modelView.normalMatrix();\nprogram.setUniformValue(m_normalMatrixLoc, normalMatrix);\nprogram.setUniformValue(m_projMatrixLoc, projection);\n\n//program.setUniformValue(m_relativePosLoc, m_relativePos);\nprogram.setUniformValue(m_opacityLoc, m_opacity);\nprogram.setUniformValue(m_colorMaskLoc, m_colorMask);\n\nglEnableVertexAttribArray(m_vertexAttrLoc);\nm_vertices.bind();\nglVertexAttribPointer(m_vertexAttrLoc, 3, GL_DOUBLE, false, 3 * sizeof(GLdouble), NULL);\nm_vertices.release();\n\nglEnableVertexAttribArray(m_normalAttrLoc);\nm_normals.bind();\nglVertexAttribPointer(m_normalAttrLoc, 3, GL_DOUBLE, false, 0, NULL);\nm_normals.release();\n\nglEnableVertexAttribArray(m_colorAttrLoc);\n\nif (m_showProblemAreas) {\n    m_problemColorMap.bind();\n    glVertexAttribPointer(m_colorAttrLoc, 3, GL_DOUBLE, false, 0, NULL);\n    m_problemColorMap.release();\n}\nelse if (m_showPrepMap) {\n    m_prepColorMap.bind();\n    glVertexAttribPointer(m_colorAttrLoc, 3, GL_DOUBLE, false, 0, NULL);\n    m_prepColorMap.release();\n}\nelse if (m_showMockupMap) {\n    m_mokupColorMap.bind();\n    glVertexAttribPointer(m_colorAttrLoc, 3, GL_DOUBLE, false, 0, NULL);\n    m_mokupColorMap.release();\n}\nelse {\n    //m_colors.bind();\n    //glVertexAttribPointer(m_colorAttrLoc, 3, GL_DOUBLE, false, 0, NULL);\n    //m_colors.release();\n}\n\nm_indices.bind();\nglDrawElements(GL_TRIANGLES, m_indices.size() / sizeof(int), GL_UNSIGNED_INT, NULL);\nm_indices.release();\n\nglDisableVertexAttribArray(m_vertexAttrLoc);\nglDisableVertexAttribArray(m_normalAttrLoc);\nglDisableVertexAttribArray(m_colorAttrLoc);\n\nEDIT: Sorry for not being clear enough. The cube is merely an example. My requirements are that the shading works for any kind of mesh. Those with very sharp edges, and those that are very organic (like humans or animals).\n\nA:\n\nThe issue is clearly explained by the image \"Normals calculated in my program\" from your question. The normal vectors at the corners and edges of the cube are not normal perpendicular to the faces:\n\nFor a proper specular reflection on plane faces, the normal vectors have to be perpendicular to the sides of the cube. \nThe vertex coordinate and its normal vector from a tuple with 6 components (x, y, z, nx, ny, nz).\nA vertex coordinate on an edge of the cube is adjacent to 2 sides of the cube and 2 (face) normal vectors. The 8 vertex coordinates on the 8 corners of the cube are adjacent to 3 sides (3 normal vectors) each.\nTo define the vertex attributes with face normal vectors (perpendicular to a side) you have to define multiple tuples with the same vertex coordinate but different normal vectors. You have to use the different attribute tuples to form the triangle primitives on the different sides of the cube.\ne.g. If you have defined a cube with the left, front, bottom coordinate of (-1, -1, -1) and the right, back, top coordinate of (1, 1, 1), then the vertex coordinate (-1, -1, -1) is adjacent to the left, front and bottom side of the cube:\n         x  y  z   nx ny nz\nleft:   -1 -1 -1   -1  0  0\nfront:  -1 -1 -1    0 -1  0\nbottom: -1 -1 -1    0  0 -1\n\nUse the left attribute tuple to form the triangle primitives on the left side, the front to form the front and bottom for the triangles on the bottom.\n\nIn general you have to decide what you want. There is no general approach for all meshes.\nEither you have a fine granulated mesh and you want a smooth appearance (e.g a sphere). In that case your approach is fine, it will generate a smooth light transition on the edges between the primitives.\nOr you have a mesh with hard edges like a cube. In that case you have to \"duplicate\" vertices. If 2 (or even more) triangles share a vertex coordinate, but the face normal vectors are different, then you have to create a separate tuple, for all the combinations of the vertex coordinate and the face normal vector. \nFor a general \"smooth\" solution you would have to interpolate the normal vectors of the vertex coordinates which are in the middle of plane surfaces, according to the surrounding geometry. That means if a bunch of triangle primitives form a plane, then all the normal vectors of the vertices have to be computed dependent on there position on the plane. At the centroid the normal vector is equal to the face normal vector. For all other points the normal vector has to be interpolated with the normal vectors of the surrounding faces. \nAnyway that seems to be an XY problem. Why is there a \"vertex\" somewhere in the middle of a plane? Probably the plane is tessellated. But if the plan is tessellated, why are the normal vectors not interpolated too, during the tessellation process? \n\nA:\n\nIn your image, we can see that the inner triangle (the one that doesn't have point on cube edges, in top left quarter) has an homogeneous color.\nMy interpretation is that triangles that have points on the edge/corner of the cube share the same vertex and then share the same normal and some how the normal are averaged. So it's not perpendicular to the faces.\nTo debug this, you should create a simple geometry of a cube with 6 faces and 2 triangles per face. Hence it's make 12 triangles.\nTwo options:\n\nIf you have 8 vertex in the geometry, the corner are shared between triangles of different face and the issue came from the geometry generator.\nIf you have 6\u00d74=24 vertex in the geometry the truth lies elsewhere.\n\nA:\n\nAs mentioned in the other answers the problem is your mesh normals.\nComputing an average normal, like you are doing currently, is what you would want \nto do for a smooth object like a sphere. cgal has a function for that CGAL::Polygon_mesh_processing::compute_vertex_normal  For a cube what you want is normals perpendicular to the faces\ncgal has a functoin for that too CGAL::Polygon_mesh_processing::compute_face_normal\nTo debug the normals you can just set fragColor = vec4(norm,1); in mainmesh.frag. Here the cubes on the left have averaged (smooth) normals and on the right have face (flat) normals:And shaded they look like this:\n\nshading has to work for any kind of mesh (a cube or any organic mesh)\n\nFor that you can use something like per_corner_normals whitch:\n\nImplements a simple scheme which computes corner normals as averages\n  of normals of faces incident on the corresponding vertex which do not\n  deviate by more than a specified dihedral angle (e.g. 20\u00b0)\n\nAnd this is what it looks like with a angle of 1\u00b0, 20\u00b0, 100\u00b0:\n\n"
}