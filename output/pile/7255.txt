{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7255",
    "text": "Q:\n\nUsing Scala 2.10 `to` to convert a List to a SortedMap\n\nI am trying to convert a scala.collection.immutable.List of pairs to a scala.collection.immutable.SortedMap using the new to method from Scala 2.10, but I get a compile-time error:\nscala> List((1, \"Fred\"), (2, \"Barney\")).to[scala.collection.immutable.SortedMap]\n<console>:10: error: scala.collection.immutable.SortedMap takes two type parameters, expected: one\n              List((1, \"Fred\"), (2, \"Barney\")).to[SortedMap]\n                                                  ^\n\nCan this be done using the to method? Am I missing an intermediate method call?\n\nA:\n\nI had a similar question some time ago and came up with this: \nSortedMap( list: _*)\n\nSo you can do it like :\nval map =  SortedMap( List((1, \"Fred\"), (2, \"Barney\")): _*)\n\nThe _* means you take the Seqs elements instead of the Seq itself as parameter. \n\nA:\n\n@gourlaysama already explained why it does not compile, and @Chirlo provided the simplest (and recommended) work around: SortedMap( list: _*).\nI'd like to propose an alternative:\nimport collection.Traversable\nimport collection.generic.CanBuildFrom\nimplicit class RichPairTraversable[A,B]( t: Traversable[(A,B)] ) {\n  def toPairCol[Col[A,B]](implicit cbf: CanBuildFrom[Nothing, (A,B), Col[A, B]]): Col[A, B] = {\n    val b = cbf()\n    b.sizeHint(t)\n    b ++= t\n    b.result\n  }  \n}\n\nSome test in the REPL:\nscala> List((1, \"Fred\"), (2, \"Barney\")).toPairCol[scala.collection.immutable.SortedMap]\nres0: scala.collection.immutable.SortedMap[Int,String] = Map(1 -> Fred, 2 -> Barney)\n\nscala> List((1, \"Fred\"), (2, \"Barney\")).toPairCol[scala.collection.immutable.HashMap]\nres1: scala.collection.immutable.HashMap[Int,String] = Map(1 -> Fred, 2 -> Barney)\n\nNow, I will probably not use it in production, given that doing SortedMap( list: _* ) is not that\nhard and requires no magic.\n\n"
}