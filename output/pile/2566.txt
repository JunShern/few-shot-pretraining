{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "2566",
    "text": "Q:\n\nAppropriate Scala Collection similar to Python Dictionary\n\nI have an algorithm that iteratively returns (key, value). What I want to do is store these results in a structure such that if the key does not exist, it will add it and the corresponding value. Now, if the key exists, it will append the value to an existing array of values.\nIn python, I can do this using a python dictionary with this format:\ndict = {'key1': [val1, val2, val3],\n        'key2': [val4, val5], \n        'key3': [val6], ... }\n\nand simply do: \nif key in dict.keys():\n    dict[key].append(value)\nelse:\n    dict[key] = [value]\n\nHow do I do this in Scala?\n\nA:\n\nMaybe something like this?\nscala> def insert[K,V](k: K, v: V, m: Map[K, List[V]]): Map[K, List[V]] = {\n     | if (m contains k) m + (k -> (m(k) :+ v))\n     | else m + (k -> List(v)) }\ninsert: [K, V](k: K, v: V, m: Map[K,List[V]])Map[K,List[V]]\n\nscala> insert('b', 23, Map('b' -> List(2)))\nres30: Map[Char,List[Int]] = Map(b -> List(2, 23))\n\nscala> insert('b', 23, Map('c' -> List(2)))\nres31: Map[Char,List[Int]] = Map(c -> List(2), b -> List(23))\n\nOr, incorporating Sergey's very fine suggestion:\ndef insert[K,V](k: K, v: V, m: Map[K, List[V]]): Map[K, List[V]] =\n  m + (k -> (m.getOrElse(k, List()) :+ v))\n\n"
}