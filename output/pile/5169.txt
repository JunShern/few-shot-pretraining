{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 1 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "5169",
    "text": "Q:\n\nDjango: Custom model field does not show correct value in the form\n\nI needed to store arbitrary data in a relational database of multiple data-types so I came up with a solution of in addition to storing the data itself also to store what is the datatype of the data (str, int, etc). This allows upon retreival to cast the string which is stored in the db into whatever proper data-type the data is.  In order to store the data-type I made a custom model field:\nclass DataType(object):\n    SUPPORTED_TYPES = {\n        u'unicode': unicode,\n        u'str': str,\n        u'bool': bool,\n        u'int': int,\n        u'float': float\n    }\n    INVERSE_SUPPORTED_TYPES = dict(zip(SUPPORTED_TYPES.values(), SUPPORTED_TYPES.keys()))\n    TYPE_CHOICES = dict(zip(SUPPORTED_TYPES.keys(), SUPPORTED_TYPES.keys()))\n\n    def __init__(self, datatype=None):\n        if not datatype:\n            datatype = unicode\n\n        t_datatype = type(datatype)\n\n        if t_datatype in [str, unicode]:\n            self.datatype = self.SUPPORTED_TYPES[datatype]\n\n        elif t_datatype is type and datatype in self.INVERSE_SUPPORTED_TYPES.keys():\n            self.datatype = datatype\n\n        elif t_datatype is DataType:\n            self.datatype = datatype.datatype\n\n        else:\n            raise TypeError('Unsupported %s' % str(t_datatype))\n\n    def __unicode__(self):\n        return self.INVERSE_SUPPORTED_TYPES[self.datatype]\n\n    def __str__(self):\n        return str(self.__unicode__())\n\n    def __len__(self):\n        return len(self.__unicode__())\n\n    def __call__(self, *args, **kwargs):\n        return self.datatype(*args, **kwargs)\n\nclass DataTypeField(models.CharField):\n    __metaclass__ = models.SubfieldBase\n    description = 'Field for storing python data-types in db with capability to get python the data-type back'\n\n    def __init__(self, **kwargs):\n        defaults = {}\n        overwrites = {\n            'max_length': 8\n        }\n        defaults.update(kwargs)\n        defaults.update(overwrites)\n        super(DataTypeField, self).__init__(**overwrites)\n\n    def to_python(self, value):\n        return DataType(value)\n\n    def get_prep_value(self, value):\n        return unicode(DataType(value))\n\n    def value_to_string(self, obj):\n        val = self._get_val_from_obj(obj)\n        return self.get_prep_value(val)\n\nSo this allows me to do something like that:\nclass FooModel(models.Model):\n    data = models.TextField()\n    data_type = DataTypeField()\n\n>>> foo = FooModel.objects.create(data='17.94', data_type=float)\n>>> foo.data_type(foo.data)\n17.94\n>>> type(foo.data_type(foo.data))\nfloat\n\nSo my problem is that in the Django Admin (I am using ModelAdmin), the value for data_type in the textbox does not show up properly. Whenever it is float (and in db it is stores as float, I checked), the value displayed is 0.0. For int it displays 0. For bool it displays False. Instead of showing the string representation of the data_type, somewhere Django actually calls it, which means the __call__ is called withour an parameters, which results in those values. For example:\n>>> DataType(float)()\n0.0\n>>> DataType(int)()\n0\n>>> DataType(bool)()\nFalse\n\nI figured out how to monkey patch it by replacing __call__ method with the following:\ndef __call__(self, *args, **kwargs):\n    if not args and not kwargs:\n        return self.__unicode__()\n    return self.datatype(*args, **kwargs)\n\nThis displays the correct value in the form however I feel that this is not very elegant. Is there any way to make it better? I could not figure out where Django called the field value in the first place.\nThanx\n\nA:\n\nwrt why your DataType get called, read this:  https://docs.djangoproject.com/en/1.4/topics/templates/#accessing-method-calls\nThe clean solution might be to simply rename call to something more explicit.\n\n"
}