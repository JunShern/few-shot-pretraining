{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "6424",
    "text": "Q:\n\nLittle bit confusing about free pointer inside function\n\nsome weeks ago I learn about proper way how pointers should be allocated and dealocated inside function so given in example linkedList:\ntypedef struct _node {\n    void *data;\n    struct _node *next;\n} Node;\n\ntypedef struct _linkedList {\n    Node *head;\n    Node *tail;\n    Node *current;\n} LinkedList;\n\nIn My opinion right way to destroy queue is by using function that get pointer to pointer to node which I want to delete:\nvoid destroy (Node ** node) \n\nOr in more real world example pointer to pointer and pointer to list to delete.\nvoid destroy (LinkedList * list, Node ** node) \n\nbut now I am reading book \"Understanding C pointers\" and I encounter to problem because In chapter 6 pointers to structures there is followed example of function destroyList:\nvoid delete(LinkedList *list, Node *node) {\n    if (node == list->head) {\n        if (list->head->next == NULL) {\n            list->head = list->tail = NULL;\n        } else {\n            list->head = list->head->next;\n        }\n    } else {\n        Node *tmp = list->head;\n        while (tmp != NULL && tmp->next != node) {\n            tmp = tmp->next;\n        }\n       if (tmp != NULL) {\n            tmp->next = node->next;\n        }    \n    }   \n    free(node);  //free on pointer copy value not pointer\n}\n\nSo in this example author run free on pointer that is passed by value, so in my opinion this shouldn't work. But I looked into errata and there is no notes about this example.\nIn this case I understand that List is function argument to use correct instance of list, but is should be rather that:\nfree(list->head) ; //It should work?\n\nAnd then also free memory for allocated List.\nAm I right? Because reading this example I have a feeling that I have a problem with good understanding of this topic.\nAlso I went to Linux Man Page and I saw free prototype:\n void free(void *ptr);    // http://linux.die.net/man/3/free\n\nSo why everybody told to pass pointer to pointer when You want to free memory but in standard library same free function take as parameter not pointer to pointer but pointer, how it work correctly?\n\nA:\n\nas you state correctly, free( void *p ) frees the memory p points to but as the address is passed by value it will remain unchanged for the caller. Thus you could run into problems like this:\nint *p = malloc( sizeof *p );\n\n*p = 1;\nfree( p );\n...\n\nif( p )\n   *p = 2;     // Undefined Behaviour!!! although p is free()'d it's still != NULL\n\nSo you will often find\nfree( p );\np = NULL;\n\nNevertheless in my opinion it's ok to write a free() like function where you pass a pointer by value as long as the function's description states clearly that the pointer must not be used afterwards (no matter wht type of pointer that may be). But of course you're free to define the function with double pointers and set everything you have free()'d to NULL inside, like in this very simple example:\nvoid myfree( void **pp )\n{\n   free( *p );\n   *p = NULL;\n}\n\n...\nint *p = malloc( sizeof *p );\n...\nmyfree( &p );\n// now p == NULL\n\n"
}