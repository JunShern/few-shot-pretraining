{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['The problem lies mostly in building the arrays which takes a majority of the time as well as GC when the results are returned from which I chalk up to probably JNI overhead and not much I can do about that. (0.199)', 'You have an idea to replace it) but I welcome any suggestions at all regarding how to get the fastest array building out of this. (0.190)']."
        }
    ],
    "doc_id": "5371",
    "text": "Q:\n\nHigh performance primitive array builder in Java\n\nI currently use google-or tools to solve a max flow problem, so this has me create a few int[] arrays in java to pass into ortools. Now ortools is very fast and not an issue here but I'm open to performance minded alternatives here. \nThe problem lies mostly in building the arrays which takes a majority of the time as well as GC when the results are returned from which I chalk up to probably JNI overhead and not much I can do about that. The primitive arrays approach around the 5 - 7 million point mark and they are large enough to require them to be integers, short is not an option. Do I have any options or tricks or does anyone have any insight into how to most efficiently build these? Memory is not really an issue here I have enough that and for the most part I am open to any solution for the absolute bleeding edge performance, even if it requires a different representation of my data but this still must be able to be plugged into Ortools (unless\nYou have an idea to replace it) but I welcome any suggestions at all regarding how to get the fastest array building out of this. Mind you I don't know the length of the arrays ahead of time, I don't do updates, deletes, only appends.  I'm happy to provide anymore details. Thanks for any suggestions. \n\nA:\n\nToo long for a comment.\nIf building the problem representation takes a lot of time when compared to solving, then you're doing something wrong. I guess, you're using something like\nint[] appendTo(int[] array, int element) {\n    int[] result = Arrays.copyOf(array, array.length + 1);\n    result[result.length - 1] = element;\n    return result;\n}\n\nwhich has a quadratic complexity. The solution is similar to what ArrayList does: Grow by some fixed factor and ignore trailing array elements. This mayn't be what you need at the end, but shrinking all arrays once (just before passing them to the library) is cheap.\nYou could use a class like\nclass MyIntArray {\n   private int length;\n   private int[] data = new data[4];\n\n   // This does the final shrinking.\n   public int[] toArray() {\n       return Arrays.copyOf(array, length);\n   }\n\n   public MyIntArray append(int element) {\n       if (array.length == length) {\n           array = Arrays.copyOf(array, 2 * length);\n       }\n       array[length++] = element;\n   }\n}\n\nor misuse the last element of an int[] for tracking the logical length (slightly more efficient, but very hacky).\nThere are various trade-offs, e.g., you could reduce your growth factor to 1.5 by using length + (length >> 1) instead of 2 * length, start with shorter or longer arrays, or even with an empty array (like ArrayList does; then you'd need to adapt the growth factor as well).\n\n"
}