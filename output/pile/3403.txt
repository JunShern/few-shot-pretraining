{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains [\"Separate from the output type, I'd like to point out a few alternative styles you may prefer for writing this sort of code: (0.190)\", 'there are a couple different ways to write this using guards, or even the function Control.Monad.guard. (0.184)']."
        }
    ],
    "doc_id": "3403",
    "text": "Q:\n\nHaskell - Maybe arithmetic\n\nI have been asked to implement a function which uses the following profile:\nmaybe_divide :: Maybe Integer -> Maybe Integer -> Maybe Integer\n\nand responds in the following manner:\n> maybe_divide (Just 5) (Just 2) \nJust 2\n> maybe_divide (Just (-5)) (Just 2) \nJust (-3)\n> maybe_divide (Just (-5)) (Just 0) \nNothing\n> maybe_divide Nothing (Just 1) \nNothing\n> maybe_divide (Just 1) Nothing\nNothing\n\nI have written the following but it will not compile. Do you guys have any suggestions?\nmaybe_divide :: Maybe Integer -> Maybe Integer -> Maybe Integer\nmaybe_divide x y = case x of\n    Just x' -> case y of \n        Just y'\n            | y' == 0 -> Nothing  \n            | otherwise -> x' `div` y'\n    Nothing -> Nothing \n\nA:\n\nSeparate from the output type, I'd like to point out a few alternative styles you may prefer for writing this sort of code:\nFirst, you can case on multiple expressions by putting them in a tuple:\ncase (x,y) of\n    (_      , Just 0) -> Nothing\n    (Just x', Just y') -> Just (x' `div` y')\n    _ -> Nothing\n\nthere are a couple different ways to write this using guards, or even the function Control.Monad.guard.\ncase (x,y) of\n  (Just x', Just y') -> (x' `div` y') <$ guard (y' /= 0)\n  _ -> Nothing\n\nThe second approach would start with a function:\nsafeDiv :: Integer -> Integer -> Maybe Integer\nsafeDiv x 0 = Nothing\nsafeDiv x y = Just (x `div` y)\n\nNow that you have safeDiv, you can lift it into Maybe-wrapped arguments.  It's pretty close to Applicative style code, except for an extra layer of Maybe in the output.  Fortunately nested monads (e.g. Maybe (Maybe t)) are trivial to collapse:\nmaybe_divide x y = join $ safeDiv <$> x <*> y\n\nor even\nmaybe_divide = (join .) . liftM2 safeDiv\n\nif you're fluent in point-free.\nPersonally, I would use one of the two tuple-case variants.  But it's fairly common to already have a function like safeDiv, in which case the second form can be useful.\n\nA:\n\nYou should post the error you are getting, but\nx' `div` y'\n\nhas type Integer and not Maybe Integer.  Perhaps you need to wrap this in a Just.  \n\nA:\n\nYou need to wrap the successful result in Just here:\n... | otherwise -> Just (x' `div` y')\n\n"
}