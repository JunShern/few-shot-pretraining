{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains A:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "6174",
    "text": "//\n//  SendPaxViewController.swift\n//  Blockchain\n//\n//  Created by Alex McGregor on 4/23/19.\n//  Copyright \u00a9 2019 Blockchain Luxembourg S.A. All rights reserved.\n//\n\nimport DIKit\nimport ERC20Kit\nimport EthereumKit\nimport Foundation\nimport PlatformKit\nimport PlatformUIKit\nimport RxCocoa\nimport RxSwift\nimport SafariServices\nimport ToolKit\n\nprotocol SendPaxViewControllerDelegate: class {\n    func onLoad()\n    func onAppear()\n    func onConfirmSendTapped()\n    func onSendProposed()\n    func onPaxEntry(_ value: CryptoValue?)\n    func onFiatEntry(_ value: FiatValue)\n    func onAddressEntry(_ value: String?)\n    func onErrorBarButtonItemTapped()\n    func onExchangeAddressButtonTapped()\n    func onQRBarButtonItemTapped()\n    \n    var rightNavigationCTAType: NavigationCTAType { get }\n}\n\nclass SendPaxViewController: UIViewController {\n    \n    // MARK: Public Properties\n    \n    weak var delegate: SendPaxViewControllerDelegate?\n    \n    // MARK: Private IBOutlets\n    \n    @IBOutlet private var outerStackView: UIStackView!\n    @IBOutlet private var topGravityStackView: UIStackView!\n\n    @IBOutlet private var sourceAccountTitleLabel: UILabel!\n    @IBOutlet private var sourceAccountValueLabel: UILabel!\n    \n    @IBOutlet private var destinationAddressTitleLabel: UILabel!\n    @IBOutlet private var destinationAddressIndicatorLabel: UILabel!\n    @IBOutlet private var destinationAddressTextField: UITextField!\n\n    @IBOutlet private var feesTitleLabel: UILabel!\n    @IBOutlet private var networkFeesLabel: UILabel!\n    \n    @IBOutlet private var maxAvailableLabel: ActionableLabel!\n\n    @IBOutlet private var cryptoTitleLabel: UILabel!\n    @IBOutlet private var cryptoAmountTextField: UITextField!\n    \n    @IBOutlet private var fiatTitleLabel: UILabel!\n    @IBOutlet private var fiatAmountTextField: UITextField!\n    \n    @IBOutlet private var sendNowButton: UIButton!\n    @IBOutlet private var exchangeAddressButton: UIButton!\n    \n    private var fields: [UITextField] {\n        [\n            destinationAddressTextField,\n            cryptoAmountTextField,\n            fiatAmountTextField\n        ]\n    }\n    \n    // MARK: Private Properties\n        \n    private var coordinator: SendPaxCoordinator!\n    private let alertViewPresenter: AlertViewPresenter = AlertViewPresenter.shared\n    private let loadingViewPresenter: LoadingViewPresenting = LoadingViewPresenter.shared\n    private var qrScannerViewModel: QRCodeScannerViewModel<AddressQRCodeParser>?\n    private let analyticsRecorder: AnalyticsEventRecording = resolve()\n    \n    private var maxAvailableTrigger: ActionableTrigger? {\n        didSet {\n            guard let trigger = maxAvailableTrigger else {\n                maxAvailableLabel.text = \"\"\n                return\n            }\n\n            let maxText = NSMutableAttributedString(\n                string: trigger.primaryString,\n                attributes: useMaxAttributes()\n            )\n\n            let CTA = NSAttributedString(\n                string: trigger.callToAction,\n                attributes: useMaxActionAttributes()\n            )\n\n            maxText.append(CTA)\n\n            maxAvailableLabel.attributedText = maxText\n        }\n    }\n    \n    // MARK: Class Functions\n    \n    @objc class func make() -> SendPaxViewController {\n        SendPaxViewController.makeFromStoryboard()\n    }\n    \n    // MARK: Lifecycle\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        coordinator = SendPaxCoordinator(\n            interface: self,\n            exchangeAddressPresenter: SendExchangeAddressStatePresenter(assetType: .pax)\n        )\n        fields.forEach({ $0.delegate = self })\n        topGravityStackView.addBackgroundColor(#colorLiteral(red: 0.8039215803, green: 0.8039215803, blue: 0.8039215803, alpha: 1))\n        sendNowButton.layer.cornerRadius = 4.0\n        sendNowButton.setTitle(LocalizationConstants.continueString, for: .normal)\n        maxAvailableLabel.delegate = self\n        delegate?.onLoad()\n        setupKeyboard()\n        setupAccessibility()\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        delegate?.onAppear()\n    }\n    \n    private func setupAccessibility() {\n        sourceAccountTitleLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.sourceAccountTitleLabel\n        sourceAccountValueLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.sourceAccountValueLabel\n        \n        destinationAddressTitleLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.destinationAddressTitleLabel\n        destinationAddressTextField.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.destinationAddressTextField\n        destinationAddressIndicatorLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.destinationAddressIndicatorLabel\n        \n        feesTitleLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.feesTitleLabel\n        networkFeesLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.feesValueLabel\n        \n        maxAvailableLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.maxAvailableLabel\n        \n        cryptoTitleLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.cryptoTitleLabel\n        cryptoAmountTextField.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.cryptoAmountTextField\n\n        fiatTitleLabel.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.fiatTitleLabel\n        fiatAmountTextField.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.fiatAmountTextField\n        \n        exchangeAddressButton.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.exchangeAddressButton\n        \n        sendNowButton.accessibilityIdentifier = AccessibilityIdentifiers.SendScreen.continueButton\n    }\n    \n    private func setupKeyboard() {\n        let bar = UIToolbar()\n        let doneButton = UIBarButtonItem(barButtonSystemItem: .done, target: self, action: #selector(dismissKeyboard))\n        let flexibleSpace = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: self, action: nil)\n        bar.items = [ flexibleSpace, doneButton ]\n        bar.sizeToFit()\n        \n        destinationAddressTextField.inputAccessoryView = bar\n        fiatAmountTextField.inputAccessoryView = bar\n        cryptoAmountTextField.inputAccessoryView = bar\n        hideKeyboardWhenTappedAround()\n    }\n    \n    private func apply(_ update: SendMoniesPresentationUpdate) {\n        switch update {\n        case .cryptoValueTextField(let amount):\n            guard cryptoAmountTextField.isFirstResponder == false else { return }\n            if amount?.amount == 0 {\n                cryptoAmountTextField.text = \"\"\n            } else {\n                cryptoAmountTextField.text = amount?.toDisplayString(includeSymbol: false)\n            }\n        case .feeValueLabel(let fee):\n            networkFeesLabel.text = fee\n        case .toAddressTextField(let address):\n            destinationAddressTextField.text = address\n        case .fiatValueTextField(let amount):\n            guard fiatAmountTextField.isFirstResponder == false else { return }\n            if amount?.amount == 0 {\n                fiatAmountTextField.text = \"\"\n            } else {\n                fiatAmountTextField.text = amount?.toDisplayString(includeSymbol: false, locale: Locale.current)\n            }\n        case .loadingIndicatorVisibility(let visibility):\n            switch visibility {\n            case .hidden:\n                loadingViewPresenter.hide()\n            case .visible:\n                loadingViewPresenter.show(with: LocalizationConstants.loading)\n            }\n        case .sendButtonEnabled(let enabled):\n            sendNowButton.isEnabled = enabled\n            sendNowButton.alpha = enabled ? 1.0 : 0.5\n        case .textFieldEditingEnabled(let editable):\n            fields.forEach({ $0.isEnabled = editable })\n        case .showAlertSheetForError(let error):\n            handle(error: error)\n        case .showAlertSheetForSuccess:\n            let alert = AlertModel(\n                headline: LocalizationConstants.success,\n                body: LocalizationConstants.SendAsset.paymentSent,\n                image: #imageLiteral(resourceName: \"eth_good\"),\n                style: .sheet\n            )\n            let alertView = AlertView.make(with: alert, completion: nil)\n            alertView.show()\n        case .hideConfirmationModal:\n            ModalPresenter.shared.closeAllModals()\n        case .updateNavigationItems:\n            if let navController = navigationController as? BaseNavigationController {\n                navController.update()\n            }\n        case .walletLabel(let accountLabel):\n            sourceAccountValueLabel.text = accountLabel\n        case .maxAvailable(let max):\n            maxAvailableTrigger = ActionableTrigger(\n                text: LocalizationConstants.SendAsset.useTotalSpendableBalance,\n                CTA: max?.toDisplayString(includeSymbol: true) ?? \"...\"\n            ) { [weak self] in\n                guard let max = max else { return }\n                self?.delegate?.onPaxEntry(max)\n            }\n        case .fiatCurrencyLabel(let fiatCurrency):\n            fiatTitleLabel.text = fiatCurrency\n        case .exchangeAddressButtonVisibility(let isVisible):\n            exchangeAddressButton.isHidden = !isVisible\n        case .useExchangeAddress(let address):\n            destinationAddressTextField.text = address\n            if address == nil {\n                exchangeAddressButton.setImage(UIImage(named: \"exchange-icon-small\"), for: .normal)\n                destinationAddressTextField.isHidden = false\n                destinationAddressIndicatorLabel.text = nil\n            } else {\n                exchangeAddressButton.setImage(UIImage(named: \"cancel_icon\"), for: .normal)\n                destinationAddressTextField.isHidden = true\n                destinationAddressIndicatorLabel.text = String(\n                    format: LocalizationConstants.Exchange.Send.destination,\n                    CryptoCurrency.pax.displayCode\n                )\n            }\n        case .showAlertForEnabling2FA:\n            alertViewPresenter.standardNotify(\n                title: LocalizationConstants.Errors.error, message: LocalizationConstants.Exchange.twoFactorNotEnabled\n            )\n        }\n    }\n    \n    // MARK: Private Helpers\n\n    private func useMaxAttributes() -> [NSAttributedString.Key: Any] {\n        let fontName = Constants.FontNames.montserratRegular\n        let font = UIFont(name: fontName, size: 13.0) ?? UIFont.systemFont(ofSize: 13.0)\n        return [\n            .font: font,\n            .foregroundColor: UIColor.darkGray\n        ]\n    }\n\n    private func useMaxActionAttributes() -> [NSAttributedString.Key: Any] {\n        let fontName = Constants.FontNames.montserratRegular\n        let font = UIFont(name: fontName, size: 13.0) ?? UIFont.systemFont(ofSize: 13.0)\n        return [\n            .font: font,\n            .foregroundColor: UIColor.brandSecondary\n        ]\n    }\n    \n    fileprivate func handle(error: SendMoniesInternalError) {\n        fields.forEach({ $0.resignFirstResponder() })\n        var alert = AlertModel(\n            headline: error.title,\n            body: error.description,\n            image: #imageLiteral(resourceName: \"eth_bad\"),\n            style: .sheet\n        )\n        if error == .insufficientFeeCoverage {\n            guard let url = URL(string: Constants.Url.ethGasExplanationForPax) else { return }\n            let action = AlertAction(style: .confirm(LocalizationConstants.learnMore), metadata: .url(url))\n            alert.actions = [action]\n        }\n        let alertView = AlertView.make(with: alert) { [weak self] action in\n            guard let self = self else { return }\n            guard let metadata = action.metadata else { return }\n            switch metadata {\n            case .url(let url):\n                let viewController = SFSafariViewController(url: url)\n                viewController.modalPresentationStyle = .overFullScreen\n                self.present(viewController, animated: true, completion: nil)\n            case .block,\n                 .pop,\n                 .payload,\n                 .dismiss:\n                break\n            }\n        }\n        alertView.show()\n    }\n    \n    // MARK: Actions\n    \n    @IBAction private func sendNowTapped(_ sender: UIButton) {\n        delegate?.onSendProposed()\n    }\n    \n    @IBAction private func exchangeAddressButtonPressed() {\n        delegate?.onExchangeAddressButtonTapped()\n    }\n}\n\nextension SendPaxViewController: UITextFieldDelegate {\n    func textFieldDidEndEditing(_ textField: UITextField) {\n        guard let text = textField.text, !text.isEmpty else { return }\n        if textField == cryptoAmountTextField {\n            let value = CryptoValue.paxFromMajor(string: text)\n            delegate?.onPaxEntry(value)\n        }\n        if textField == fiatAmountTextField {\n            let currencyCode = BlockchainSettings.App.shared.fiatCurrencyCode\n            let value = FiatValue.create(amountString: text, currencyCode: currencyCode)\n            delegate?.onFiatEntry(value)\n        }\n    }\n    \n    func textFieldShouldClear(_ textField: UITextField) -> Bool {\n        if textField == destinationAddressTextField {\n            delegate?.onAddressEntry(\"\")\n        }\n        return true\n    }\n    \n    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {\n        guard let text = textField.text else { return true }\n        \n        let replacementInput = (text as NSString).replacingCharacters(in: range, with: string)\n        \n        if textField == destinationAddressTextField {\n            delegate?.onAddressEntry(replacementInput)\n        }\n        if textField == cryptoAmountTextField {\n            let value = CryptoValue.paxFromMajor(string: replacementInput)\n            delegate?.onPaxEntry(value)\n        }\n        if textField == fiatAmountTextField {\n            let currencyCode = BlockchainSettings.App.shared.fiatCurrencyCode\n            let value = FiatValue.create(amountString: replacementInput, currencyCode: currencyCode)\n            delegate?.onFiatEntry(value)\n        }\n        return true\n    }\n}\n\nextension SendPaxViewController: NavigatableView {\n    func navControllerRightBarButtonTapped(_ navController: UINavigationController) {\n        if let type = delegate?.rightNavigationCTAType, type == .error {\n            delegate?.onErrorBarButtonItemTapped()\n        } else if let type = delegate?.rightNavigationCTAType, type == .qrCode {\n            delegate?.onQRBarButtonItemTapped()\n        } else if let parent = parent as? AssetSelectorContainerViewController {\n            parent.navControllerRightBarButtonTapped(navController)\n        }\n    }\n    \n    func navControllerLeftBarButtonTapped(_ navController: UINavigationController) {\n        if let parent = parent as? AssetSelectorContainerViewController {\n            parent.navControllerLeftBarButtonTapped(navController)\n        }\n    }\n    \n    var rightNavControllerCTAType: NavigationCTAType {\n        delegate?.rightNavigationCTAType ?? .qrCode\n    }\n    \n    var rightCTATintColor: UIColor {\n        guard let delegate = delegate else { return .white }\n        if delegate.rightNavigationCTAType == .qrCode ||\n            delegate.rightNavigationCTAType == .activityIndicator {\n            return .white\n        }\n        return .pending\n    }\n}\n\nextension SendPaxViewController: SendPAXInterface {\n    func apply(updates: Set<SendMoniesPresentationUpdate>) {\n        updates.forEach({ self.apply($0) })\n    }\n    \n    func display(confirmation: BCConfirmPaymentViewModel) {\n        let confirmView = BCConfirmPaymentView(\n            frame: view.frame,\n            viewModel: confirmation,\n            sendButtonFrame: sendNowButton.frame\n        )!\n        confirmView.confirmDelegate = self\n        ModalPresenter.shared.showModal(\n            withContent: confirmView,\n            closeType: ModalCloseTypeBack,\n            showHeader: true,\n            headerText: LocalizationConstants.SendAsset.confirmPayment\n        )\n    }\n    \n    func displayQRCodeScanner() {\n        scanQrCodeForDestinationAddress()\n    }\n}\n\nextension SendPaxViewController: ConfirmPaymentViewDelegate {\n    func confirmButtonDidTap(_ note: String?) {\n        delegate?.onConfirmSendTapped()\n    }\n    \n    func feeInformationButtonClicked() {\n        // TODO\n    }\n}\n\nextension SendPaxViewController {\n    func hideKeyboardWhenTappedAround() {\n        let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(SendPaxViewController.dismissKeyboard))\n        tap.cancelsTouchesInView = false\n        view.addGestureRecognizer(tap)\n    }\n    \n    @objc func dismissKeyboard() {\n        view.endEditing(true)\n    }\n}\n\n// TODO: Clean this up, move to Coordinator\nextension SendPaxViewController {\n    @objc func scanQrCodeForDestinationAddress() {\n        guard let scanner = QRCodeScanner() else { return }\n        \n        let parser = AddressQRCodeParser(assetType: .pax)\n        let textViewModel = AddressQRCodeTextViewModel()\n        \n        qrScannerViewModel = QRCodeScannerViewModel(\n            parser: parser,\n            additionalParsingOptions: .lax(routes: [.exchangeLinking]),\n            textViewModel: textViewModel,\n            scanner: scanner,\n            completed: { [weak self] result in\n                self?.handleAddressScan(result: result)\n            }\n        )\n        \n        let viewController = QRCodeScannerViewControllerBuilder(viewModel: qrScannerViewModel)?\n            .with(presentationType: .modal(dismissWithAnimation: false))\n            .build()\n        \n        guard let qrCodeScannerViewController = viewController else { return }\n        \n        DispatchQueue.main.async {\n            guard let controller = AppCoordinator.shared.tabControllerManager.tabViewController else { return }\n            controller.present(qrCodeScannerViewController, animated: true, completion: nil)\n        }\n    }\n    \n    private func handleAddressScan(result: Result<AddressQRCodeParser.Address, AddressQRCodeParser.AddressQRCodeParserError>) {\n        if case .success(let assetURL) = result {\n            let address = assetURL.payload.address\n            delegate?.onAddressEntry(address)\n            destinationAddressTextField.text = address\n\n            guard\n                let amount = assetURL.payload.amount,\n                let value = CryptoValue.paxFromMajor(string: amount)\n            else {\n                return\n            }\n            delegate?.onPaxEntry(value)\n            cryptoAmountTextField.insertText(amount)\n        }\n    }\n}\n\nextension SendPaxViewController: ActionableLabelDelegate {\n    func targetRange(_ label: ActionableLabel) -> NSRange? {\n        maxAvailableTrigger?.actionRange()\n    }\n\n    func actionRequestingExecution(label: ActionableLabel) {\n        guard let trigger = maxAvailableTrigger else { return }\n        analyticsRecorder.record(event: AnalyticsEvents.Send.sendFormUseBalanceClick(asset: .pax))\n        trigger.execute()\n    }\n}\n"
}