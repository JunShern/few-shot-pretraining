{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "8818",
    "text": "Q:\n\nCall C standard library function from asm in Visual Studio\n\nI have a problem with calling C function from asm project created in visual studio (Win10 x64, Visual Studio 2015). Project consist of one asm file:\n.586\n.model flat, stdcall\noption casemap:none\nincludelib msvcrt.lib\n\nExitProcess PROTO return:DWORD\nextern printf:near\n\n.data\ntext BYTE \"Text\", 0\n\n.code\nmain PROC\n    push offset text\n    call printf\n    add esp,4\n    invoke ExitProcess,0\nmain ENDP\nend main\n\nWhen I build project, linker outputs the error:\n\nError LNK2019 unresolved external symbol _printf referenced in\n  function _main@0\n\nLinker output parameters:\n\n/OUT:\"C:\\Users\\apple\\Documents\\SP_Lab7\\Debug\\SP_Lab7_Demo.exe\"\n  /MANIFEST:NO /NXCOMPAT\n  /PDB:\"C:\\Users\\apple\\Documents\\SP_Lab7\\Debug\\SP_Lab7_Demo.pdb\"\n  /DYNAMICBASE \"kernel32.lib\" \"user32.lib\" \"gdi32.lib\" \"winspool.lib\"\n  \"comdlg32.lib\" \"advapi32.lib\" \"shell32.lib\" \"ole32.lib\" \"oleaut32.lib\"\n  \"uuid.lib\" \"odbc32.lib\" \"odbccp32.lib\" /MACHINE:X86 /SAFESEH:NO\n  /INCREMENTAL:NO\n  /PGD:\"C:\\Users\\apple\\Documents\\SP_Lab7\\Debug\\SP_Lab7_Demo.pgd\"\n  /SUBSYSTEM:WINDOWS /MANIFESTUAC:\"level='asInvoker' uiAccess='false'\"\n  /ManifestFile:\"Debug\\SP_Lab7_Demo.exe.intermediate.manifest\"\n  /ERRORREPORT:PROMPT /NOLOGO /TLBID:1\n\nIf I comment call print, then everything executes normally (even Windows API function). Is there any way to call C function from asm file without creating cpp file that includes <cstdio>? \nIs it possible to do?\n\nA:\n\nMicrosoft refactored much of the C runtime and libraries in VS 2015. Some functions are no longer exported from the C library (some are defined in a C header file). Microsoft has some compatibility libraries like legacy_stdio_definitions.lib and legacy_stdio_wide_specifiers.lib, but you can also choose to use the older Visual Studio 2013 platform toolset with the older C libraries.\nTo change the platform toolset: pull down the Project menu; select Properties...; go to Configuration Properties/General, and change Platform Toolset to Visual Studio 2013 (v120)\n\nA:\n\nIt appears that it' possible to use the Visual Studio 2015 Toolset with a few modifications. \n\nYou'll need to add these libraries to your dependencies: libcmt.lib, libvcruntime.lib, libucrt.lib, legacy_stdio_definitions.lib. Alternatively you could use includelib to include these libraries in your assembly file.\nSpecify C calling convention for your main procedure using PROC C \nAt the end of your file (and this is important) do not use end main, use end only. Not fixing this may cause unexpected crashes. \nAlthough we can use ExitProcess to exit our application, we can also put the return code in EAX and do a ret to return. The C runtime calls our main function, and will call the shutdown code for us upon returning.\n\nThe code could look like:\n.586\n.model flat, stdcall\noption casemap:none\n\nincludelib libcmt.lib\nincludelib libvcruntime.lib\nincludelib libucrt.lib\nincludelib legacy_stdio_definitions.lib\n\nExitProcess PROTO return:DWORD\nextern printf:NEAR\n\n.data\ntext BYTE \"Text\", 0\n\n.code\nmain PROC C                    ; Specify \"C\" calling convention\n    push offset text\n    call printf\n    add  esp, 4\n;   invoke ExitProcess,0       ; Since the C library called main (this function)\n                               ; we can set eax to 0 and use ret`to have\n                               ; the C runtime close down and return our error\n                               ; code instead of invoking ExitProcess\n    mov eax, 0\n    ret\nmain ENDP\nend                            ; Use `end` on a line by itself\n                               ; We don't want to use `end main` as that would\n                               ; make this function our program entry point\n                               ; effectively skipping by the C runtime initialization\n\n"
}