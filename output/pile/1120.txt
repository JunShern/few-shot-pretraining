{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*']."
        }
    ],
    "doc_id": "1120",
    "text": "/*\n     File:       SFNTLayoutTypes.h\n \n     Contains:   SFNT file layout structures and constants.\n \n     Version:    QuickTime 7.3\n \n     Copyright:  (c) 2007 (c) 1994-2001 by Apple Computer, Inc., all rights reserved.\n \n     Bugs?:      For bug reports, consult the following page on\n                 the World Wide Web:\n \n                     http://developer.apple.com/bugreporter/\n \n*/\n#ifndef __SFNTLAYOUTTYPES__\n#define __SFNTLAYOUTTYPES__\n\n#ifndef __MACTYPES__\n#include <MacTypes.h>\n#endif\n\n\n\n#if PRAGMA_ONCE\n#pragma once\n#endif\n\n#if PRAGMA_IMPORT\n#pragma import on\n#endif\n\n#if PRAGMA_STRUCT_ALIGN\n    #pragma options align=mac68k\n#elif PRAGMA_STRUCT_PACKPUSH\n    #pragma pack(push, 2)\n#elif PRAGMA_STRUCT_PACK\n    #pragma pack(2)\n#endif\n\n/* ----------------------------------------------------------------------------------------- */\n/* CONSTANTS */\n/*\n    The following values can be used to set run feature values. Note that unless the\n    feature is defaulted differently in different fonts, the zero value for the\n    selectors represents the default value.  Check the following URL site for further info:\n    \"http://fonts.apple.com/Registry\"\n*/\n\n\n/*\n *  Summary:\n *    Feature types\n */\nenum {\n  kAllTypographicFeaturesType   = 0,\n  kLigaturesType                = 1,\n  kCursiveConnectionType        = 2,\n  kLetterCaseType               = 3,\n  kVerticalSubstitutionType     = 4,\n  kLinguisticRearrangementType  = 5,\n  kNumberSpacingType            = 6,\n  kSmartSwashType               = 8,\n  kDiacriticsType               = 9,\n  kVerticalPositionType         = 10,\n  kFractionsType                = 11,\n  kOverlappingCharactersType    = 13,\n  kTypographicExtrasType        = 14,\n  kMathematicalExtrasType       = 15,\n  kOrnamentSetsType             = 16,\n  kCharacterAlternativesType    = 17,\n  kDesignComplexityType         = 18,\n  kStyleOptionsType             = 19,\n  kCharacterShapeType           = 20,\n  kNumberCaseType               = 21,\n  kTextSpacingType              = 22,\n  kTransliterationType          = 23,\n  kAnnotationType               = 24,\n  kKanaSpacingType              = 25,\n  kIdeographicSpacingType       = 26,\n  kUnicodeDecompositionType     = 27,\n  kRubyKanaType                 = 28,\n  kCJKSymbolAlternativesType    = 29,\n  kIdeographicAlternativesType  = 30,\n  kCJKVerticalRomanPlacementType = 31,\n  kItalicCJKRomanType           = 32,\n  kCJKRomanSpacingType          = 103,\n  kLastFeatureType              = -1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kAllTypographicFeaturesType\n */\nenum {\n  kAllTypeFeaturesOnSelector    = 0,\n  kAllTypeFeaturesOffSelector   = 1\n};\n\n\n\n/*\n *  Summary:\n *    Selectors for feature type kLigaturesType\n */\nenum {\n  kRequiredLigaturesOnSelector  = 0,\n  kRequiredLigaturesOffSelector = 1,\n  kCommonLigaturesOnSelector    = 2,\n  kCommonLigaturesOffSelector   = 3,\n  kRareLigaturesOnSelector      = 4,\n  kRareLigaturesOffSelector     = 5,\n  kLogosOnSelector              = 6,\n  kLogosOffSelector             = 7,\n  kRebusPicturesOnSelector      = 8,\n  kRebusPicturesOffSelector     = 9,\n  kDiphthongLigaturesOnSelector = 10,\n  kDiphthongLigaturesOffSelector = 11,\n  kSquaredLigaturesOnSelector   = 12,\n  kSquaredLigaturesOffSelector  = 13,\n  kAbbrevSquaredLigaturesOnSelector = 14,\n  kAbbrevSquaredLigaturesOffSelector = 15,\n  kSymbolLigaturesOnSelector    = 16,\n  kSymbolLigaturesOffSelector   = 17\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kCursiveConnectionType\n */\nenum {\n  kUnconnectedSelector          = 0,\n  kPartiallyConnectedSelector   = 1,\n  kCursiveSelector              = 2\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kLetterCaseType\n */\nenum {\n  kUpperAndLowerCaseSelector    = 0,\n  kAllCapsSelector              = 1,\n  kAllLowerCaseSelector         = 2,\n  kSmallCapsSelector            = 3,\n  kInitialCapsSelector          = 4,\n  kInitialCapsAndSmallCapsSelector = 5\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kVerticalSubstitutionType\n */\nenum {\n  kSubstituteVerticalFormsOnSelector = 0,\n  kSubstituteVerticalFormsOffSelector = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kLinguisticRearrangementType\n */\nenum {\n  kLinguisticRearrangementOnSelector = 0,\n  kLinguisticRearrangementOffSelector = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kNumberSpacingType\n */\nenum {\n  kMonospacedNumbersSelector    = 0,\n  kProportionalNumbersSelector  = 1,\n  kThirdWidthNumbersSelector    = 2,\n  kQuarterWidthNumbersSelector  = 3\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kSmartSwashType\n */\nenum {\n  kWordInitialSwashesOnSelector = 0,\n  kWordInitialSwashesOffSelector = 1,\n  kWordFinalSwashesOnSelector   = 2,\n  kWordFinalSwashesOffSelector  = 3,\n  kLineInitialSwashesOnSelector = 4,\n  kLineInitialSwashesOffSelector = 5,\n  kLineFinalSwashesOnSelector   = 6,\n  kLineFinalSwashesOffSelector  = 7,\n  kNonFinalSwashesOnSelector    = 8,\n  kNonFinalSwashesOffSelector   = 9\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kDiacriticsType\n */\nenum {\n  kShowDiacriticsSelector       = 0,\n  kHideDiacriticsSelector       = 1,\n  kDecomposeDiacriticsSelector  = 2\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kVerticalPositionType\n */\nenum {\n  kNormalPositionSelector       = 0,\n  kSuperiorsSelector            = 1,\n  kInferiorsSelector            = 2,\n  kOrdinalsSelector             = 3\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kFractionsType\n */\nenum {\n  kNoFractionsSelector          = 0,\n  kVerticalFractionsSelector    = 1,\n  kDiagonalFractionsSelector    = 2\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kOverlappingCharactersType\n */\nenum {\n  kPreventOverlapOnSelector     = 0,\n  kPreventOverlapOffSelector    = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kTypographicExtrasType\n */\nenum {\n  kHyphensToEmDashOnSelector    = 0,\n  kHyphensToEmDashOffSelector   = 1,\n  kHyphenToEnDashOnSelector     = 2,\n  kHyphenToEnDashOffSelector    = 3,\n  kSlashedZeroOnSelector        = 4,\n  kSlashedZeroOffSelector       = 5,\n  kFormInterrobangOnSelector    = 6,\n  kFormInterrobangOffSelector   = 7,\n  kSmartQuotesOnSelector        = 8,\n  kSmartQuotesOffSelector       = 9,\n  kPeriodsToEllipsisOnSelector  = 10,\n  kPeriodsToEllipsisOffSelector = 11\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kMathematicalExtrasType\n */\nenum {\n  kHyphenToMinusOnSelector      = 0,\n  kHyphenToMinusOffSelector     = 1,\n  kAsteriskToMultiplyOnSelector = 2,\n  kAsteriskToMultiplyOffSelector = 3,\n  kSlashToDivideOnSelector      = 4,\n  kSlashToDivideOffSelector     = 5,\n  kInequalityLigaturesOnSelector = 6,\n  kInequalityLigaturesOffSelector = 7,\n  kExponentsOnSelector          = 8,\n  kExponentsOffSelector         = 9\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kOrnamentSetsType\n */\nenum {\n  kNoOrnamentsSelector          = 0,\n  kDingbatsSelector             = 1,\n  kPiCharactersSelector         = 2,\n  kFleuronsSelector             = 3,\n  kDecorativeBordersSelector    = 4,\n  kInternationalSymbolsSelector = 5,\n  kMathSymbolsSelector          = 6\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kCharacterAlternativesType\n */\nenum {\n  kNoAlternatesSelector         = 0\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kDesignComplexityType\n */\nenum {\n  kDesignLevel1Selector         = 0,\n  kDesignLevel2Selector         = 1,\n  kDesignLevel3Selector         = 2,\n  kDesignLevel4Selector         = 3,\n  kDesignLevel5Selector         = 4\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kStyleOptionsType\n */\nenum {\n  kNoStyleOptionsSelector       = 0,\n  kDisplayTextSelector          = 1,\n  kEngravedTextSelector         = 2,\n  kIlluminatedCapsSelector      = 3,\n  kTitlingCapsSelector          = 4,\n  kTallCapsSelector             = 5\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kCharacterShapeType\n */\nenum {\n  kTraditionalCharactersSelector = 0,\n  kSimplifiedCharactersSelector = 1,\n  kJIS1978CharactersSelector    = 2,\n  kJIS1983CharactersSelector    = 3,\n  kJIS1990CharactersSelector    = 4,\n  kTraditionalAltOneSelector    = 5,\n  kTraditionalAltTwoSelector    = 6,\n  kTraditionalAltThreeSelector  = 7,\n  kTraditionalAltFourSelector   = 8,\n  kTraditionalAltFiveSelector   = 9,\n  kExpertCharactersSelector     = 10\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kNumberCaseType\n */\nenum {\n  kLowerCaseNumbersSelector     = 0,\n  kUpperCaseNumbersSelector     = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kTextSpacingType\n */\nenum {\n  kProportionalTextSelector     = 0,\n  kMonospacedTextSelector       = 1,\n  kHalfWidthTextSelector        = 2\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kTransliterationType\n */\nenum {\n  kNoTransliterationSelector    = 0,\n  kHanjaToHangulSelector        = 1,\n  kHiraganaToKatakanaSelector   = 2,\n  kKatakanaToHiraganaSelector   = 3,\n  kKanaToRomanizationSelector   = 4,\n  kRomanizationToHiraganaSelector = 5,\n  kRomanizationToKatakanaSelector = 6,\n  kHanjaToHangulAltOneSelector  = 7,\n  kHanjaToHangulAltTwoSelector  = 8,\n  kHanjaToHangulAltThreeSelector = 9\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kAnnotationType\n */\nenum {\n  kNoAnnotationSelector         = 0,\n  kBoxAnnotationSelector        = 1,\n  kRoundedBoxAnnotationSelector = 2,\n  kCircleAnnotationSelector     = 3,\n  kInvertedCircleAnnotationSelector = 4,\n  kParenthesisAnnotationSelector = 5,\n  kPeriodAnnotationSelector     = 6,\n  kRomanNumeralAnnotationSelector = 7,\n  kDiamondAnnotationSelector    = 8,\n  kInvertedBoxAnnotationSelector = 9,\n  kInvertedRoundedBoxAnnotationSelector = 10\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kKanaSpacingType\n */\nenum {\n  kFullWidthKanaSelector        = 0,\n  kProportionalKanaSelector     = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kIdeographicSpacingType\n */\nenum {\n  kFullWidthIdeographsSelector  = 0,\n  kProportionalIdeographsSelector = 1,\n  kHalfWidthIdeographsSelector  = 2\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kUnicodeDecompositionType\n */\nenum {\n  kCanonicalCompositionOnSelector = 0,\n  kCanonicalCompositionOffSelector = 1,\n  kCompatibilityCompositionOnSelector = 2,\n  kCompatibilityCompositionOffSelector = 3,\n  kTranscodingCompositionOnSelector = 4,\n  kTranscodingCompositionOffSelector = 5\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kRubyKanaType\n */\nenum {\n  kNoRubyKanaSelector           = 0,\n  kRubyKanaSelector             = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kCJKSymbolAlternativesType\n */\nenum {\n  kNoCJKSymbolAlternativesSelector = 0,\n  kCJKSymbolAltOneSelector      = 1,\n  kCJKSymbolAltTwoSelector      = 2,\n  kCJKSymbolAltThreeSelector    = 3,\n  kCJKSymbolAltFourSelector     = 4,\n  kCJKSymbolAltFiveSelector     = 5\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kIdeographicAlternativesType\n */\nenum {\n  kNoIdeographicAlternativesSelector = 0,\n  kIdeographicAltOneSelector    = 1,\n  kIdeographicAltTwoSelector    = 2,\n  kIdeographicAltThreeSelector  = 3,\n  kIdeographicAltFourSelector   = 4,\n  kIdeographicAltFiveSelector   = 5\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kCJKVerticalRomanPlacementType\n */\nenum {\n  kCJKVerticalRomanCenteredSelector = 0,\n  kCJKVerticalRomanHBaselineSelector = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kItalicCJKRomanType\n */\nenum {\n  kNoCJKItalicRomanSelector     = 0,\n  kCJKItalicRomanSelector       = 1\n};\n\n\n/*\n *  Summary:\n *    Selectors for feature type kCJKRomanSpacingType\n */\nenum {\n  kHalfWidthCJKRomanSelector    = 0,\n  kProportionalCJKRomanSelector = 1,\n  kDefaultCJKRomanSelector      = 2,\n  kFullWidthCJKRomanSelector    = 3\n};\n\n/* --------------------------------------------------------------------------- */\n/* ---------------- Table Specific Typedefs and Constants -------------------- */\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: lookup tables - used within various other tables */\nenum {\n  kSFNTLookupSimpleArray        = 0,    /* a simple array indexed by glyph code */\n  kSFNTLookupSegmentSingle      = 2,    /* segment mapping to single value */\n  kSFNTLookupSegmentArray       = 4,    /* segment mapping to lookup array */\n  kSFNTLookupSingleTable        = 6,    /* sorted list of glyph, value pairs */\n  kSFNTLookupTrimmedArray       = 8     /* a simple trimmed array indexed by glyph code */\n};\n\ntypedef UInt16                          SFNTLookupTableFormat;\ntypedef UInt16                          SFNTLookupValue;\ntypedef UInt16                          SFNTLookupOffset;\ntypedef UInt32                          SFNTLookupKind;\n/*\n    A BinarySearchHeader defines the five standard fields needed to perform quick\n    lookups in a lookup table (note that using UInt16s, and not ItemCounts or\n    similar types, is important here, since these tables are in fonts, and the\n    documented font formats specify 16-bit quantities).\n*/\nstruct SFNTLookupBinarySearchHeader {\n  UInt16              unitSize;               /* size of a unit in bytes */\n  UInt16              nUnits;                 /* number of units in table */\n  UInt16              searchRange;            /* (largest power of two <= nUnits) * unitSize */\n  UInt16              entrySelector;          /* log2 (largest power of two <= nUnits) */\n  UInt16              rangeShift;             /* (nUnits - largest power of two <= nUnits) * unitSize */\n};\ntypedef struct SFNTLookupBinarySearchHeader SFNTLookupBinarySearchHeader;\n/* A format 0 lookup table maps all glyphs in the font to lookup values */\nstruct SFNTLookupArrayHeader {\n  SFNTLookupValue     lookupValues[1];\n};\ntypedef struct SFNTLookupArrayHeader    SFNTLookupArrayHeader;\n/* A format 8 lookup table maps some range of glyphs in the font to lookup values */\nstruct SFNTLookupTrimmedArrayHeader {\n  UInt16              firstGlyph;\n  UInt16              count;\n  SFNTLookupValue     valueArray[1];\n};\ntypedef struct SFNTLookupTrimmedArrayHeader SFNTLookupTrimmedArrayHeader;\n/*\n    Format 2 and format 4 lookup tables map ranges of glyphs to either single lookup\n    values (format 2), or per-glyph lookup values (format 4). Since both formats\n    use the same kind of data, only one unified set of segment-related structures\n    is defined.\n*/\nstruct SFNTLookupSegment {\n  UInt16              lastGlyph;\n  UInt16              firstGlyph;\n  UInt16              value[1];\n};\ntypedef struct SFNTLookupSegment        SFNTLookupSegment;\nstruct SFNTLookupSegmentHeader {\n  SFNTLookupBinarySearchHeader  binSearch;\n  SFNTLookupSegment   segments[1];\n};\ntypedef struct SFNTLookupSegmentHeader  SFNTLookupSegmentHeader;\n/* A format 6 lookup table maps single glyphs to lookup values. */\nstruct SFNTLookupSingle {\n  UInt16              glyph;\n  UInt16              value[1];\n};\ntypedef struct SFNTLookupSingle         SFNTLookupSingle;\nstruct SFNTLookupSingleHeader {\n  SFNTLookupBinarySearchHeader  binSearch;\n  SFNTLookupSingle    entries[1];\n};\ntypedef struct SFNTLookupSingleHeader   SFNTLookupSingleHeader;\n/* The format-specific part of the subtable header */\nunion SFNTLookupFormatSpecificHeader {\n  SFNTLookupArrayHeader  theArray;\n  SFNTLookupSegmentHeader  segment;\n  SFNTLookupSingleHeader  single;\n  SFNTLookupTrimmedArrayHeader  trimmedArray;\n};\ntypedef union SFNTLookupFormatSpecificHeader SFNTLookupFormatSpecificHeader;\n/* The overall subtable header */\nstruct SFNTLookupTable {\n  SFNTLookupTableFormat  format;              /* table format */\n  SFNTLookupFormatSpecificHeader  fsHeader;   /* format specific header */\n};\ntypedef struct SFNTLookupTable          SFNTLookupTable;\ntypedef SFNTLookupTable *               SFNTLookupTablePtr;\ntypedef SFNTLookupTablePtr *            SFNTLookupTableHandle;\n/* --------------------------------------------------------------------------- */\n/* GENERAL FORMATS FOR STATE TABLES -- prefix \"ST\" */\nenum {\n  kSTClassEndOfText             = 0,\n  kSTClassOutOfBounds           = 1,\n  kSTClassDeletedGlyph          = 2,\n  kSTClassEndOfLine             = 3,\n  kSTSetMark                    = 0x8000,\n  kSTNoAdvance                  = 0x4000,\n  kSTMarkEnd                    = 0x2000,\n  kSTLigActionMask              = 0x3FFF,\n  kSTRearrVerbMask              = 0x000F\n};\n\ntypedef UInt8                           STClass;\ntypedef UInt8                           STEntryIndex;\nstruct STHeader {\n  UInt8               filler;\n  STClass             nClasses;\n  UInt16              classTableOffset;\n  UInt16              stateArrayOffset;\n  UInt16              entryTableOffset;\n};\ntypedef struct STHeader                 STHeader;\nstruct STClassTable {\n  UInt16              firstGlyph;\n  UInt16              nGlyphs;\n  STClass             classes[1];\n};\ntypedef struct STClassTable             STClassTable;\nstruct STEntryZero {\n  UInt16              newState;\n  UInt16              flags;\n};\ntypedef struct STEntryZero              STEntryZero;\nstruct STEntryOne {\n  UInt16              newState;\n  UInt16              flags;\n  UInt16              offset1;\n};\ntypedef struct STEntryOne               STEntryOne;\nstruct STEntryTwo {\n  UInt16              newState;\n  UInt16              flags;\n  UInt16              offset1;\n  UInt16              offset2;\n};\ntypedef struct STEntryTwo               STEntryTwo;\n/* --------------------------------------------------------------------------- */\n/* GENERAL FORMATS FOR STATE TABLES to be used with 'morx' tables -- prefix \"STX\" */\nenum {\n  kSTXHasLigAction              = 0x2000\n};\n\n\ntypedef UInt16                          STXClass;\ntypedef UInt16                          STXStateIndex;\ntypedef UInt16                          STXEntryIndex;\nstruct STXHeader {\n  UInt32              nClasses;\n  UInt32              classTableOffset;\n  UInt32              stateArrayOffset;\n  UInt32              entryTableOffset;\n};\ntypedef struct STXHeader                STXHeader;\n\ntypedef SFNTLookupTable                 STXClassTable;\nstruct STXEntryZero {\n  STXStateIndex       newState;\n  UInt16              flags;\n};\ntypedef struct STXEntryZero             STXEntryZero;\nstruct STXEntryOne {\n  STXStateIndex       newState;\n  UInt16              flags;\n  UInt16              index1;\n};\ntypedef struct STXEntryOne              STXEntryOne;\nstruct STXEntryTwo {\n  STXStateIndex       newState;\n  UInt16              flags;\n  UInt16              index1;\n  UInt16              index2;\n};\ntypedef struct STXEntryTwo              STXEntryTwo;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'lcar' */\n/* CONSTANTS */\nenum {\n  kLCARTag                      = 0x6C636172, /* 'lcar' */\n  kLCARCurrentVersion           = 0x00010000, /* current version number for 'lcar' table */\n  kLCARLinearFormat             = 0,\n  kLCARCtlPointFormat           = 1\n};\n\n/* TYPES */\nstruct LcarCaretClassEntry {\n  UInt16              count;\n  UInt16              partials[1];            /* these are either FUnits or control-point numbers */\n};\ntypedef struct LcarCaretClassEntry      LcarCaretClassEntry;\nstruct LcarCaretTable {\n  Fixed               version;\n  UInt16              format;\n  SFNTLookupTable     lookup;\n};\ntypedef struct LcarCaretTable           LcarCaretTable;\ntypedef LcarCaretTable *                LcarCaretTablePtr;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'just' */\n/* CONSTANTS */\nenum {\n  kJUSTTag                      = 0x6A757374, /* 'just' */\n  kJUSTCurrentVersion           = 0x00010000,\n  kJUSTStandardFormat           = 0,\n  kJUSTnoGlyphcode              = 0xFFFF, /* used in a pcConditionalAddAction */\n  kJUSTpcDecompositionAction    = 0,\n  kJUSTpcUnconditionalAddAction = 1,\n  kJUSTpcConditionalAddAction   = 2,\n  kJUSTpcGlyphStretchAction     = 3,\n  kJUSTpcDuctilityAction        = 4,\n  kJUSTpcGlyphRepeatAddAction   = 5\n};\n\n/* Justification priority levels */\nenum {\n  kJUSTKashidaPriority          = 0,\n  kJUSTSpacePriority            = 1,\n  kJUSTLetterPriority           = 2,\n  kJUSTNullPriority             = 3,\n  kJUSTPriorityCount            = 4\n};\n\n/* Justification flags */\nenum {\n  kJUSTOverridePriority         = 0x8000,\n  kJUSTOverrideLimits           = 0x4000,\n  kJUSTOverrideUnlimited        = 0x2000,\n  kJUSTUnlimited                = 0x1000,\n  kJUSTPriorityMask             = 0x0003\n};\n\n/* TYPES */\ntypedef UInt16                          JustPCActionType;\ntypedef UInt16                          JustificationFlags;\n/* A JustPCDecompositionAction defines a ligature decomposition action. */\nstruct JustPCDecompositionAction {\n  Fixed               lowerLimit;\n  Fixed               upperLimit;\n  UInt16              order;\n  UInt16              count;\n  UInt16              glyphs[1];\n};\ntypedef struct JustPCDecompositionAction JustPCDecompositionAction;\n/* A JUSTPCUnconditionalAddAction defines an unconditional glyph add action. */\n\ntypedef UInt16                          JustPCUnconditionalAddAction;\n/*\n    A JUSTPCConditionalAddAction defines a glyph substitution and add action. If the addGlyph\n    is equal to kJUSTnoGlyphcode, then no glyph will be added, and the justification for\n    the line will be redone.\n*/\nstruct JustPCConditionalAddAction {\n  Fixed               substThreshhold;        /* threshhold of growth factor at which subst occurs */\n  UInt16              addGlyph;\n  UInt16              substGlyph;\n};\ntypedef struct JustPCConditionalAddAction JustPCConditionalAddAction;\n/* A PCDuctilityAction defines a ductile axis along which the glyph will be varied. */\nstruct JustPCDuctilityAction {\n  UInt32              ductilityAxis;\n  Fixed               minimumLimit;\n  Fixed               noStretchValue;\n  Fixed               maximumLimit;\n};\ntypedef struct JustPCDuctilityAction    JustPCDuctilityAction;\n/*\n    A PCGlyphRepetitionAction defines a glyph which will not be stretched or otherwise\n    transformed, but rather which will be emplaced however many times are needed to fill\n    the needed gap.\n*/\nstruct JustPCGlyphRepeatAddAction {\n  UInt16              flags;\n  UInt16              glyph;\n};\ntypedef struct JustPCGlyphRepeatAddAction JustPCGlyphRepeatAddAction;\n/* PCActionSubrecords contain the actual postcompensation actions. */\nstruct JustPCActionSubrecord {\n  UInt16              theClass;               /* justification class value associated with this rec */\n  JustPCActionType    theType;\n  UInt32              length;\n  UInt32              data;                   /* not really a UInt32; cast as ptr to appropriate action */\n};\ntypedef struct JustPCActionSubrecord    JustPCActionSubrecord;\n/* The set of postcompensation records is defined in a PCAction struct. */\nstruct JustPCAction {\n  UInt32              actionCount;            /* long for alignment purposes */\n  JustPCActionSubrecord  actions[1];\n};\ntypedef struct JustPCAction             JustPCAction;\n/*\n    JustWidthDeltaEntry is the justification table entry structure.  The justClass value (which is\n    actually limited to 7 bits by the state table structure) is defined as a long for PPC alignment reasons.\n*/\nstruct JustWidthDeltaEntry {\n  UInt32              justClass;\n  Fixed               beforeGrowLimit;        /* ems AW can grow by at most on LT */\n  Fixed               beforeShrinkLimit;      /* ems AW can shrink by at most on LT */\n  Fixed               afterGrowLimit;         /* ems AW can grow by at most on RB */\n  Fixed               afterShrinkLimit;       /* ems AW can shrink by at most on RB */\n  JustificationFlags  growFlags;              /* flags controlling grow case */\n  JustificationFlags  shrinkFlags;            /* flags controlling shrink case */\n};\ntypedef struct JustWidthDeltaEntry      JustWidthDeltaEntry;\nstruct JustWidthDeltaGroup {\n  UInt32              count;\n  JustWidthDeltaEntry  entries[1];\n};\ntypedef struct JustWidthDeltaGroup      JustWidthDeltaGroup;\n/* Overall structure of a postcompensation table is defined in PostcompTable. */\nstruct JustPostcompTable {\n  SFNTLookupTable     lookupTable;\n                                              /* action records here */\n};\ntypedef struct JustPostcompTable        JustPostcompTable;\nstruct JustDirectionTable {\n  UInt16              justClass;              /* offset to state table (0=none) */\n  UInt16              widthDeltaClusters;     /* offset to clusters */\n  UInt16              postcomp;               /* offset to postcomp table (0=none) */\n  SFNTLookupTable     lookup;\n};\ntypedef struct JustDirectionTable       JustDirectionTable;\nstruct JustTable {\n  Fixed               version;\n  UInt16              format;\n  UInt16              horizHeaderOffset;\n  UInt16              vertHeaderOffset;\n};\ntypedef struct JustTable                JustTable;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'opbd' */\n/* CONSTANTS */\nenum {\n  kOPBDTag                      = 0x6F706264, /* 'opbd' */\n  kOPBDCurrentVersion           = 0x00010000,\n  kOPBDDistanceFormat           = 0,\n  kOPBDControlPointFormat       = 1\n};\n\n/* TYPES */\n\ntypedef UInt16                          OpbdTableFormat;\n/*\n    The OpbdSideValues struct is the lookup result from the FindSingle call for the\n    optical tables. It contains the 4 FUnit values that are relevant to the specified\n    glyph, or the 4 control gxPoint values.\n*/\nstruct OpbdSideValues {\n  SInt16              leftSideShift;\n  SInt16              topSideShift;\n  SInt16              rightSideShift;\n  SInt16              bottomSideShift;\n};\ntypedef struct OpbdSideValues           OpbdSideValues;\nstruct OpbdTable {\n  Fixed               version;\n  OpbdTableFormat     format;\n  SFNTLookupTable     lookupTable;\n};\ntypedef struct OpbdTable                OpbdTable;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'mort' */\n/* CONSTANTS */\nenum {\n  kMORTTag                      = 0x6D6F7274, /* 'mort' */\n  kMORTCurrentVersion           = 0x00010000, /* current version number for 'mort' table */\n                                        /* Coverage masks */\n  kMORTCoverVertical            = 0x8000,\n  kMORTCoverDescending          = 0x4000,\n  kMORTCoverIgnoreVertical      = 0x2000,\n  kMORTCoverTypeMask            = 0x000F, /* Subtable types */\n  kMORTRearrangementType        = 0,\n  kMORTContextualType           = 1,\n  kMORTLigatureType             = 2,\n  kMORTSwashType                = 4,\n  kMORTInsertionType            = 5,    /* Ligature subtable constants */\n  kMORTLigLastAction            = (long)0x80000000,\n  kMORTLigStoreLigature         = 0x40000000,\n  kMORTLigFormOffsetMask        = 0x3FFFFFFF,\n  kMORTLigFormOffsetShift       = 2,    /* Rearrangement subtable actions */\n  kMORTraNoAction               = 0,    /*    no action   */\n  kMORTraxA                     = 1,    /*      Ax => xA    */\n  kMORTraDx                     = 2,    /*      xD => Dx    */\n  kMORTraDxA                    = 3,    /*     AxD => DxA   */\n  kMORTraxAB                    = 4,    /*   ABx => xAB   */\n  kMORTraxBA                    = 5,    /*   ABx => xBA   */\n  kMORTraCDx                    = 6,    /*   xCD => CDx   */\n  kMORTraDCx                    = 7,    /*   xCD => DCx   */\n  kMORTraCDxA                   = 8,    /*  AxCD => CDxA  */\n  kMORTraDCxA                   = 9,    /*  AxCD => DCxA  */\n  kMORTraDxAB                   = 10,   /*  ABxD => DxAB  */\n  kMORTraDxBA                   = 11,   /*  ABxD => DxBA  */\n  kMORTraCDxAB                  = 12,   /* ABxCD => CDxAB */\n  kMORTraCDxBA                  = 13,   /* ABxCD => CDxBA */\n  kMORTraDCxAB                  = 14,   /* ABxCD => DCxAB */\n  kMORTraDCxBA                  = 15,   /* ABxCD => DCxBA */\n                                        /* Insertion subtable constants */\n  kMORTDoInsertionsBefore       = 0x80,\n  kMORTIsSplitVowelPiece        = 0x40,\n  kMORTInsertionsCountMask      = 0x3F,\n  kMORTCurrInsertKashidaLike    = 0x2000,\n  kMORTMarkInsertKashidaLike    = 0x1000,\n  kMORTCurrInsertBefore         = 0x0800,\n  kMORTMarkInsertBefore         = 0x0400,\n  kMORTMarkJustTableCountMask   = 0x3F80,\n  kMORTMarkJustTableCountShift  = 7,    /* JustTableIndex for marked character */\n  kMORTCurrJustTableCountMask   = 0x007F,\n  kMORTCurrJustTableCountShift  = 0,    /* JustTableIndex for current character */\n  kMORTCurrInsertCountMask      = 0x03E0,\n  kMORTCurrInsertCountShift     = 5,    /* count to insert after current glyphRec */\n  kMORTMarkInsertCountMask      = 0x001F,\n  kMORTMarkInsertCountShift     = 0     /* count to insert after marked glyphRec */\n};\n\n/* TYPES */\n\ntypedef UInt32                          MortSubtableMaskFlags;\ntypedef UInt32                          MortLigatureActionEntry;\nstruct MortRearrangementSubtable {\n  STHeader            header;\n};\ntypedef struct MortRearrangementSubtable MortRearrangementSubtable;\nstruct MortContextualSubtable {\n  STHeader            header;\n  UInt16              substitutionTableOffset;\n};\ntypedef struct MortContextualSubtable   MortContextualSubtable;\nstruct MortLigatureSubtable {\n  STHeader            header;\n  UInt16              ligatureActionTableOffset;\n  UInt16              componentTableOffset;\n  UInt16              ligatureTableOffset;\n};\ntypedef struct MortLigatureSubtable     MortLigatureSubtable;\nstruct MortSwashSubtable {\n  SFNTLookupTable     lookup;\n};\ntypedef struct MortSwashSubtable        MortSwashSubtable;\nstruct MortInsertionSubtable {\n  STHeader            header;\n};\ntypedef struct MortInsertionSubtable    MortInsertionSubtable;\nunion MortSpecificSubtable {\n  MortRearrangementSubtable  rearrangement;\n  MortContextualSubtable  contextual;\n  MortLigatureSubtable  ligature;\n  MortSwashSubtable   swash;\n  MortInsertionSubtable  insertion;\n};\ntypedef union MortSpecificSubtable      MortSpecificSubtable;\nstruct MortSubtable {\n  UInt16              length;\n  UInt16              coverage;\n  MortSubtableMaskFlags  flags;\n  MortSpecificSubtable  u;\n};\ntypedef struct MortSubtable             MortSubtable;\nstruct MortFeatureEntry {\n  UInt16              featureType;\n  UInt16              featureSelector;\n  MortSubtableMaskFlags  enableFlags;\n  MortSubtableMaskFlags  disableFlags;\n};\ntypedef struct MortFeatureEntry         MortFeatureEntry;\nstruct MortChain {\n  MortSubtableMaskFlags  defaultFlags;        /* default flags for this chain */\n  UInt32              length;                 /* byte length of this chain */\n  UInt16              nFeatures;              /* number of feature entries */\n  UInt16              nSubtables;             /* number of subtables */\n  MortFeatureEntry    featureEntries[1];\n                                              /* the subtables follow */\n};\ntypedef struct MortChain                MortChain;\nstruct MortTable {\n  Fixed               version;\n  UInt32              nChains;\n  MortChain           chains[1];\n};\ntypedef struct MortTable                MortTable;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'morx' (version 2 and beyond metamorphosis tables) */\n/* CONSTANTS */\nenum {\n  kMORXTag                      = 0x6D6F7278, /* 'morx' */\n  kMORXCurrentVersion           = 0x00020000, /* version number for current 'morx' table */\n                                        /* Coverage masks */\n  kMORXCoverVertical            = (long)0x80000000,\n  kMORXCoverDescending          = 0x40000000,\n  kMORXCoverIgnoreVertical      = 0x20000000,\n  kMORXCoverTypeMask            = 0x000000FF\n};\n\n/* TYPES */\nstruct MorxRearrangementSubtable {\n  STXHeader           header;\n};\ntypedef struct MorxRearrangementSubtable MorxRearrangementSubtable;\nstruct MorxContextualSubtable {\n  STXHeader           header;\n  UInt32              substitutionTableOffset;\n};\ntypedef struct MorxContextualSubtable   MorxContextualSubtable;\nstruct MorxLigatureSubtable {\n  STXHeader           header;\n  UInt32              ligatureActionTableOffset;\n  UInt32              componentTableOffset;\n  UInt32              ligatureTableOffset;\n};\ntypedef struct MorxLigatureSubtable     MorxLigatureSubtable;\nstruct MorxInsertionSubtable {\n  STXHeader           header;\n  UInt32              insertionGlyphTableOffset;\n};\ntypedef struct MorxInsertionSubtable    MorxInsertionSubtable;\nunion MorxSpecificSubtable {\n  MorxRearrangementSubtable  rearrangement;\n  MorxContextualSubtable  contextual;\n  MorxLigatureSubtable  ligature;\n  MortSwashSubtable   swash;\n  MorxInsertionSubtable  insertion;\n};\ntypedef union MorxSpecificSubtable      MorxSpecificSubtable;\nstruct MorxSubtable {\n  UInt32              length;\n  UInt32              coverage;\n  MortSubtableMaskFlags  flags;\n  MorxSpecificSubtable  u;\n};\ntypedef struct MorxSubtable             MorxSubtable;\nstruct MorxChain {\n  MortSubtableMaskFlags  defaultFlags;        /* default flags for this chain */\n  UInt32              length;                 /* byte length of this chain */\n  UInt32              nFeatures;              /* number of feature entries */\n  UInt32              nSubtables;             /* number of subtables */\n  MortFeatureEntry    featureEntries[1];\n                                              /* the subtables follow */\n};\ntypedef struct MorxChain                MorxChain;\nstruct MorxTable {\n  Fixed               version;\n  UInt32              nChains;\n  MorxChain           chains[1];\n};\ntypedef struct MorxTable                MorxTable;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'prop' */\n/* CONSTANTS */\nenum {\n  kPROPTag                      = 0x70726F70, /* 'prop' */\n  kPROPCurrentVersion           = 0x00030000, /* current version number for 'prop' table */\n  kPROPPairOffsetShift          = 8,\n  kPROPPairOffsetSign           = 7,\n  kPROPIsFloaterMask            = 0x8000, /* glyph is floater */\n  kPROPCanHangLTMask            = 0x4000, /* glyph can hang left/top */\n  kPROPCanHangRBMask            = 0x2000, /* glyph can hang right/bottom */\n  kPROPUseRLPairMask            = 0x1000, /* if glyph lands in RL streak, use paired glyph */\n  kPROPPairOffsetMask           = 0x0F00, /* 4-bit signed offset to other pair member */\n  kPROPRightConnectMask         = 0x0080, /* glyph connects to glyph on right */\n  kPROPZeroReserved             = 0x0060, /* must be zero */\n  kPROPDirectionMask            = 0x001F /* direction bits */\n};\n\n/* These are the Unicode direction classes (plus the Special European Number class). */\nenum {\n  kPROPLDirectionClass          = 0,    /* Left-to-Right */\n  kPROPRDirectionClass          = 1,    /* Right-to-Left */\n  kPROPALDirectionClass         = 2,    /* Right-to-Left Arabic Letter */\n  kPROPENDirectionClass         = 3,    /* European Number */\n  kPROPESDirectionClass         = 4,    /* European Number Seperator */\n  kPROPETDirectionClass         = 5,    /* European Number Terminator */\n  kPROPANDirectionClass         = 6,    /* Arabic Number */\n  kPROPCSDirectionClass         = 7,    /* Common Number Seperator */\n  kPROPPSDirectionClass         = 8,    /* Paragraph Seperator (also referred to as Block Separator) */\n  kPROPSDirectionClass          = 9,    /* Segment Seperator */\n  kPROPWSDirectionClass         = 10,   /* Whitespace */\n  kPROPONDirectionClass         = 11,   /* Other Neutral */\n  kPROPSENDirectionClass        = 12,   /* Special European Number (not a Unicode class) */\n  kPROPLREDirectionClass        = 13,   /* Left-to-Right Embeding */\n  kPROPLRODirectionClass        = 14,   /* Left-to-Right Override */\n  kPROPRLEDirectionClass        = 15,   /* Right-to-Left Embeding */\n  kPROPRLODirectionClass        = 16,   /* Right-to-Left Override */\n  kPROPPDFDirectionClass        = 17,   /* Pop Directional Format */\n  kPROPNSMDirectionClass        = 18,   /* Non-Spacing Mark */\n  kPROPBNDirectionClass         = 19,   /* Boundary Neutral */\n  kPROPNumDirectionClasses      = 20    /* Number of Unicode directional types + Special European Number */\n};\n\n/* TYPES */\n\ntypedef UInt16                          PropCharProperties;\nstruct PropTable {\n  Fixed               version;\n  UInt16              format;\n  PropCharProperties  defaultProps;\n  SFNTLookupTable     lookup;\n};\ntypedef struct PropTable                PropTable;\nstruct PropLookupSegment {\n  UInt16              lastGlyph;\n  UInt16              firstGlyph;\n  UInt16              value;\n};\ntypedef struct PropLookupSegment        PropLookupSegment;\nstruct PropLookupSingle {\n  UInt16              glyph;\n  PropCharProperties  props;\n};\ntypedef struct PropLookupSingle         PropLookupSingle;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'trak' */\n/* CONSTANTS */\nenum {\n  kTRAKTag                      = 0x7472616B, /* 'trak' */\n  kTRAKCurrentVersion           = 0x00010000, /* current version number for 'trak' table */\n  kTRAKUniformFormat            = 0     /*    kTRAKPerGlyphFormat         = 2*/\n};\n\n/* TYPES */\n\ntypedef SInt16                          TrakValue;\nstruct TrakTableEntry {\n  Fixed               track;\n  UInt16              nameTableIndex;\n  UInt16              sizesOffset;            /* offset to array of TrackingValues */\n};\ntypedef struct TrakTableEntry           TrakTableEntry;\nstruct TrakTableData {\n  UInt16              nTracks;\n  UInt16              nSizes;\n  UInt32              sizeTableOffset;\n  TrakTableEntry      trakTable[1];\n};\ntypedef struct TrakTableData            TrakTableData;\nstruct TrakTable {\n  Fixed               version;\n  UInt16              format;\n  UInt16              horizOffset;\n  UInt16              vertOffset;\n};\ntypedef struct TrakTable                TrakTable;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'kern' */\n/* CONSTANTS */\nenum {\n  kKERNTag                      = 0x6B65726E, /* 'kern' */\n  kKERNCurrentVersion           = 0x00010000,\n  kKERNVertical                 = 0x8000, /* set if this table has vertical kerning information */\n  kKERNResetCrossStream         = 0x8000, /* this value in a cross-stream table means reset to zero */\n  kKERNCrossStream              = 0x4000, /* set if this table contains cross-stream kerning values */\n  kKERNVariation                = 0x2000, /* set if this table contains variation kerning values */\n  kKERNUnusedBits               = 0x1F00, /* UNUSED, MUST BE ZERO */\n  kKERNFormatMask               = 0x00FF /* format of this subtable */\n};\n\nenum {\n  kKERNOrderedList              = 0,    /* ordered list of kerning pairs */\n  kKERNStateTable               = 1,    /* state table for n-way contextual kerning */\n  kKERNSimpleArray              = 2,    /* simple n X m array of kerning values */\n  kKERNIndexArray               = 3     /* modifed version of SimpleArray */\n};\n\n/* Message Type Flags */\nenum {\n  kKERNLineStart                = 0x00000001, /* Array of glyphs starts a line */\n  kKERNLineEndKerning           = 0x00000002, /* Array of glyphs ends a line */\n  kKERNNoCrossKerning           = 0x00000004, /* Prohibit cross kerning */\n  kKERNNotesRequested           = 0x00000008, /* Caller wants kerning notes */\n  kKERNNoStakeNote              = 1,    /* Indicates a glyph was involved in a kerning pair/group */\n  kKERNCrossStreamResetNote     = 2,    /* Indicates a return-to-baseline in cross-stream kerning */\n  kKERNNotApplied               = 0x00000001 /* All kerning values were zero, kerning call had no effect */\n};\n\n/* TYPES */\n\ntypedef UInt8                           KernTableFormat;\ntypedef UInt16                          KernSubtableInfo;\ntypedef SInt16                          KernKerningValue;\ntypedef UInt16                          KernArrayOffset;\n/* header for version 0 kerning table */\nstruct KernVersion0Header {\n  UInt16              version;                /* font version number (will be 0!) */\n  UInt16              nTables;                /* number of subtables present */\n  UInt16              firstSubtable[1];       /* first subtable starts here */\n};\ntypedef struct KernVersion0Header       KernVersion0Header;\n/* Header for a kerning table */\nstruct KernTableHeader {\n  Fixed               version;                /* font version number (currently 1.0) */\n  SInt32              nTables;                /* number of subtables present */\n  UInt16              firstSubtable[1];       /* first subtable starts here */\n};\ntypedef struct KernTableHeader          KernTableHeader;\ntypedef KernTableHeader *               KernTableHeaderPtr;\ntypedef KernTableHeaderPtr *            KernTableHeaderHandle;\n/*\n    F O R M A T   S P E C I F I C   D E F I N I T I O N S\n\n    kernOrderedList:\n    \n    The table is a sorted list of [left glyph, right glyph, value] triples.\n    There's enough information in the header so that the list can be\n    efficiently binary searched. \n*/\n/* defines a single kerning pair of Glyphcodes  */\nstruct KernKerningPair {\n  UInt16              left;\n  UInt16              right;\n};\ntypedef struct KernKerningPair          KernKerningPair;\n/* a single list entry */\nstruct KernOrderedListEntry {\n  KernKerningPair     pair;                   /* the kerning pair */\n  KernKerningValue    value;                  /* the kerning value for the above pair */\n};\ntypedef struct KernOrderedListEntry     KernOrderedListEntry;\ntypedef KernOrderedListEntry *          KernOrderedListEntryPtr;\n/* the header information for binary searching the list */\nstruct KernOrderedListHeader {\n  UInt16              nPairs;                 /* number of kerning pairs in table */\n  UInt16              searchRange;            /* (largest power of two <= nPairs) * entry size */\n  UInt16              entrySelector;          /* log2 (largest power of two <= nPairs) */\n  UInt16              rangeShift;             /* (nPairs - largest power of two <= nPairs) * entry size */\n  UInt16              table[1];               /* entries are first glyph, second glyph, and value */\n};\ntypedef struct KernOrderedListHeader    KernOrderedListHeader;\n/* KernStateTable: like the the generic state tables */\nstruct KernStateHeader {\n  STHeader            header;                 /* state table header */\n  UInt16              valueTable;             /* offset to kerning value table */\n  UInt8               firstTable[1];          /* first table starts here */\n};\ntypedef struct KernStateHeader          KernStateHeader;\nstruct KernStateEntry {\n  UInt16              newState;\n  UInt16              flags;                  /* flags per above enum */\n};\ntypedef struct KernStateEntry           KernStateEntry;\n/*\n    Kern offset table header.\n    The offset table is a trimmed array from firstGlyph to limitGlyph.\n    Glyphs outside of this range should get zero for right-hand glyphs\n    and the offset of the beginning of the kerning array for left-hand glyphs.\n*/\nstruct KernOffsetTable {\n  UInt16              firstGlyph;             /* first glyph in class range */\n  UInt16              nGlyphs;                /* number of glyphs in class range */\n  KernArrayOffset     offsetTable[1];         /* offset table starts here */\n};\ntypedef struct KernOffsetTable          KernOffsetTable;\ntypedef KernOffsetTable *               KernOffsetTablePtr;\n/* Header information for accessing offset tables and kerning array */\n/*\n    KernSimpleArray:\n    \n    The array is an nXm array of kenring values. Each row in the array\n    represents one left-hand glyph, and each column one right-hand glyph.\n    The zeroth row and column always represent glyphs that are out of bounds\n    and will always contain zero.\n    \n    A pair is looked up by indexing the left-hand glyph through the left\n    offset table, the right-hand glyph through the right offset table,\n    adding both offsets to the starting address of the kerning array,\n    and fetching the kerning value pointed to.\n*/\n/* Kern offset table header. */\n/* The offset table is a trimmed array from firstGlyph to limitGlyph. */\n/* Glyphs outside of this range should get zero for right-hand glyphs */\n/* and the offset of the beginning of the kerning array for left- */\n/* hand glyphs. */\nstruct KernSimpleArrayHeader {\n  UInt16              rowWidth;               /* width, in bytes, of a row in the table */\n  UInt16              leftOffsetTable;        /* offset to left-hand offset table */\n  UInt16              rightOffsetTable;       /* offset to right-hand offset table */\n  KernArrayOffset     theArray;               /* offset to start of kerning array */\n  UInt16              firstTable[1];          /* first offset table starts here... */\n};\ntypedef struct KernSimpleArrayHeader    KernSimpleArrayHeader;\n/* Index Array */\nstruct KernIndexArrayHeader {\n  UInt16              glyphCount;\n  UInt8               kernValueCount;\n  UInt8               leftClassCount;\n  UInt8               rightClassCount;\n  UInt8               flags;                  /* set to 0 for now */\n  SInt16              kernValue[1];           /* actual kerning values reference by index in kernIndex */\n  UInt8               leftClass[1];           /* maps left glyph to offset into kern index */\n  UInt8               rightClass[1];          /* maps right glyph to offset into kern index */\n  UInt8               kernIndex[1];           /* contains indicies into kernValue */\n};\ntypedef struct KernIndexArrayHeader     KernIndexArrayHeader;\n/* format specific part of subtable header */\nunion KernFormatSpecificHeader {\n  KernOrderedListHeader  orderedList;\n  KernStateHeader     stateTable;\n  KernSimpleArrayHeader  simpleArray;\n  KernIndexArrayHeader  indexArray;\n};\ntypedef union KernFormatSpecificHeader  KernFormatSpecificHeader;\n/* version 0 subtable header */\nstruct KernVersion0SubtableHeader {\n  UInt16              version;                /* kerning table version number */\n  UInt16              length;                 /* length in bytes (including this header) */\n  KernSubtableInfo    stInfo;                 /* sub-table info */\n  KernFormatSpecificHeader  fsHeader;         /* format specific sub-header */\n};\ntypedef struct KernVersion0SubtableHeader KernVersion0SubtableHeader;\n/* Overall Subtable header format */\nstruct KernSubtableHeader {\n  SInt32              length;                 /* length in bytes (including this header) */\n  KernSubtableInfo    stInfo;                 /* subtable info */\n  SInt16              tupleIndex;             /* tuple index for variation subtables */\n  KernFormatSpecificHeader  fsHeader;         /* format specific sub-header */\n};\ntypedef struct KernSubtableHeader       KernSubtableHeader;\ntypedef KernSubtableHeader *            KernSubtableHeaderPtr;\n/* --------------------------------------------------------------------------- */\n/* FORMATS FOR TABLE: 'bsln' */\n/* CONSTANTS */\nenum {\n  kBSLNTag                      = 0x62736C6E, /* 'bsln' */\n  kBSLNCurrentVersion           = 0x00010000, /* current version number for 'bsln' table */\n  kBSLNDistanceFormatNoMap      = 0,\n  kBSLNDistanceFormatWithMap    = 1,\n  kBSLNControlPointFormatNoMap  = 2,\n  kBSLNControlPointFormatWithMap = 3\n};\n\n/* Baseline classes and constants */\nenum {\n  kBSLNRomanBaseline            = 0,\n  kBSLNIdeographicCenterBaseline = 1,\n  kBSLNIdeographicLowBaseline   = 2,\n  kBSLNHangingBaseline          = 3,\n  kBSLNMathBaseline             = 4,\n  kBSLNLastBaseline             = 31,\n  kBSLNNumBaselineClasses       = kBSLNLastBaseline + 1,\n  kBSLNNoBaselineOverride       = 255\n};\n\n/* TYPES */\ntypedef UInt32                          BslnBaselineClass;\n/* The BslnBaselineRecord array defines the baseline deltas for the line. */\ntypedef Fixed                           BslnBaselineRecord[32];\n/*\n    BslnFormat0Part is the format-specific data for a distance table with no mapping (i.e.\n    all the glyphs belong to the defaultBaseline).\n*/\nstruct BslnFormat0Part {\n  SInt16              deltas[32];\n};\ntypedef struct BslnFormat0Part          BslnFormat0Part;\n/* BslnFormat1Part is the format-specific data for a distance table with a gxMapping. */\nstruct BslnFormat1Part {\n  SInt16              deltas[32];\n  SFNTLookupTable     mappingData;\n};\ntypedef struct BslnFormat1Part          BslnFormat1Part;\n/*\n    BslnFormat2Part is the format-specific data for a control-point table with no\n    mapping (i.e. all the glyphs belong to the defaultBaseline). It specifies a single\n    glyph to use and the set of control points in that glyph that designate each of\n    the baselines.\n*/\nstruct BslnFormat2Part {\n  UInt16              stdGlyph;\n  SInt16              ctlPoints[32];\n};\ntypedef struct BslnFormat2Part          BslnFormat2Part;\n/*\n    BslnFormat3Part is the format-specific data for a distance table with a mapping. Like\n    format 2, it contains a single glyph and its set of control-point values for each\n    of the baselines.\n*/\nstruct BslnFormat3Part {\n  UInt16              stdGlyph;\n  SInt16              ctlPoints[32];\n  SFNTLookupTable     mappingData;\n};\ntypedef struct BslnFormat3Part          BslnFormat3Part;\n/* The BslnFormatUnion is a union containing the format-specific parts of the baseline table. */\nunion BslnFormatUnion {\n  BslnFormat0Part     fmt0Part;\n  BslnFormat1Part     fmt1Part;\n  BslnFormat2Part     fmt2Part;\n  BslnFormat3Part     fmt3Part;\n};\ntypedef union BslnFormatUnion           BslnFormatUnion;\n/* The table format used in BaselineTable */\n\ntypedef UInt16                          BslnTableFormat;\n/* BaselineTable defines the top-level format of the baseline table in the font. */\nstruct BslnTable {\n  Fixed               version;\n  BslnTableFormat     format;\n  UInt16              defaultBaseline;\n  BslnFormatUnion     parts;\n};\ntypedef struct BslnTable                BslnTable;\ntypedef BslnTable *                     BslnTablePtr;\n/* --------------------------------------------------------------------------- */\n\n#if PRAGMA_STRUCT_ALIGN\n    #pragma options align=reset\n#elif PRAGMA_STRUCT_PACKPUSH\n    #pragma pack(pop)\n#elif PRAGMA_STRUCT_PACK\n    #pragma pack()\n#endif\n\n#ifdef PRAGMA_IMPORT_OFF\n#pragma import off\n#elif PRAGMA_IMPORT\n#pragma import reset\n#endif\n\n\n#endif /* __SFNTLAYOUTTYPES__ */\n\n"
}