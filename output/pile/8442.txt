{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": true,
            "reason": "Text contains Markdown."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": true,
            "reason": "Text contains ['-', '-', '-', '-', '*', '*', '*', '-', '-', '-', '-', '-', '-', '-', '-', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '9', '-', '-', '-', '-', '-', '-', '-', '-', '1', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-']."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['linked from the parent shows, we have a lot of promise-based details remaining (0.192)', 'discussion and the examples people are linking to. (0.191)', 'of the community and lack of agreement on things which are well-decided in (0.196)', 'From reading the comments there are Still a lot of misconceptions about Js. (0.197)', \"While some of the complaints are valid, it's not (0.196)\"]."
        }
    ],
    "doc_id": "8442",
    "text": "\nAfter a year of using Node.js in production - 0xmohit\nhttp://geekforbrains.com/post/after-a-year-of-nodejs-in-production\n======\nplacebo\nI usually don't respond to anything which I feel is just another \"language\nwar\" provocation, but whenever I see these type of reviews I'm mystified. I've\ndeveloped in many languages and frameworks, both well known and lesser known -\ndecades of client and server side of C/C++, Javascript, Lua, Java, Python,\nPHP, Perl, Lisp. Pascal (just to name a few) in projects of all sizes, and not\nonce did I have the thought \"this language sucks\". I think there are a few\nreasons for this: 1) Even after all these years, I'm still passionate and\nexcited at the ability to sculpt logic, regardless of the \"material\" I need to\nuse. 2) A \"keep it simple\" approach - no way to overemphasise this. Know the\nadvantages and limitations of the language and stick to what works. Keeping\nthings simple should be like a fractal - existing at all levels of\nabstraction. 3) I'm very wary of hype. New, shiny and trendy does not\nnecessarily mean better, especially when the hype is in conflict with keeping\nthings simple. I find that when you understand the playing field, mark the\nareas to avoid and keep things as simple as possible, the elegance of the\ndesign and implementation usually makes the advantage of language X over Y\ninsignificant, and I feel that blaming failure on the language used is like\nblaming a bad novel on the word processor used to write it.\n\n~~~\nastrobe_\n> I feel that blaming failure on the language used is like blaming a bad novel\n> on the word processor used to write it.\n\nSure. If you're a good novelist you can write something great even on a\nkeyboard with a broken 'e' key (btw, your 'I' key is about to break; you\nshould replace it asap).\n\nBut novelists don't have deadlines and when the novel is done, they usually\ndon't take reader requests to change this or that part of the story.\n\n\"The advantages and limitations\", what works and what doesn't, \"areas to\navoid\" are precisely the point of that kind of review.\n\n~~~\nplacebo\n> (btw, your 'I' key is about to break; you should replace it asap).\n\nhaha - touch\u00e9, point taken :-)\n\nDeadlines seem like a great excuse for compromising quality. Sure, life is\ncomplicated, the boss is demanding, the mortgage has to be paid, the children\nneed to be supported etc. etc. but compromising quality and enthusiasm (they\nusually are correlated) because of the \"terror\" of a deadline will just leave\nyou at the mercy of the next \"terror\", only this time you'll even have even\nless enthusiasm to fix the spaghetti. Doesn't sound like an enjoyable\nexistence.\n\nOf course, very few people have the privilege of never having to compromise,\nbut it's never black or white and there are many more degrees of freedom to\nchoose the path with more quality than are implied.\n\n>\"The advantages and limitations\", what works and what doesn't, \"areas to\navoid\" are precisely the point of that kind of review.\n\nThe \"area to avoid\" in the review is Node.js and considering that large and\nimpressive projects have been written in it, it seems that this is another\ncase of throwing the baby out with the bathwater.\n\n------\nbeders\nNow all of a sudden, having types and some standards to gather around doesn't\nsound like a bad idea anymore ;)\n\nI agree with one of the commenters: Lessons already learned by older engineers\n(who went through similar woes with other languages/tools) are being re-\nlearned again and again.\n\nThe software industry is in a sorry state.\n\nUnless you are a very disciplined team with a very strong sense of writing\nmodular code, don't use Node.js for any larger project. And even then, the\nsingle-most useful function in an IDE 'Show Call Hierarchy' will never be\navailable when using a dynamically typed language.\n\nThat is not an issue for smaller projects. However, long before you even get\nclose to the the million lines of code project size, your tools will fail you.\nYour debugging/refactoring times will explode and adding a new feature will\nseem unsurmountable.\n\nInstead, let's just re-write everything from scratch because the cool hipster\nthat wrote your backend a year ago has left for greener pastures...\n\nI won't even try to guess the amount of technical debt produced with Node.js\nand the likes each day in the bay area.\n\nAnd, yes, I just used Node.js to write a Slack-bot. It was fun, took me two\nhours and got me up and running quickly. That's the beauty of it. Just be\naware of the dangers.\n\n~~~\nencoderer\nI've worked in three million+ loc codebases, in PHP, Python and Java. I don't\nshare your opinion that you need static types in these circumstances. You need\ndiscipline, modularity, and most importantly you need to have been blessed\nwith gardeners and maintainers throughout the life of a project and not just\nafter a mess has already taken hold.\n\n~~~\nbeders\nDid you read what I wrote? I already said that you need a disciplined team.\nGood luck keeping that team together for years to come. Not sure if you are\ndisputing the fact that keeping code around is a challenge, or not.\n\n------\ntylerlh\nThe Netflix.com site and webapp runs on Node (and talks to a number of\nservices written in mostly JVM based languages). While we encounter challenges\njust as we would with any other language -- it works for us and I would argue\nthat it's a pretty big application.\n\nThere's always a multitude of ways to get something done, and it's up to you\nto decide what tool will do it best. Don't treat any one language as an end-\nall-be-all and you might find yourself much happier and more productive. Of\ncourse, YMMV.\n\n~~~\nChrisAntaki\n> There's always a multitude of ways to get something done, and it's up to you\n> to decide what tool will do it best\n\nWell said.\n\nBy the way, what is Netflix's take on Promises vs RxJS?\n\n~~~\nZoeZoeBee\nI'm pretty sure Netflix is in the Observables camp, as Ben Lesh over at\nNetflix is RxJs\n\n~~~\nAkkuma\nI watched one of the recent Netflix engineering videos where they moved to a\ncustomized version of React and I could have sworn in that talk they actually\nmoved away from Observables[1]. What was confusing is that the other talked\nreleased at the same time they talk about enhancing RxJS.\n\n[1]:\n[https://youtu.be/5sETJs2_jwo?t=5m32s](https://youtu.be/5sETJs2_jwo?t=5m32s)\n\n~~~\nmikeryan\nA friend of mine runs some UI engineering at Netflix from talking to him\nreactive JavaScript is still heavily used.\n\n~~~\nAkkuma\nI'm sure it is still heavily used, but it looks like there are two very\nopposing views with one going so far as completely removing it.\n\n------\njoshmanders\nThese types of articles make me laugh. Typically a dev with many many years\nexperience with one language, learned all it's quirks, standards, etc decides\nto try Node.js because it's the \"new hot fun toy\", and expect it to work like\ntheir old language, and realize that is not how it works, doesn't know where\nto find what and fails real hard to realize that JavaScript in general is in a\nhuge influx of updating at this moment, which by nature propagates to Node.js.\n\nThe end result is they get frustrated and go back to their old language.\n\n~~~\neva1984\nYeah, so some js devs might need to stop overselling javascript to everyone,\npretending it is the one language that people are waiting for years...Just\nsaying.\n\n~~~\njoshmanders\nYou should try to surround yourself with developers who don't have such\nattitudes. I am a fan of JavaScript, I love Node.js and I will often times\nsuggest it to newbies. But I don't pretend it's the be all/end all of\nlanguages. Just like any other language it has its strengths and weaknesses.\nIt's up to you to decide if it's the right choice for you.\n\n~~~\nuptownJimmy\nIt is one of my most cherished professional goals to avoid ever working with\npeople who think like this. The message this sends to junior devs is so\nbackwards and wrong-headed that it defies discourse.\n\n~~~\njackweirdy\nWhy? It seems like a reasonable statement - surround yourself with people who\nthink critically, not evangelically?\n\n~~~\nuptownJimmy\nBut I see your point as being precisely backwards: it's the JS crew who\nconstantly evangelize for their way of doing things, and that way of doing\nthings is completely inappropriate for anyone who isn't already expert.\n\n\"Choose your own tools\" is advice for experts, and literally nobody else. It\nsmacks of the cowboy attitude, and that attitude is wildly unhelpful to almost\nanybody doing professional work in software. Frameworks and coding standards\nexist for a reason: not to be unreasonable strictures, but to provide guidance\nand sanity in a staggeringly complex field of endeavor.\n\nMany new devs and junior devs are flocking to the JavaScript ecosystem, and it\nis one of the most troubled and chaotic ecosystems in all of software right\nnow. Anyone who is not a complete JS badass is simply not going to find Node\nto be even a decent choice for learning best practices pertaining to the\nlarger world of application development. And I feel I'm stating that politely.\n\nSo: yet another JavaScript Pro tossing out the \"choose your tools like a Pro\"\nadvice-morsel is part of the problem, as I see it. I don't want to work with\npeople who toss the kids into the deep end and hope a few can learn to swim\nreal quick. I think people deserve a helping hand and a reasonable set of\nexpectations.\n\nThe JavaScript ecosystem has become self-parodying. Anyone who is oblivious to\nthat fact is inherently NOT a trustworthy witness. That is not to say that the\nwhole thing is rotten and worthless, but it IS messy as heck, and refusing to\nacknowledge that is a sign that one is in denial about some pretty blatant\nfacts.\n\n------\nspion\n> Coming from other languages such as Python, Ruby or PHP you\u2019d expect\n> throwing and catching errors, or even returning an error from a function\n> would be a straightforward way of handling errors. Not so with Node.\n> Instead, you get to pass your errors around in your callbacks (or promises)\n> - thats right, no throwing of exceptions.\n\nPromises let you throw errors normally. They will propagate up the call stack\nin a similar manner. With bluebird, you will also get full stack traces in\ndevelopment mode and the performance penalty for that isn't too bad.\n\n> The last thing that I found frustrating was the lack of standards. Everyone\n> seems to have their own idea of how the above points should be handled.\n> Callbacks? Promises? Error handling? Build scripts?\n\nPromises are in ES6 (i don't think it gets more standard than that) and have\nwell defined semantics, including error handling, shared between libraries:\n[https://promisesaplus.com/](https://promisesaplus.com/)\n\nI know that Bluebird's promisifyAll might seem like a bit of a hack, but just\ntry it out. It works surprisingly well, and its really painstaikingly tuned\nfor near-zero performance loss. It will probably be both less painful to do\nand more performant than any manual attempt to wrap a callback based API into\na promise one.\n\n~~~\npjungwir\nI gave a talk about handling errors in Node a few years ago:\n\n[https://github.com/pjungwir/node-errors-\ntalk](https://github.com/pjungwir/node-errors-talk)\n\nAt the time the solution was \"use domains\", but I think domains are deprecated\nnow. It was painful enough that I have stuck with Rails since then. I'm glad\nto hear that Promises are an improvement!\n\n~~~\nkoolba\nDomains have been deprecated since at least 0.10. As of yet there's no\nreplacement for them and all node apps should be using them. There's no other\nway to catch \" _But ... but ... that can 't happen!_\" type errors.\n\n~~~\nspion\nThere is no replacement because they're a fundamentally broken idea. They\nrequire the following to happen, in that order:\n\n* V8 needs to optimize try-finally\n\n* Node core needs to add try-finally at every single place where callbacks are invoked and make sure all state and resource cleanup is properly done to support domains\n\n* Popular libraries need to also add try-finally handlers for the above.\n\nAs to why this is a problem in node and not so much in other languages, its\nbecause with node callbacks, the call stack goes both ways. In other\nlanguages, libraries mostly call their dependencies' code. In node's CPS\nstyle, you call the library but the library also calls your closure code. The\nsemantics for the 2nd part aren't well defined in node - the loose law\nbasically says: I wont call you twice, I'll try not to call you synchronously,\nand you wont throw (and if you do the behavior is undefined).\n\nWith promises there is a contract and its enforced by the promise\nimplementation. Since Promises actually have error semantics, you can build\nresource management strategies on top of them. [http://promise-\nnuggets.github.io/articles/21-context-manager...](http://promise-\nnuggets.github.io/articles/21-context-managers-transactions.html) \\- and\nconsequently there is no reason to crash your server on errors.\n\n~~~\nlobster_johnson\nDomains are used for another reason: To emulate thread-local variables. I hope\nthat support is not going away, because it's really handy.\n\n~~~\nspion\nIts interesting that the same problem (TLS) can also be solved with something\nsimilar to promises :)\n\n------\nCorrado\nI agree with this article and find the Node.js community, and to a lesser\nextent Javascript itself, exhausting. It seems like every 2 minutes there is a\n\"more\" proper way to do something, which tells me that the architecture is not\nyet mature, even though it's pretty old by now.\n\nOn a related note, it seems like every time you find something that doesn't\nquite work correctly or conveniently in Node.js there is a \"fix\". Don't like\ncallbacks? Force Node.js to look more like other \"normal\" code and use\nPromises. Having trouble getting Node.js to concentrate on one thing at a\ntime? Force Node.js to look more like other \"normal\" languages and use the\n\"async\" library. And it just goes on and on and on. If I have to use all of\nthese other pieces and parts to be productive in Node.js I may as well just\nuse some other language.\n\nI really wanted to like and use Node.js, but Javascript and the community are\nholding it back.\n\n~~~\neagsalazar2\nYes, the Javascript world is quickly evolving both on the front end and\nbackend, and of course that can be exhausting but I have to disagree with both\nconclusions that (a) this means the tech is immature, and (b) the community's\nreadiness to make changes is \"holding it back\".\n\nThe js world is very unique in its ability to evolve quickly and things have\nimproved _massively_ over the last few years. Now, apart from the churn itself\nand precisely because of that rapid evolution, front end and backend\ndevelopment in javascript is amazing compared to most other options\n(especially on the front end). So while you do have to be realistic about the\ncost of the evolving ecosystem, it is just a tradeoff for rapid progress, not\na flaw.\n\nIf you crave stability, agreed, this rollercoaster probably isn't your ride.\nBut the evolution of node, the emergence of react/redux, es6, etc is amazing\nand beautiful IMO and I'm totally enjoying every bit of it compared to the\nstaid mediocrity of my Rails, C/C++, and Java history.\n\n~~~\nrimantas\nThe problem I see that in this case \"evolving\" looks suspiciously like running\nin circles without going anywhere.\n\n~~~\nroyjacobs\nA good example mentioned in the article is the \"npm scripts -> grunt -> gulp\n-> npm scripts\" evolution in best practices for building.\n\n------\nprogrammarchy\nNever had the problems with Node described in the article. Node forces\nthinking about modularity and composition though, which I'd wager is what the\nauthor is actually struggling with. Write functions that do one thing and\nthey're pretty easy to compose, even if they're asynchronous. It's really not\nhard to debug what went wrong in the stack trace when you name your functions.\n\nAnd I think exception handling is much worse than passing errors up through\ncallbacks. It forces you to think about edge cases. Not sure how python\nhandles this, but I can't tell you how many times I've seen Java or C# code\nswallow exceptions which is much harder to debug IMO.\n\nPeople really seem to have a problem with there not being \"the one true path\"\nin Javascript, but it's not something that gives me much anxiety. Javascript\nis incredibly moldable, which is part of what makes it so powerful.\n\n------\neknkc\nTLDR;\n\nAuthor actually wants to use Python. Used Node.JS regardless, for whatever\nreason.. It did not work the way Python works. Author is frustrated. Complains\nthat JavaScript is not Python.\n\n~~~\nfredrb\nThis. You can't apply some other language paradigms in every programming\nlanguage just because it's the only thing you know how to do.\n\n------\nWintamute\n> You use Grunt!? Everyone uses Gulp!? Wait no, use native NPM scripts!\n\nAlthough couched as a criticism this is actually the community fixing itself.\nThe evolution from Grunt > Gulp > npm scripts is movement away from needless\ncomplexity towards simplicity. Npm scripts are effectively just Bash commands\nthat build and manage your project, which sometimes employ small, unixy tools\nwritten in Node.\n\nThis self correction was pretty quick, it happened within a few years.\n\n> Unfortunately, there isn\u2019t any one \u201cstandard\u201d (like everything else in\n> Javascript) for implementing or using Promises.\n\nYes there is. It's called the Promises/A+ spec, and its built into ES6.\n\n~~~\nTouche\nNPM scripts are just a different problem. See:\n\n[https://twitter.com/sindresorhus/status/724259780676575232?l...](https://twitter.com/sindresorhus/status/724259780676575232?lang=en)\n\n[https://github.com/ReactiveX/rxjs/blob/a3ec89605a24a6f54e577...](https://github.com/ReactiveX/rxjs/blob/a3ec89605a24a6f54e577d21773dad11f22fdb14/package.json#L14-L96)\n\nAlready people are coming up with new \"solutions\" to this problem that looks\nmore like Grunt. It's a repetitive circle. Personally I just use Make.\n\n~~~\nWintamute\nSo somebody found a project somewhere on the internet with an exceptionally\ncomplicated build process, and you use it to say npm scripts are broken?\nSorry, that's absurd. Looking at that particular build process, I don't think\na Makefile could have been crafted to make it much simpler or smaller. In that\nexample, the problem lies with the complexity of what they're having to do,\nnot the tool.\n\nNpm scripts are really just shell scripting, which means all the real progress\nhappens in the unixy Node tools that do the heavy lifting, where it should be.\nIt's a future proof and scalable approach for the vast majority of projects\nimo.\n\n~~~\nTouche\nIt's an inflated example of what all npm script projects become, imo. First\nyou just have \"test\", then you add \"build\", then you separate your \"test\" into\none for the browser, one for Node, one for CI, then you need scripts that\ncombine those together; then you create different \"start\" versions depending\non environment... It blows up quickly.\n\n> Npm scripts are really just shell scripting, which means all the real\n> progress happens in the unixy Node tools that do the heavy lifting, where it\n> should be.\n\nThat's fine, but you're missing critical features that Make provides; make\nwon't even rebuild a target if no files have changed.\n\n~~~\nWintamute\nAdmittedly, my first 2 or 3 npm scripts based build processes did start to get\na bit ugly. But I'm much better at writing them now, so they stay pretty sane.\n\n> That's fine, but you're missing critical features that Make provides; make\n> won't even rebuild a target if no files have changed.\n\nWebPack does this for me too. Also my ava tests don't rerun for files that\nhaven't changed while watching.\n\nGenuinely curious, what scenarios precisely do you find this feature of Make\nuseful?\n\nAlso, Make isn't truly cross platform ... and since I sometimes work with\nWindows devs this would be a problem.\n\n------\nkcorbitt\nI've spent a lot of time writing Javascript on the front-end in the last year\nusing both React and React Native. I've found the React ecosystem to be a\nsane, productive and enjoyable development environment.\n\nInterested in sharing more model logic between our front- and backends, I also\ninvestigated writing some new backend features using Node (we're currently\ndeveloping with Rails). But after days of research and playing around with the\navailable options, I came to a conclusion similar to Gavin's -- any reasonably\ncomplex backend requires you to either roll your own everything, or try to\ncobble together literally hundreds of tiny dependencies that weren't built to\ngo together, and then somehow keep track of all of their regressions and\nbreaking changes.\n\nNode's fantastic performance and unique ability to share logic between client\nand server are enticing, but I just don't trust the community and \"best\npractices\" around it enough to bet the farm on it for now.\n\n~~~\nwrong_variable\nThe same problems you cite for node.js are the reasons why a lot of devs love\nnode.js.\n\nIts much easier to do your own research and find the best module to solve a\nparticular problem you are having then to shoehorn into some larger monolithic\nframework.\n\nAlso its a lot more fundamental then that - Node.js has prolly the fastest\niteration cycle for any platform out there since its so easy to create your\nown module - it leads to some sort of Cambrian explosion of innovation and\nexperimentation.\n\nEDIT:\n\nAlso OP seems to think callback hell and async programming is bad. The\nimportant thing is those things are problems for python/.... too !\n\nIts just that python doesn't have a good programming model to even begin to\naddress those concerns.\n\nJavaScript at-least tries to say - \"hey this is a problem we need to deal with\n- concurrency is a issues we all face \"\n\nSo when devs complain about callback hell - its just that they have never\ntried to use python to do async in a neat way.\n\n~~~\nempthought\n> python doesn't have a good programming model to even begin to address those\n> concerns\n\nThis isn't even close to true. Anything JavaScript has to express logic in the\nface of asynchrony, Python has too. There are a half-dozen asynchronous web\nservers written in Python.\n\nThere's not as much of a culture of writing APIs that way in Python because\nit's generally a terrible way to program, and threads/OS processes are good\nenough for basically everything except HTTP servers with absurd numbers of\nconcurrent connections.\n\n~~~\nwrong_variable\n> There's not as much of a culture of writing APIs that way in Python because\n> it's generally a terrible way to program\n\nI would love to see evidence for you making that statement. Almost every\nprogrammer would put out their fav programming language as the 'right' way to\nprogram.\n\n> everything except HTTP servers with absurd numbers of concurrent connection\n\nOnce you introduce async operations in your code - you need to follow the\nexecution path through. http request can be async - but then what if the http\nrequest results you doing a db lookup or some form of file handling ? you need\nto make the whole thing event driven.\n\n~~~\nempthought\nIt's not like we didn't have cooperative multitasking for 50 years. Having\nthreads/processes and a scheduler is easier and safer, full stop. Potentially\nlong-running portions of the program don't need to be arbitrarily chopped up\nto yield control back to the server, because they are pre-empted. Your system\nis no longer at the mercy of the worst code within it.\n\nBoth nginx and Apache's event MPM handle HTTP connections with events while\nthe app backends are still using preemptive threads for running the HTTP\nhandler code, so it's clearly not the case that \"you need to make the whole\nthing event driven.\" You just need programmers who don't think, \"well since\nthe browser doesn't expose threads to JavaScript programmers, clearly they are\nuseless.\"\n\n------\nnarrator\nI'm using NodeJS on a pretty big project.\n\nThings I like:\n\n* Async libraries make it easy to make things high performance.\n\n* I like Sequelize as an ORM, once I figured out how the async everything works.\n\n* The testing support is pretty good, both mocha and e2e testing using selenium\n\n* The angular-fullstack generator was really helpful for getting started and setting up the deploy to Heroku.\n\n* everything is open source. If I get confused with what a library is doing while I'm debugging I can just stick a print in the lib temporarily.\n\nThings I don't like:\n\n* \"undefined is not a function\". When something goes wrong. This is the error I get 80% of the time.\n\n* async stuff silently swallows exceptions unless I put try{} catch(err) { console.trace(err) } everywhere\n\n* There's a bit of a learning curve with promises.\n\n* Needs a lot more automated testing than a really strongly typed language like Scala.\n\n* Single Threaded. I know how to program using threads, so I view this as a disadvantage.\n\n* No types. I have a lot of type checking asserts at the beginning of dao functions.\n\nIf I did it all again and my teammates would oblige, I would have probably\nchosen Play/Scala. I actually reimplemnted things from a Play/Scala project I\ndid a while back (login/signup/forgot password/confirm account) and it took\nless time in Play/Scala, even without passportJS and friends. I have about a\nyears worth of experience learning Scala before I started that project, so it\nwould probably take longer for a new Scala developer.\n\n~~~\nrhinoceraptor\n> async stuff silently swallows exceptions unless I put try{} catch(err) {\n> console.trace(err) } everywhere\n\nHuh? That's not how async errors work in Node. Try/Catch is not async, the\ncatch block will not magically transfer to your callback function.\n\nYou check for the error as the first parameter in your callback, that's the\nstandard way of error handling. Throwing errors in Node is considered by most\nto be an anti-pattern.\n\n~~~\nnarrator\nThat's nice in theory, but third party libraries may throw exceptions if\nunexpected things happen at runtime. You'd still have to put the try catch\nblock there and call the callback in the catch block everywhere.\n\n~~~\nrhinoceraptor\nThat's only for non-async stuff, which is very rare. If you're using some\nwacky 3rd party code which throws an Error instead of the accepted convention\nof (err, response) callback arguments (or returning a promise), I suggest not\nusing it.\n\n------\nmrmondo\nWe couldn't even stand 6 months let alone a year. Broken pack depts make it\nhard to CI, poor performance, memory leaks, huge docker base images due to\ndeps, lots of single cpu only tasks that were too hard to scale out, an ugly\nlanguage compared to ruby or Python and on top of all that how poor the\npackage management with NPM has been. We've just ditched it and gone back to\nPython/Django/flask and ruby for the ops tooling.\n\n------\nsilviogutierrez\nSame experience as the author. Tons of reinventing the wheel, and hundreds of\ndependencies.\n\nThe majority of established companies that say they use Node in production are\ndoing so as a fancy proxy. All the \"serious\" stuff is done on backend services\nwritten in other languages.\n\nMoreover, asynchrony is a concept far more advanced than most people think.\n\nWe will likely continue to leverage Node as a fancy proxy. Adding Typescript\nwill only help. But it's likely that as Node grows into a mature platform,\nother platforms will continue to fill in the gaps that Node filled.\n\nSee for example Node constantly adding [foo]Sync versions of methods, while\nPython adds first class sync support.\n\n------\nfirasd\nI've been on a similar learning curve with Node over the last year, and it has\ncertainly been a rougher incline than other languages I've used.\n\nThe whole async situation needs to settle down, it's completely unacceptable\nto write code with callbacks, promises, etc. This is because they are not just\nchallenging to deal with, but intrinsically wrong in concept. I have to wait\nfor a database query to complete, then pass the next thing to do to the\ncallback of the query? That can't be right.\n\nInteresting article I found: \"Async/Await: The Hero JavaScript Deserved\"\n[https://www.twilio.com/blog/2015/10/asyncawait-the-hero-\njava...](https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-\ndeserved.html)\n\n~~~\nSilhouette\nI find that JS often seems to tie programmers in the most extraordinary knots\njust to implement even quite simple logic, because of the single-threaded\nnature of the language.\n\nIn the programming model used by most other mainstream languages today, if\nyou've got some work to do that interacts with some external system and might\ntake a while, you'd probably start another thread for that task. You'd write\nthe required logic in the usual linear fashion, and just let the thread block\nif and when it needs to. Modelling this using fork/join semantics and\ntechniques to co-ordinate access to shared resources from different threads\nare reasonably well understood ideas.\n\nBecause there is no general support for concurrency and parallelism in JS, you\nonly get one thread, and so in most cases you can't afford to ever block it.\nConsequently, you get this highly asynchronous style that feels like writing\neverything manually in continuation passing style, just so you can carry on\nwith something else instead of waiting. That in turn leads to callback hell,\nwhere you start to lose cohesion and locality in your code, even though\nusually you're still just trying to represent a simple, linear sequence of\noperations.\n\nAsync/await help to bring that cohesion and locality back by writing code in a\nstyle that is closer to the natural linear behaviour it is modelling. However,\neven those feel a bit like papering over the cracks in some cases. Async/await\nkinda sorta give us some simple fork/join semantics, but as the blog post\nlinked from the parent shows, we have a lot of promise-based details remaining\nunderneath.\n\nFundamentally, the problem seems to be that JS is increasingly being used to\ndeal with concurrent behaviours, but it lacks an execution model and language\ntools to describe that behaviour in a natural, systematic way as most other\nwidely used languages can. Being strictly single-threaded avoided all the\nsynchronisation problems in the early days, when the most you had to worry\nabout was a couple of different browser events firing close together and it\nwas helpful to know the handler for one would complete before anything else\nstarted happening. I'm not sure it's still a plus point now that we're trying\nto use JS for much more demanding concurrent systems, though.\n\n~~~\nTouche\n> Modelling this using fork/join semantics and techniques to co-ordinate\n> access to shared resources from different threads are reasonably well\n> understood ideas.\n\nWriting thread-safe code is anything but easy in languages that support\nthreads.\n\n~~~\nSilhouette\nI respectfully disagree.\n\nDealing with _shared state_ is not always easy when you're working with\nmultiple threads. If you can't reasonably avoid that sharing because of the\nnature of your problem, and if your choice of language and tools only provide\ntools on the level of manual locking, then I agree that writing correct,\nthread-safe code has its challenges.\n\nHowever, there are plenty of scenarios where you don't need much if any state\nto be shared between threads. That includes almost every example of JS\npromises or async/await that I've seen this evening while reading this\ndiscussion and the examples people are linking to.\n\nThere are also plenty of more sophisticated models for co-ordinating threads\nthat do need to interact, from message passing to software transactional\nmemory. These are hardly obscure ideas today, and I don't think anyone could\nreasonably argue that for example message passing makes things complicated but\nasync/await/promises make things simple.\n\n------\ndeedubaya\nFor all the comments on here about how unfair the author was, there sure is\nminimal feedback on the problems they highlighted.\n\n~~~\nsnappy173\nthe feedback is: stop expecting javascript to act like python\n\n~~~\ndeedubaya\nHow productive!\n\n~~~\nsnappy173\nsorry if that came off harsh, but that is actually the feedback, and it's\nvalid. whether or not javascript/node is better or worse than python, it's\npretty clear that bringing a python style approach to nodejs is going to cause\nproblems, especially with error handling and async stuff.\n\n------\nmrgalaxy\nI have used Node.js in production for about 5 years now and I must agree with\nthe sentiment that JavaScript is \"Easy to learn, impossible to master\". Yes,\nerror handling is a little confusing at first but it stems from JavaScript's\nasynchronous nature which is naturally complex for the linear mind.\n\nMy personal sentiment is to just use Promises, like everywhere. ES7\nasync/await will really help with this too.\n\n------\nclessg\nFor web applications, I've been very happy with the up-and-coming Phoenix[0],\na framework for the Elixir language.\n\nVery well-designed and thought-out, fast, productive. Leans functional and\nimmutable rather than object-oriented and mutable. It's kind of like Rails but\nwithout most of the problems.\n\n[0] [http://www.phoenixframework.org/](http://www.phoenixframework.org/)\n\n~~~\ndeedubaya\nI've found Elixir to be a delightful language with very palatable syntax\ncompared to ruby. It has been a really enjoyable transition, with some vague\nreminders of the parts I really like about JavaScript.\n\n------\nemilong\nI've been using Node in production for a few months now, having come from Ruby\n(Rails & Sinatra) immediately before, but having used JavaEE and PHP before\nthat. I find it... fine.\n\nFor error handling, bluebird's typed error catching\n([http://bluebirdjs.com/docs/api/catch.html](http://bluebirdjs.com/docs/api/catch.html))\nis working well for me and I'm finding it analogous to my experiences with\nJava and Ruby.\n\nI'm rather used to using ORMs as well and I use Bookshelf\n([http://bookshelfjs.org](http://bookshelfjs.org)) on top of Postgres for this\nas well. It definitely has room to grow, but it's also fine.\n\nI've also gained a dependency injection container (Bottle.js, see my write up\nhere: [https://blog.boldlisting.com/declarative-dependencies-for-\nun...](https://blog.boldlisting.com/declarative-dependencies-for-unit-testing-\nnode-js-services-45542ceb5703#.gaf9om7zj)), which I sorely missed in my Rails\ndays and which gives a lot of structure to the application.\n\nI think the biggest concerns on which I'd agree with the author are the pace\nof the community and lack of agreement on things which are well-decided in\nother, more well-established development environments.\n\nThat being said, there's huge potential with Node because of that. There are\nmore coders in the world than ever (I'm assuming) and Javascript is a great\nlow barrier to entry language that encourages people to explore various\nruntimes. In 20+ years of coding, I've not seen this level of excitement and\nengagement in a development environment. While it may be rocky for another few\nyears yet, I suspect we'll end up with a very productive platform, simply\nbecause of the amount of involvement. Of course, it's totally understandable\nto want to wait for that before jumping in. :)\n\nAs a relatively new Node developer, I'm much more concerned about the single-\nthreaded nature than the development environment, but so far even that hasn't\nbeen a problem.\n\n------\nTouche\nA lot of this is residual effects of the (slow) evolution of JavaScript. It\nwas thrust into the spotlight missing a lot of features and these features\nhave only recently been fixed by the language itself.\n\nBut Node has been around since 2009. 2009 JavaScript was missing _a lot_ of\nfeatures. It was basically a runtime only advanced users should use. The Node\nmaintainers had to make a lot of decisions that now conflict (to some degree)\nwith fixes that have come later to the language. They chose their callback\nstyle; now we have Promises. They chose to throw in methods rather than return\nan error in the callback (this makes it awkward to use fs with Promises\nwithout a wrapper library). They chose to implement their version of CommonJS,\nnow we have the .mjs issue arise.\n\n------\nnevi-me\nBeen on Node and Mongo for 4 years now. Both have worked well for me.\n\nJS has evolved a lot in the past few years, and with it came all the new shiny\ntools that left us confused.\n\nI think a year was too short for the author. Sounds like they were chasing\nafter every cool thing to make life easy.\n\nError handling is a pain yea, I've seen amateur folk try catch this and that,\nI think that lends itself to being terrible.\n\nOne of the things I appreciate the most about JS is JSON. Crafting tens of\nclasses in Java irritates me. I find Python sometimes tricky also when dealing\nwith structs VA lists.\n\nI've always stuck to the basics when I was learning how to JavaScript with\nNode. I used only callbacks for 2 years until I understood what my code was\ndoing. Granted, I'd have spaghetti at the end of complex async queries, but I\nunderstood what was going on. I moved to caolan::async and have been using\nasync whenever necessary. I barely use promises as I got confused by the early\nadoption craze.\n\nI learnt how to use Backbonejs, and a bit of Angular+React+Ember, but I found\nmyself comfortable using vanilla JavaScript. Only thing I use is Underscore\ntemplates. I know I could benefit from shadow DOMs etc, but I'm content where\nI am.\n\nI think a good way to learn is to take things at bite sized chunks. I've\nstarted using RxJS recently, and I'm loving it! I'll keep using JS as my\nprimary tool, but I'm slowly moving to Kotlin.\n\n------\nkartickv\nIf this article is true, it paints a concerning picture. I don't want to\nresearch libraries, understand the pros and cons of them, run into problems,\nthen switch to another library, and so on. I want there to be a default that\nworks out of the box for the majority of use cases. There can be alternatives,\nas long as there's a default that works out of the box for most people and\nmost use cases.\n\n------\neldude\nI train enterprise node.js for a living.\n\nMy recommendation is to just use songbird (which exposes the forthcoming\npromise API from core, built on bluebird), async/await and the async\n`trycatch` library so you don't have to worry about a 3rd party package's\nchoice of asynchrony. It also comes with optional long stack traces.\n\n~~~\nsnappy173\n>async/await\n\nin my experience, async/await is a great way to layer indirection and\nobfuscation over what is still callback hell. it may look better in the\neditor, but it's hell to debug.\n\n~~~\nraarts\nWhen I initially encountered event -based processing (libevent in C), those\ncallbacks were indeed difficult to wrap my mind around. But I learned to\nstructure the code in the editor, keeping everything together which made it\nmanageable. I 've worked with node for a couple of months now, and I find\npromises to be more confusing, because it obfuscates the callback in my mind,\nand makes it look like ordinary function calls.\n\n~~~\nspriggan3\nThe advantage of promises is that you can return them as a type, you can't do\nthat with a callback. If you fetch something from a database , your data\naccess object can return a promise and let the client code deal with the\nresult. Promises are composable by nature, callbacks are not.\n\n------\nSiVal\nReally, just learn to use callbacks properly. Well, wait, actually, you should\nskip that and start getting used to using promises instead--a big improvement.\nWell, I mean, until next version is ready, and we can start using\nasync/await...until wasm makes better thought-out languages available.\n\nDespite the sounds of this, I do like the idea of having an experimental\nplatform with which to gain experience using wildly different approaches to\nthe wildly changing world of web apps. I don't take it for granted that old\nlanguage concepts will turn out to be the most useful for the web platform.\n\nSo, I'm okay building a website for the PTA or ceramics club with this, and\nI'm very interested in the experiences of others using a wide variety of\ntechnologies and approaches, but I'm not sure Node.js would be a sensible\nfoundation to build a business on.\n\n------\ntonyjstark\nThis article definitely matches with my experience. I did two not all too\ncomplicated projects on the side with Node.js and the the first steps where so\neasy that it completely convinced me to go with it. After a while I tried to\ndig deeper and went to meetups to see whether I do things right as in a\ncommunity accepted way and if I use the right tools and so on. Since then I\nrefer to the Nodejs community as the most hipster programmer community I've\never seen. As soon as a framework was getting near a 1.0 version nobody wanted\nto use it anymore, experimental features were used in production code, it was\nhorrifying. For me that ended this endeavour, I just could not keep up with\nthe pace. I always wondered if it would be different if I would have worked\nfull-time on Nodejs projects.\n\n------\nldehaan\nFrom reading the comments there are Still a lot of misconceptions about Js.\n\njavascript is not new, it's been around since before most of the web devs out\nthere started working in computers.\n\nnodejs supports multiple CPUs.\n\nnodejs is stable.\n\nJavaScript is retarded fast, and it's not c or c++ or any Compiled language,\nand shouldn't be compared to them because that's unhelpful as a measure.\n\nit is the only language for the web which enables you to work in the same\nlanguage on both fronts.\n\nframeworks aren't JavaScript.\n\nnodejs isn't JavaScript.\n\nJavaScript is so flexible that it can be changed to suit the needs of those\nwriting it, so much so that you get whole new dsl's like typescript.\n\nthere are more conversations on the internet about JavaScript than any other\nlanguage being used today.\n\noh and nothing scales if you don't know how to write scalable software, that's\non you, not the language.\n\n------\nbschwindHN\nInteresting analysis. I just finished a year of using Node for implementing an\nHTTP API and a chat server, and found it to be actually pretty pleasant. I'm\nnot chasing the latest and greatest things, there's no ES6, no ORM, and I'm on\nan older version of Node. But it works and has actually been quite stable! The\nthings I've missed are static type checking at compile time, and execution\nspeed (which is less of an issue when you're talking with databases all the\ntime). I'd be happy to write in more detail if anyone has any questions, but I\nfound I had the opposite experience of this author. The situation makes all\nthe difference though.\n\n------\nChris911\nMost of the problems described in the articles can be solved by simply using\npromises. Error handling is centralized in your chain and any function can\nthrow and just like Python or Ruby you can catch anywhere you want. As for\nconsistency between callbacks, promises and generators, just pick one. We\nswitched from callbacks to promises and it was a great move. Error handling\ngreatly improved and the code looks a lot nicer. No more callbacks hell. Ever.\n\nWe switched our backend from Python to Node almost 2 years ago now and it was\na great decision for us. If you handle a code base that deals with a lot of\nasync requests Node is definitely a top contender.\n\n------\ncyberpanther\nI think by reading the comments here and the article, its apparent that\nNode.js just isn't as mature yet. If you know what you're doing, it can be\ngreat, but for the noobs the right way to do things is not easily apparent.\nCouple this with the huge choice in libraries and frameworks, makes Node.js\nharder for now. I think the base is good though and given more time it will\nbecome more easy to wield. This is typical of any new tool. And yes Node.js\nhas been around the block for a while, but it is still newish compared to\nPython, Ruby, PHP, etc. So you're going to pay a new adopter tax still.\n\n------\njrapdx3\nCan't fully agree with the article re: using nodejs in production. A couple of\nyears ago I decided to use nodejs for a rewrite of a web/database app that had\ngotten to be complex and hard to maintain.\n\nAs so often said, it was true for me that the abundance of modules and choices\nin node was at first very confusing.\n\nI eventually figured out that keeping things as simple as possible was my best\napproach. What I came up was a server relying on very few module dependencies\nand written using consistent if not so elegant components. Sure it's kind of\nverbose and far from totally DRY but fairly easy to understand, modify and\nextend.\n\nKey issue was node's \"callback hell\" style of async programming. Of course,\nit's not just node, other languages (Scheme, FP, etc.) can be mind-bending in\na similar way.\n\nThe callback \"inside-out\" locality inversion was initially hard to grasp, but\nonce I caught on it was possible to get the server working the way I needed it\nto. The more recent development of promises, etc., certainly provides\nreasonable ways to reduce the high barriers implicated in using the nodejs\nstyle of async programming.\n\n~~~\nzyxley\nCallbacks definitely become much, much less of a problem once you can turn\neverything into promises.\n\n------\nEdSharkey\nIn my opinion, JavaScript is a toy language. Looking at it, and the Node.js\necosystem by-extension, that way has really helped me be effective with it.\n\nTooling has never been more important to my productivity with a language as it\nhas been with JS. I constantly search for tools to paper over the warts and\npotholes.\n\n------\ngedrap\nThe only clear, objective advantage of using nodejs is that if your\napplication is I/O heavy (e.g. tons of sql queries which can be executed in\nparallel), nodejs event system is helpful and everything you need is pretty\nmuch out of the box. Other thing... it largely depends on personal taste and a\nmatter of convention.\n\nReading his \"Why I\u2019m switching from Python to Node.js\", doesn't seem like he\nwas having an issue with that. And I don't really buy into the \"same language\neverywhere\" argument because come on, how hard is it to learn python, ruby,\netc enough so that you can be productive? Not hard at all, unless you have\nhundreds of cubicles filled with drones.\n\nAnyway, it's good to see that he made some reasonable conclusions after the\nexperiment. That's a good sign :)\n\n~~~\nMichaelGG\nSame language, in theory, is great. Reuse structure definitions. Reuse\nrendering logic or even validation logic (perform checks on both, but make it\neasy to get into client-side). In general, keeping things \"in sync\".\n\nAlso can make it easier to write in SPA style but offload rendering to the\nserver when you need it (particularly first-page or reloads).\n\nWhether or not tooling is good enough to allow this (either with JS or\ncompilers) is another issue.\n\n------\nClobbersmith\nWe use NodeJS pretty extensively at Yahoo for both front end and back end\nservices and it works well. While some of the complaints are valid, it's not\nworth flipping tables over.\n\nPromises are standard in ES6 and it is \"the way\" to handle errors. At least if\nyou want to stay sane.\n\n------\nbtomar\nThough I agree with what you all explained with the big issues with NodeJS,\nyou have to understand its not all of Javascript. Its only server side JS. The\ncreators have clarified, for heavy CPU intensive services, go away from\nNodeJS. As far as frontend is concerned, AngularJS and React are just sugar\ncandy for user interaction and structure. Node filled the gap with an async\nnetwork application in pure JS without the heaviness of Python or traditional\nlanguages. It is a hack as in every day people are finding new ways to use\nNodeJS but I agree, there has to be best practices and less boilerplate (plus\nless silly npm packages for trivial JS tasks).\n\n------\nnodesocket\nI prefer to just use async\n([https://github.com/caolan/async](https://github.com/caolan/async)) for all\ncontrol and error flow. Namely async.auto() can do almost any crazy flow.\n\n------\ndustinlakin\nI think the switch to an async back-end can be more initial work than many\nexpect. It may take some time to feel as productive, but promises become\npowerful and became a game changer for me over my previous work with\ncallbacks. Error handling also becomes manageable.\n\nWhat I really enjoy is jumping into new community and getting to work with\ntools that have built. Choosing the right ones can make or break an\nexperience. I personally enjoyed working with Express and Bookshelf.js/Knex.\n\nI appreciate the authors perspective, but I also don't think this should deter\nanyone from trying out Node. I personally have no overwhelming preference to\nusing a Python or Javascript stack.\n\n~~~\nxentronium\n> Bookshelf.js/Knex\n\nAfter ruby orms, Bookshelf felt very, very underdeveloped. Anything I tried to\ndo beyond \"hello world\" only brought me pain, especially dealing with\nassociations, but honestly just about everything. I guess I've been spoiled,\nbut getting anything done in express/bookshelf combo seemed like a chore.\n\n------\nbillmalarky\nJust FYI, the Koa framework makes node sane again.\n\nCallback hell and error handling are no longer issues in node if you just\nembrace generators or async/await.\n\nWe use Koa in production and serve billions of requests just fine.\n\nIf I had to go back to Express I'd say no.\n\n------\nvelox_io\nThere's a very fine line between between removing too much essential\ncomplexity, and leaving programmers with too many limitations. Or the other\nend where the language overhead overshadows the original task at hand.\n\nFor instance multithreading should be handled by languages and frameworks\n99.9% of the time. Take reading a file (something that should be handled by\nthe language/ framework). Read it asynchronously, structure any dependant code\nclearly (which JavaScript does pretty well), if any problems are detected they\ndisplay/ log the appropriate error. You shouldn't be kneck-deep in callbacks.\n\n------\nspriggan3\nThe biggest problem is dealing with callbacks (and yes even promises use\ncallbacks , and generators need to be wrapped in a cor-routine framework in\norder to work as cor-routines ).\n\nI want to write a quick script doing some busy work , I now have to think\nabout synchronicity even though the script does not need to be non blocking.\nOf course in these circumstances, I want to move back to Ruby or Python, which\nactually let me code the thing I want to code without forcing callbacks on me.\n\nSo when you have to do 20 i/o operations in sequence, using nodejs becomes\nreally tedious.\n\n------\njtchang\nNode is one of those platforms that makes me shudder every time I go looking\nfor solid best practices. It seems to change every 3 months. It's scary (and\ncool) how fast things are changing.\n\n------\npeterashford\nI think the basic problem is that JS is not the right solution for every task\nbut for the web, it's often the only tool available.\n\nI had similar experiences to the OP. I had lots of code written in JS that I\nwas happy with to some extent, but all of it would have been easier / cleaner\n/ more maintainable in a less crap language.\n\n------\narisAlexis\nUsing babel without async await is a mistake IMO should solve almost all your\nproblems and errors. Also the main argument for using js in the back end is\nthat you have the same team working in the front-end too and in any case in\nthe same langage.\n\n------\nthrowanem\ntl;dr: \"I really miss Python's bondage and discipline, so I'm going back to\nit, and I'm going to hate on Node on my way out because I genuinely can't wrap\nmy head around the idea of a paradigm other than the one with which I'm\nfamiliar and comfortable.\"\n\nIt's not even about Node. It's about anything that isn't Python, and doesn't\nhave the Python community's strong \"there is exactly one way to do it\"\ntradition. I'm glad OP has realized that's what works for him. It's a shame he\nlacks the perspective to understand that it's _about_ him.\n\n------\nigl\nAsync-functions are the answer to all his problems. I generally agree on his\nconclusion though: Do small things, don't build big systems.\n\nI hate that JS trys to be this OO-FP hybrid. Jack of all trades, master of\nnone.\n\n------\nswivelmaster\nThis articulates my fears around switching to node very clearly. I've played\nwith it in the past and felt like it would become too difficult to manage with\na large project and lots of contributors.\n\n------\npaulftw\nA year ago one of the reasons to leave Python was poor MongoDB & JSON support,\n12 months later the same author complains about the lack of a decent SQL ORM\nlibrary in js <scratching my head/>\n\nwhile JS is far from perfect, his problem was he was a little bit ahead of\ntime- babel, standard promises & sequelize solve most of the problems. I think\nPython is still superior for serverside, but JS isn't as bad as portrayed in\nthis post, if you slowdown for a couple of weeks to learn how to use it\nproperly (just like any other popular language or framework).\n\n------\nsb8244\nI mused on similar things after getting a _very_ small project shipped. It is\nbased on my experience with Node, Ruby, and Node as of 4 years ago (when I\nfirst learned it).\n\n[https://medium.com/@yoooodaaaa/reflections-on-\nnode-698abecce...](https://medium.com/@yoooodaaaa/reflections-on-\nnode-698abecce1b3)\n\n------\nz3t4\nI think the problem is they chased the latest and greatest.\n\ntips: Always throw errors! Use named functions!\n\n------\njv22222\nUber has done pretty well using node as their core dispatch architecture.\n\n------\ntempodox\nI find this a valid assessment of Node and JS.\n\n------\nco_dh\nwelcome back :)\n\n------\nvacri\nSmall company ops guy here - a bit over a year ago, I used to joke with my\ndevs, asking them \"So, what's this month's recommended way of installing\nnode?\". More recently we've been experiencing dependency hell, which is\nexacerbated by our small team not having enough time to upgrade to the latest\nLTS release. Node is definitely a language that you have to _manage_. It\ndoesn't sit in the background and let you get on with writing stuff.\n\nIs it the right tool for X or Y? I can't say, I'm not a dev. But it does\nrequire a lot of hand-holding and keeping current with the zeitgeist.\n\n------\nhasenj\nEveryone and their aunt wants to publish an npm module. That's why you get a\nton of badly written poorly thought-out packages.\n\n------\nwizard_class\ndoesnt node support modules? thats a way to avoid callback hell\n\n~~~\nfredrb\nHow so?\n\n------\nJabavuAdams\nThanks for this. The Node / Javascript ecosystem just seems like one I don't\nwant to be a part of.\n\nI feel so lucky to have avoided the whole disgusting web stack.\n\n~~~\nbdcravens\nLike the author said, Node isn't a great fit for certain apps. It sounds like\nyours is one of them.\n\n------\nbricss\nAuthor plz, uninstall Node.js, use your so lovely Python and don't make people\nconcerned.\n\n~~~\ntobltobs\nBecause being concerned is a bad thing?\n\n------\nsantoshalper\nNode.js, meteor, et al. is a great example of what happens when you let\ninexperienced developers design a platform and run an ecosystem. Almost every\nounce of focus in this community goes to increasing developer productivity.\nOperational concerns like scalability, security, monitoring, are given the\nbare minimum of focus. In many years of programming in many languages on many\nplatforms I have never seen a worse platform and ecosystem than Node.js in a\nvery popular language (obviously some obscure languages hardly have anything\nbuilt around them at all).\n\nI really think it is setting the programming world back a lot. Not to mention\nwhat a thoroughly shitty language JavaScript is. Being able to code your web\napp in one language is a neat trick, and the ability to talk back and forth\nbetween client and server so seamlessly does kind of feel like magic, but\notherwise, this is a meaningfully worse language/platform that Visual Basic.\n\n------\njondubois\n\\- The dependency instability can be avoided by specifying specific versions\nof your dependencies inside your package.json.\n\n\\- The fact that the ecosystem is evolving quickly is a good thing. Node.js is\nstill one of the fastest growing software development platforms according to\nGoogle trends so you should expect it to change faster than other ecosystems.\n\n\\- ORMs suck (in every language) - They always sucked; ORMs are a massive hack\nintended to fix the impedence mismatch between relational DBs and RESTful\nAPIs. If you used a NoSQL DB with Node.js (such as RethinkDB), your life would\nbe much easier. Nobody in the Node.js community except your grandma cares\nabout ORMs because they're considered legacy technology. If you don't like it,\nthen you can stick to your COBOL and Oracle database.\n\n\\- Node.js lets you choose how you want to handle errors. JavaScript offers an\nError class which exposes a name property (which you can overwrite for each\nerror type) and you can also attach custom properties to Error objects (to\ncarry back more detailed info specific to each Error type). JavaScript is\nreally easy to serialize/deserialize so you can even design your error\nhandling system to be isomorphic (same error handling on the client/browser\nand server). I really enjoy error handling in Node.js/JavaScript - You just\nhave to put some thought into it.\n\n\\- The way of writing async logic is changing. The fact that Node.js is\nkeeping up is a good thing. There is no single right way to handle async\nlogic. Most well-maintained libraries will keep slowly evolving to use the\nnewer features of the language but it's mostly backwards compatible (many\nlibraries support both callbacks and promises).\n\n\\- The standards are not bad; they're evolving and you can choose your own\nstyleguides for your projects. Most JS developers will adapt to new\nstyleguides as they move between companies/projects.\n\n~~~\nflamethroeaway\nIs package.json webscale?\n\n"
}