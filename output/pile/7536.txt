{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7536",
    "text": "Q:\n\nChaining multiple ajax requests with promises\n\nI'm looking to chain multiple ajax requests, something along the lines of:\nget first JSON, if successful move on and get second JSON, if successful make a new object consisting of both JSON data.\n// get first json\n$.getJSON('http://www.json1.com').then(function(json1){\n    return json1\n}).then(function(json1){\n    // get second json\n    $.getJSON('http://www.json2.com').then(function(json2){\n        var both = {}\n        both.one = json1\n        both.two = json2\n        return both\n    })\n})\n\nShould I be nesting .then statements in each other? I'm not completely sure how to get the both variable. \n\nA:\n\n.then(function(json1){\n    return json1\n})\n\nThat's an unnecessary, (nearly) identity call.\n\n.then(function(json1){\n     \u2026;\n\nYou should always return from a then callback, so that the new promise gets a value. You can even return promises, which will be \"unwrapped\"!\n\nShould I be nesting .then statements in each other?\n\nIt doesn't really matter whether you nest them or chain them, that's the great thing about promises. Chaining them reduces the height of your \"pyramid\", so it is considered cleaner, however you cannot access the variables from higher scopes. In your case, you need to access json1, so you have to nest them.\n\nI'm not completely sure how to get the both variable.\n\nWhen you do return from the callbacks, you can get it as the resolution value of the promise that you get back from the then call.\n$.getJSON('http://www.json1.com').then(function(json1){\n    return $.getJSON('http://www.json2.com').then(function(json2){\n        return {one: json1, two: json2};\n    })\n}).then(function(both) {\n    // do something with both!\n});\n\n"
}