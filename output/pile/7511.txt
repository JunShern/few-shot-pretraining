{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": true,
            "reason": "Text contains There are many."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['There are many evaluations with the same eval_number. (0.159)', 'It seems like distinct eval_numbers are being selected, but also distinct created_at columns (which of course are all different). (0.183)']."
        }
    ],
    "doc_id": "7511",
    "text": "Q:\n\nQuery for distinct instance of model + one other field\n\nI have a model called Evaluation. When an evaluation is created, an eval_number is created with it.  There are many evaluations with the same eval_number.\nHere's an example:\n- !ruby/object:Evaluation\n  attributes:\n    id: 2023\n    score: 3\n    created_at: 2013-09-08 13:10:53.000000000 Z\n    updated_at: 2013-09-08 13:10:53.000000000 Z\n    student_id: 26\n    goal_id: 50\n    eval_number: 33\n- !ruby/object:Evaluation\n  attributes:\n    id: 2099\n    score: 4\n    created_at: 2013-09-08 13:19:12.000000000 Z\n    updated_at: 2013-09-08 13:19:12.000000000 Z\n    student_id: 26\n    goal_id: 36\n    eval_number: 34\n- !ruby/object:Evaluation\n  attributes:\n    id: 2100\n    score: 3\n    created_at: 2013-09-08 13:19:12.000000000 Z\n    updated_at: 2013-09-08 13:19:12.000000000 Z\n    student_id: 26\n    goal_id: 37\n    eval_number: 34\n- !ruby/object:Evaluation\n  attributes:\n    id: 2101\n    score: 4\n    created_at: 2013-09-08 13:19:12.000000000 Z\n    updated_at: 2013-09-08 13:19:12.000000000 Z\n    student_id: 26\n    goal_id: 38\n    eval_number: 34\n\nIn a view, I want to show the date that a given evaluation was created in a table header.  It should look like this:\ndate_1  |  date_2  |  date_3  | date_4  |  etc..\n\nTo do this, I need to get distinct evaluation_numbers + the created_at dates that go with them.  I thought that this would help, but it's returning more than one record per eval_number with this code:\n  def eval_date(i)\n    evals = self.goals.first.evaluations\n    eval = evals.select(\"distinct(eval_number), created_at\").all[i]\n    eval.created_at.to_date\n  end\n\nIt seems like distinct eval_numbers are being selected, but also distinct created_at columns (which of course are all different).  This makes the .all[i] basically useless as it's finding the [0], [1], [2], etc element correctly - but there are far more than whatever the given number of i is in the returned array.  \nI want to find a distinct eval_number and load only the created_date that goes with it.  I think I could load the whole record with all attributes, but I don't need them, so I'd rather not.\n\nA:\n\nTry this:\n def eval_date(i)\n    evals = self.goals.first.evaluations\n    eval = evals.order(\"eval_number\").group(:eval_number).all[i]\n    eval.created_at.to_date\n end\n\nPS: if you are calling eval_date repeatedly then cache the evaluations like so\n def eval_date(i)\n    @evals ||= self.goals.first.evaluations.order(\"eval_number\").group(\"eval_number\").all\n    eval = @evals[i]\n    eval.created_at.to_date\n end\n\n"
}