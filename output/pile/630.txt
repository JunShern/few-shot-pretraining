{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "630",
    "text": "Q:\n\nHow would you design an AppEngine datastore for a social site like Twitter?\n\nI'm wondering what would be the best way to design a social application where members make activities and follow other member's activities using Google AppEngine.\nTo be more specific lets assume we have these entities:\n\nUsers who have friends\nActivities which represent actions made by users (lets say each has a string message and a ReferenceProperty to its owner user, or it can use parent association via appengine's key)\n\nThe hard part is following your friend's activities, which means aggregating the latest activities from all your friends.\nNormally, that would be a join between the Activities table and your friends list but thats not a viable design on appengine as there are no join simulating it will require firing up N queries (where N is number of friends) and then merging in memory - very expensive and will probably exceed request deadline...)\nI'm currently thinking of implementing this using inbox queues where creation of a new Activity will fire a background process that will put the new activity's key in the \"inbox\" of every following user:\n\nGetting \"All the users who follow X\" is a possible appengine query\nNot a very expensive batch input into a new \"Inbox\" entity that basically stores (User, Activity Key) tuples.\n\nI'll be happy to heard thought on this design or alternative suggestions etc.\n\nA:\n\nTake a look at Building Scalable, Complex Apps on App Engine (pdf), a fascinating talk given at Google I/O by Brett Slatkin. He addresses the problem of building a scalable messaging service like Twitter.\nHere's his solution using a list property:\nclass Message(db.Model):\n    sender = db.StringProperty()\n    body = db.TextProperty()\n\nclass MessageIndex(db.Model):\n    #parent = a message\n    receivers = db.StringListProperty()\n\nindexes = MessageIndex.all(keys_only = True).filter('receivers = ', user_id)\nkeys = [k.parent() for k in indexes)\nmessages = db.get(keys)\n\nThis key only query finds the message indices with a receiver equal to the one you specified without deserializing and serializing the list of receivers. Then you use these indices to only grab the messages that you want.\nHere's the wrong way to do it:\nclass Message(db.Model):\n    sender = db.StringProperty()\n    receivers = db.StringListProperty()\n    body = db.TextProperty()\n\nmessages = Message.all().filter('receivers =', user_id)\n\nThis is inefficient because queries have to unpackage all of the results returned by your query. So if you returned 100 messages with 1,000 users in each receivers list you'd have to deserialize 100,000 (100 x 1000) list property values. Way too expensive in datastore latency and cpu.\nI was pretty confused by all of this at first, so I wrote up a short tutorial about using the list property. Enjoy :)\n\nA:\n\nI don't know whether it is the best design for a social application, but jaiku was ported to App Engine by it's original creator when the company was acquired by Google, so it should be reasonable.\nSee the section Actors and Tigers and Bears, Oh My! in design_funument.txt. The entities are defined in common/models.py and the queries are in common/api.py.\n\n"
}