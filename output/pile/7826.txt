{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "Domain",
            "passed": false,
            "reason": "Document source unavailable."
        },
        {
            "criterion": "QuestionAnswerStrings",
            "passed": true,
            "reason": "Text contains Q:."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": true,
            "reason": "Text contains ['Q:', 'A:', 'A:', 'A:']."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefix",
            "passed": false,
            "reason": "Found 0 list prefixes. (Min: 5)"
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        }
    ],
    "doc_id": "7826",
    "text": "Q:\n\nPhone number duplication detector\n\nI am doing the POJ 1002 question. My code works fine but the website says the compilation time is more than 2000ms, which is not accepted. How can I improve my time-wise performance?\nProblem Statement\n\nInput \u2014 The input will consist of one case. The first line of the input specifies the number of telephone numbers in the directory (up to 100,000) as a positive integer alone on the line. The remaining lines list the telephone numbers in the directory, with each number alone on a line. Each telephone number consists of a string composed of decimal digits, uppercase letters (excluding Q and Z) and hyphens. Exactly seven of the characters in the string will be digits or letters.\nOutput \u2014 Generate a line of output for each telephone number that appears more than once in any form. The line should give the telephone number in standard form, followed by a space, followed by the number of times the telephone number appears in the directory. Arrange the output lines by telephone number in ascending lexicographical order. If there are no duplicates in the input print the line:\nNo duplicates.\n\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main{\n\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    int total = scan.nextInt();\n    scan.nextLine();                // But why?\n    String[] numbers = new String[total];\n    Map<String, Integer> dict = new TreeMap<String, Integer>();\n    \n    for(int i = 0; i < total; i++) {\n        numbers[i] = scan.nextLine();\n        numbers[i] = convert(numbers[i]);\n        if(!dict.containsKey(numbers[i])) {\n            dict.put(numbers[i], 1);\n        } else {\n            dict.put(numbers[i], dict.get(numbers[i]) + 1);\n        }\n    }\n    \n    scan.close();\n    \n    boolean hasDuplication = true;        \n    for(String number: dict.keySet()) {\n        if(dict.get(number) > 1) {\n            hasDuplication = false;\n            System.out.println(number + \" \" + dict.get(number));\n        }\n    }\n    if(hasDuplication) {\n        System.out.println(\"No duplicates.\");\n    }\n}\n\npublic static String convert(String raw) {\n    raw = raw.replaceAll(\"-\", \"\");\n    raw = raw.toLowerCase();\n    String number = \"\";\n    for(int i = 0; i < raw.length(); i++) {\n        number += parse(raw.charAt(i));\n    }\n    number = number.substring(0, 3) + \"-\" + number.substring(3);\n    return number;\n}\n\npublic static char parse(char digit) {\n    if(digit >= 'a' && digit < 'q') {\n        digit = (char) ((digit-'a') / 3 + '2');\n    } else if(digit > 'q' && digit < 'z') {\n        digit = (char) ((digit-'q') / 3 + '7');\n    }\n    return digit;\n}\n\n}\n\nA:\n\nChomp the new line\n\n    scan.nextLine();                // But why?\n\nNothing to do with performance, but Scanner is skipping nextLine() after using next(), nextInt() or other nextFoo()? explains this.  \nRemove unnecessary data structure\n\n    String[] numbers = new String[total];\n\nYou never use numbers as an array.  You could get rid of it entirely.  \n\n        numbers[i] = scan.nextLine();\n        numbers[i] = convert(numbers[i]);\n        if(!dict.containsKey(numbers[i])) {\n            dict.put(numbers[i], 1);\n        } else {\n            dict.put(numbers[i], dict.get(numbers[i]) + 1);\n        }\n\nReplace numbers[i] with a single String.  \n        String number = convert(scan.nextLine());\n\n        Integer count = dict.get(number);\n        if (count == null) {\n            count = 0;\n        }\n        count++;\n\n        dict.put(number, count);\n\nNow we don't keep an array around for nothing.  \nI also changed the get/put pattern.  This saves having to do both the containsKey check and the get.  \nConsider other data structures\n\n    Map<String, Integer> dict = new TreeMap<String, Integer>();\n\nI would expect a TreeMap to be slower than a HashMap for most applications that depend on insert and read efficiency.  This is especially so since it sorts on keys and what you want is to find all with at least value 2.  You'd need to override the comparison to get that behavior.  \nYou don't use the read behavior that would be helpful.  And you accept the slower writes.  \n        Map<String, Integer> dict = new HashMap<>();\n\nThis should perform faster for larger inputs.  \nPick the right method\n\n    for(String number: dict.keySet()) {\n        if(dict.get(number) > 1) {\n            hasDuplication = false;\n            System.out.println(number + \" \" + dict.get(number));\n        }\n    }\n\nThis is the use case for an entrySet.  \n    for (Map.Entry<String, Integer> entry : dict.entrySet()) {\n        if (entry.getValue() > 1) {\n            hasDuplication = true;\n            System.out.println(entry.getKey() + \" \" + entry.getValue());\n        }\n    }\n\nNow we don't have to do an expensive get lookup operation on each iteration.  \nI'd also switch the meaning of hasDuplication to match the name.  Don't forget to switch it the other two places as well.  \n\n    boolean hasDuplication = true;\n\nto \n    boolean hasDuplication = false;\n\nand \n\n    if(hasDuplication) {\n\nto \n    if (!hasDuplication) {\n\nOther possibilities\nIf this doesn't help, consider splitting reading the input from processing it.  So something like \n    for (int i = 0; i < numbers.length; i++) {\n        numbers[i] = scan.nextLine();\n    }\n\n    scan.close();\n\n    for (String number : numbers) {\n        number = convert(number);\n\n        Integer count = dict.get(number);\n        if (count == null) {\n            count = 0;\n        }\n        count++;\n\n        dict.put(number, count);\n    }\n\nI didn't test this, so you may have to declare a new variable rather than reusing number.  \n\nA:\n\nUse a profiler to measure where the time is spent!\nThat said, your convert method is very inefficient. It uses multiple string operations. You can make it one-pass using  the characters as they come by.\nWe need some extra cases to be able to prevent upper/lowercasing.\npublic static String toBaseForm(String raw) {\n        StringBuilder sb = new StringBuilder();\n        for (char ch : raw.toCharArray()) {\n            if (ch >= 'A' && ch < 'Q') {\n                sb.append((char) ((ch - 'A') / 3 + '2'));\n            } else if (ch >= 'Q' && ch < 'Z') {\n                sb.append((char) ((ch - 'Q') / 3 + '7'));\n            } else if (ch >= 'a' && ch < 'q') {\n                sb.append((char) ((ch - 'a') / 3 + '2'));\n            } else if (ch >= 'q' && ch < 'z') {\n                sb.append((char) ((ch - 'q') / 3 + '7'));\n            } else if (ch >= '0' && ch <= '9') {\n                sb.append(ch);\n            }\n            if (sb.length() == 3) {\n                sb.append('-');\n            }\n        }\n        return sb.toString();\n    }\n\nA:\n\nString allocations\nYou make a number of allocations that may not be obvious:\npublic static String convert(String raw) {\n    raw = raw.replaceAll(\"-\", \"\"); // possibly new string, if contains hyphen\n    raw = raw.toLowerCase(); // possibly new string, if contains uppercase\n    String number = \"\";\n    for(int i = 0; i < raw.length(); i++) {\n        number += parse(raw.charAt(i)); // definitely new string, raw.length() times!\n    }\n    number = number.substring(0, 3) + \"-\" + number.substring(3); // three new strings: sub + sub + result\n    return number;\n}\n\nString is immutable in Java, meaning any operations that result in different char data will result in a different string. String.substring also (usually) creates a new string.\nThe input \"888-GLOP\" ends up creating eleven new strings before returning its final, twelfth string!\nMap.get + Map.put = Map.merge\nif(!dict.containsKey(numbers[i])) { // \u0398(log n)\n    dict.put(numbers[i], 1); // \u0398(log n)\n} else {\n    dict.put(numbers[i], dict.get(numbers[i]) + 1); // \u0398(log n) + \u0398(log n)\n}\n\n// -->\n\ndict.merge(numbers[i], 1, Integer::sum);\n\nStill, you are sorting/comparing strings each time you want to update your map. You could split into two parts: one part that checks whether you have already seen the input before (doesn't need to be sorted), and another that keeps track of your actual duplicates:\nHashSet<String> seen;\nTreeMap<String, Integer> duplicates;\n\n// Set.add returns false if already contained\nif ( !seen.add(number) ) { // \u0398(1)\n  duplicates.merge(number, 1, Integer::sum); // \u0398(log n)\n}\n\n// printing later -- don't forget to add 1 to dupe count!\nduplicates.forEach( (k,v) -> System.out.println( ... (v + 1) ... ); )\n\nAlternatively, you can turn the data around:\nHashMap<String, Integer> frequency;\nTreeSet<String> duplicates;\n\nif ( frequency.merge(number, 1, Integer::sum) > 1 ) { // \u0398(1)\n  duplicates.add(number); // \u0398(log n)\n}\n\nduplicates.forEach( k -> System.out.println( ... frequency.get(k) ... ); )\n\nAlternative implementation\nConsider that:\n\nPhone numbers have a normal form, which is NNN-NNNN, with N being a digit. This makes phone numbers contain 7 digits worth of information. That fits in an int. \u2192 Less memory usage, better cache usage.\nYou don't need to retain the original form. \u2192 We can use destructive methods.\nYour incoming alphabet is limited: uppercase letters, decimal digits, and the hyphen. \u2192 switch-case and/or table parsing are viable.\nYou need to output only the duplicates. \u2192 We don't need to store everything, but we might end up having to.\nYou need to output the duplicates in lexicographical order. \u2192 We don't need to keep everything sorted; only the duplicates.\n\nLeading to:\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    final Scanner in = new Scanner(System.in);\n    int count = in.nextInt();\n\n    /* We split duplicate detection in an unsorted part that just saves whether\n     * we've seen it before, and a sorted part that stores actual duplicates in\n     * lexicographical order. */\n    final Set<Integer> seen = new HashSet<>();\n    final NavigableMap<Integer, Integer> duplicates = new TreeMap<>();\n\n    while ( count-- > 0 ) {\n      String strnum = in.next();\n      final Integer number = parse(strnum);\n\n      if ( !seen.add(number) ) {\n        // number of dupes is number of encounters minus one\n        duplicates.merge(number, 1, Integer::sum);\n      }\n    }\n\n    if ( duplicates.isEmpty() ) {\n      System.out.println(\"No duplicates.\");\n    } else {\n      for ( Map.Entry<Integer, Integer> duplicate : duplicates.entrySet() ) {\n        // don't forget to add one to the dupe count to get total count\n        System.out.println(format(duplicate.getKey()) + \" \" + (duplicate.getValue() + 1));\n      }\n    }\n  }\n\n  /** Formats a parsed phone number to its normal form (NNN-NNNN). */\n  static String format(int phoneNumber) {\n    final int prefix = phoneNumber / 10000;\n    final int suffix = phoneNumber % 10000;\n    return String.format(\"%03d-%04d\", prefix, suffix);\n  }\n\n  /** Parses an unformatted phone number string, considering only the alphanumerics.\n    * Does not guard for overflow. */\n  static int parse(String number) {\n    int retval = 0;\n    for ( int i = 0; i < number.length(); i++ ) {\n      int digit;\n      final char c = number.charAt(i);\n      switch ( c ) {\n        case '0':\n          digit = 0;\n          break;\n\n        case '1':\n          digit = 1;\n          break;\n\n        case '2': case 'A': case 'B': case 'C':\n          digit = 2;\n          break;\n\n        case '3': case 'D': case 'E': case 'F':\n          digit = 3;\n          break;\n\n        case '4': case 'G': case 'H': case 'I':\n          digit = 4;\n          break;\n\n        case '5': case 'J': case 'K': case 'L':\n          digit = 5;\n          break;\n\n        case '6': case 'M': case 'N': case 'O':\n          digit = 6;\n          break;\n\n        case '7': case 'P': case 'R': case 'S':\n          digit = 7;\n          break;\n\n        case '8': case 'T': case 'U': case 'V':\n          digit = 8;\n          break;\n\n        case '9': case 'W': case 'X': case 'Y':\n          digit = 9;\n          break;\n\n        default:\n          continue;\n      }\n\n      retval = 10 * retval + digit;\n    }\n\n    return retval;\n  }\n}\n\n"
}