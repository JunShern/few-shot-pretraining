{
    "criteria": [
        {
            "criterion": "AllDocuments",
            "passed": true,
            "reason": "All documents pass."
        },
        {
            "criterion": "QuestionAnswerStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "FullyStructured",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStrings",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesStringsV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ListPrefixV2",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesMinimalEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesSynonymsEmbed",
            "passed": false,
            "reason": "Does not meet criterion."
        },
        {
            "criterion": "ExamplesDiverseEmbed",
            "passed": true,
            "reason": "Text contains ['Although the basic set of file formats supported by UNIGINE out-of-the-box includes the most commonly used ones, in some cases you may need to import models or scenes in some specific file format. (0.156)', 'An example of a scene in our custom format containing all available elements is given below. (0.186)']."
        }
    ],
    "doc_id": "2642",
    "text": "UNIGINE's Import System allows you to import models and scenes in various external formats (FBX, DAE, OBJ, etc.). Although the basic set of file formats supported by UNIGINE out-of-the-box includes the most commonly used ones, in some cases you may need to import models or scenes in some specific file format. Fortunately the Import System can be extended to support any custom file format.\nImplement your own custom importer as a plugin.\nCreate your own import pre-processor.\nUse your custom importer to bring a scene stored in a custom file format to UNIGINE.\nSo, in this example we are going create a custom importer for a custom file format. Let it be an xml-based format in which we declare our scene as a hierarchy of nodes that have a transformation and can have a mesh, light or camera attribute. Let our file format have a .myext exstension. An example of a scene in our custom format containing all available elements is given below.\nAt the end of this example we're going to have this model imported to UNIGINE's world and saved in UNIGINE's native file formats in the specified folder. But before we get started, a little bit of theory (as key points).\nUNIGINE's API offers us a set of classes for implementing customized model import.\nA custom importer should be inherited from the Importer class.\nA custom import processor should be inherited from the ImportProcessor class.\nEnough words! Let's get to business! The code below is supplemented with comments explaining the basic aspects of the process.\nAs you know each importer should be implemented as a plugin. So we're going to create a C++ plugin.\nAs for plugin implementation, it's also simple. Include UnigineImport.h for basic import functionality and our importer's header file (MyImporter.h).\nTo learn more about creating a C++ plugin please refer to this article.\nFirst we should define some intermediate data structures to which all parameters of imported scene elements are to be extracted. And we should declare a common template for UserData to be able to assign data to the import structures.\nExtract data from the input file, put it to the corresponding import structures (ImportMesh, ImportLight, etc.) and add them to the import scene.\nUse pre-processor(s) to prepare scene metadata when necessary (e.g. merge all static meshes into a single one, optimize vertex cache, etc.). In our example we're going to strip off light color information if the corresponding option (make_lights_white) is set.\nSave generated UNIGINE objects to *.node and *.mesh files. This part is performad by the DefaultProcessor, so we do nothing here.\nThese default values can be changed in your application when using the importer via the Importer::setParameter*() methods.\nFirst, let us create a new project named MyProject, that will use our library. Let it be a simple project using UnigineScript only (the idea for C++ is the same).\nPut our plugin library module (a *.dll, *.so or *.dylib file) to our project's bin directory.\nMake sure your project's binary and plugin library have the same bitness and version.\nThe same can be done in the project's system logic via Engine::addPlugin() on the C++ side or via Engine.addPlugin() on the C# side of the project.\nUse the plugin in our project. Let's add some lines of code to the init() method of the world script (MyProject.cpp file) to demonstrate the idea.\nmy_importer.init(\"my_scene.myext\", ~0);\t\t\t\t// initializing the importer with default import flags IMPROT_LIGHTS, IMPORT_MESHES, IMPORT_CAMERAS, etc.\nNow when we launch our project with MyImporter plugin loaded and MyProject world opened the scene will imported to the world and corresponding files are saved to MyProject/data/output_folder/ folder."
}